\documentclass[twoside]{scrbook}
\KOMAoptions{fontsize=12pt}
\KOMAoptions{paper=a4}
\KOMAoptions{draft=true}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[colorlinks=true,linkcolor=black,citecolor=black,filecolor=black,urlcolor=black,plainpages=false,pdfpagelabels,breaklinks=true]{hyperref}
\usepackage{todonotes}
\usepackage{tikz-timing}
\usepackage{listings}
\usepackage{makeidx}                              % index of key words
\makeindex
\title{Multi-user mixed-signal ASIC workflow}
\subtitle{Stuff I learned about making ASICs}
\author{Andreas Hartel}
%\institution{Heidelberg University}
\lstdefinestyle{BashInputStyle}{
  language=bash,
  basicstyle=\small\sffamily,
  numbers=left,
  numberstyle=\tiny,
  numbersep=3pt,
  frame=tb,
  columns=fullflexible,
  backgroundcolor=\color{yellow!20},
  linewidth=0.9\linewidth,
  xleftmargin=0.1\linewidth
}
\newcommand{\wscript}{\texttt{wscript}}
\newcommand{\brick}{\texttt{brICk}}
\begin{document}
\maketitle
\tableofcontents
\cleardoublepage
\dictum[Clarence "Kelly" Johnson]{Keep it simple, stupid!}

\chapter{Overall repository structure}
\section{Basic concepts}
\begin{description}%[ --- ]{repository}
	\item[A repository]
		contains zero or more units and zero or more tasks, with each task residing in its own rundir.

		If a rundir uses files (or rundirs) from the repository it is located in, the repository is referred to as local.
		Otherwise the rundir uses external repositories.
	\item[A rundir]
		is a directory containing at least a \wscript and a link to the waf binary. It defines one or more tasks.
	\item[A unit]
		can contain basically the following types of files:
		\begin{itemize}
			\item Virtuoso schematics and layouts
			\item Verilog or VHDL source code (for digital RTL implementation or as a behavioral replacement for an analog unit).
			\item constraints
			\item Abstracts of anlog units (consisting of lib files, lef files or GDSII files).
			\item Verilog or VHDL netlists generated with a synthesis tool out of RTL descriptions.
		\end{itemize}

		Every unit contains a file that specifies which files in this unit are either present as source or are generated by which rundir.
		Sources and generating rundirs can both be located in external repositories.
		The recursing rundir can then decide (upon existance of external repositories) whether to use a local file or rundir as an input or to generate its necessary inputs.
	\item[A task]
		takes one or more input files of one or more units and modifies them according to the specification in the \wscript.
		A task is specified via a wscript and executed with waf.

		Example tasks:
		\begin{itemize}
			\item Abstract generation out of a full-custom layout 
			\item Synthesis of an RTL module
		\end{itemize}

		A task has to be able to fall back to local input files if an external repository is not present and its input files are therefore missing.

		A task may recurse into unit or rundir directories of the local repository or other external repositories.
	\item[A result]
		is an outcome of a task that can be re-used as an input to other tasks.
\end{description}

A task recurses into a unit to receive a source list of the files that are present in this unit.
The wscript inside the unit can also define sources that are only present in external repositories.
If the referenced external repository is present, the task can work on the external repository's files or rundirs.
If the task is only possible if the external repository is present the task will be skipped.
If the task can proceed with the present input files the task will continue.

\subsection{Examples}
\begin{itemize}
	\item A chip toplevel RTL simulation can only proceed if all external repositories containing RTL code are present or if there is a gate-level netlist or behavioral representing the missing modules.
	\item A place \& route task can depend on synthesized netlists of two modules in two different units. To gather all necessary inputs it has to perform the following steps:
		\begin{enumerate}
			\item Recurse into the directory of unit0 and load it's source list.
			\item Check whether any files in unit0's source list are results of other tasks and whether the referenced tasks are present.
			\item Execute the referenced tasks if necessary.
			\item Recurse into the directory of unit1 and load it's source list.
			\item Check whether any files in unit1's source list are results of other tasks and whether the referenced tasks are present.
			\item Execute the referenced tasks if necessary.
			\item Execute the rundir's own tasks.
		\end{enumerate}
\end{itemize}

Therefore, a unit has to specify it's source files and results that can replace it's source files if they are not present.

Every rundir has to specify it's inputs and outputs (done by waf anyway).

\textbf{In the end, a recurse into a unit directory is basically an indirect recurse into one or more rundirs with fallback solutions for missing rundirs or source files!}

\chapter{Version control with git}
\section{Basic tasks}
\todo{Make a cake}\missingfigure{Hallo}
\section{Managing multiple repositories}
To get a copy of the repository you want to work with and enter it, type the following code. 
\begin{lstlisting}[style=BashInputStyle]
git clone URL/of/your/repository
cd repository
\end{lstlisting}

The feature that git offers to mangage multiple repositories with one top-level repository, is called submodules\index{submodule}.
Submodules are therefore other git repositories and git allows you to specify which state of the submodule(s) belong to a certain commit of your main repository.
To be able to work with multiple repositories you need to initialize git's submodule feature.
This has to be done every time someone has changed the .gitmodules file by adding a submodule with \lstinline[style=BashInputStyle]'git submodule add' and you have just pulled the supermodule and want to work with the new submodule(s).
\begin{lstlisting}[style=BashInputStyle]
git submodule init
\end{lstlisting}

If you want to add another submodule to a repository type the following code.
This can only be done after you've initialized the submodule feature.
Git will automatically clone the submodule into your repository.
Afterwards you'll have to commit your submodule's current state (HEAD commit) to your supermodule.
\begin{lstlisting}[style=BashInputStyle]
git submodule add URL/of/your/submodule optional/path
git commit -m ``added submodule''
\end{lstlisting}

Any time you want to want to update your submodules your can just type the following.
This will bring your submodules to the state that has most recently been committed to your supermodule.
\begin{lstlisting}[style=BashInputStyle]
git submodule update
\end{lstlisting}

If you want to commit the current state of a submodule to your supermodule, you can just added the directory name of your submodule as if it were a normal file.
\begin{lstlisting}[style=BashInputStyle]
git add path/to/your/submodule
git commit -m ``changed submodule''
\end{lstlisting}
If multiple users commit different states of a submodule to the supermodule and a submodule's state has to be merged, then git will choose the submodule state of the later commit.

If you want to ignore a submodule completely (i.e. \lstinline[style=BashInputStyle]'git submodule update' should not try to update it) you have to de-initialize the repository. This will not remove the submodule's directory or stage changes to be commited.
It is useful when you don't have access to the submodules URL. This feature needs at least version 1.8.3 of git.
\begin{lstlisting}[style=BashInputStyle]
git submodule deinit path/to/your/submodule
\end{lstlisting}

\begin{appendix}
\chapter{Usage of existing \brick tools}
brick init

command line options: --users, --units, --rundirs

Gernerates a basic directory structure with given rundirs, user dirs and unit dirs.

Every user dir already contains some basic cds and cadence files.

Every unit dir already contains the subdirectories cdslib, source, abstract and constraints.

Every rundir contains an empty wscript and a link to the waf binary which is also copied to the project root.

Also creates the doc directory.

A .gitignore file is also already created.

\chapter{timing}
\def \degr {${}^\circ $}
\begin{tikztimingtable}
Clock 128\ , MHz 0\degr & H 2C N(A1) 8{2C} N(A5) 3{2C} G \\
Clock 128\ , MHz 90\degr & [C] 2{2C} N(A2) 8{2C} N(A6) 2{2C} C \\
Clock 128\ , MHz 180\degr & C 2{2C} N(A3) 8{2C} N(A7) 2{2C} G \\
Clock 128\ , MHz 270\degr & 3{2C} N(A4) 8{2C} N(A8) 2C C \\
Coarse Pulse & 3L 16H 6L \\
Coarse Pulse - Delayed 1 & 4L N(B2) 16H N(B6) 5L \\
Coarse Pulse - Delayed 2 & 5L N(B3) 16H N(B7) 4L \\
Coarse Pulse - Delayed 3 & 6L 16H 3L \\
\\
Final Pulse Set & 3L 16H N(B5) 6L \\
Final Pulse $\overline{Reset}$ & 6L N(B4) 16H 3L \\
Final Pulse & 3L N(B1) 19H N(B8) 3L \\
\extracode
\tablerules
\begin {pgfonlayer}{background}
\foreach \n in {1,...,8}
\draw [ help lines ] (A\n) -- (B\n) ;
\end {pgfonlayer}
\end{tikztimingtable}

\begin{tikzpicture}[ timing , thick ,
timing/inline node/.style={coordinate ,
shift={(0.05,-.5)}}]
\timing(0,2) { hH N (A) LHLHL };
\timing(0,0) { HLH N (B) LHLl };
\draw [ orange , semithick ]
(A) ellipse (.2 and .6) +(0 , -0.6) coordinate (Ax)
(B) ellipse (.2 and .6) +(0 ,+0.6) coordinate (Bx) ;
\draw [ orange , semithick , ->]
(Ax) parabola [ bend pos =0.5] (Bx) ;
\end{tikzpicture}

\definecolor{bgblue}{rgb}{0.41961,0.80784,0.80784}
\definecolor{bgred}{rgb}{1,0.61569,0.61569}
\definecolor{fgblue}{rgb}{0,0,0.6}
\definecolor{fgred}{rgb}{0.6,0,0}
\begin{tikztimingtable}[timing/slope=0,
timing/coldist=2pt,xscale=2,yscale=1.1,semithick]
\scriptsize clock&7{C}\\
S&.75L h 2.25L H LLl[fgblue]\\
R&1.8L .8H 2.2L 1.4H 0.8L[fgblue]\\
Q&L .8H 1.7L 1.5H LL\\
$\overline{\mbox{Q}}$&H .8L 1.7H 1.5L HH\\
Q&LHHHHLL[fgred]\\
$\overline{\mbox{Q}}$&HLLLLHH[fgred]\\
\extracode
\begin{pgfonlayer}{background}
\shade[right color=bgblue,left color=white]
(7,-8.45)rectangle(-2,-4.6);
\shade[right color=bgred,left color=white]
(7,-12.8)rectangle(-2,-8.6);
\begin{scope}[gray,semitransparent,semithick]
\horlines{}
\foreach \x in{1,...,6}
\draw(\x,1)--(\x,-12.8);
%similar:\vertlines{1,...,6}
\end{scope}
\node[anchor=south east,inner sep=0pt]
at(7,-8.45){\tiny clocked};
\node[anchor=south east,inner sep=0pt,fgred]
at(7,-12.8){\tiny positiveedgetriggered};
\end{pgfonlayer}
\end{tikztimingtable}
\end{appendix}

\backmatter
\printindex
\end{document}

