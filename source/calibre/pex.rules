#!tvf

tvf::VERBATIM {


// xCalibre/calibre  RC/LVS command file based on the follow calibre command file//
/////////////////////////////////////////////////////////////////////////////////
// 
//   @(#) TSMC 65nm CALIBRE LVS/RC COMMAND FILE 
//   @(#) TSMC 65 NM CMOS LOGIC GENERAL PURPOSE  DEVICE FORMATION EXAMPLES AND LVS PROPERTIES  
//   @(#) DEVICE FORMATION EXAMPLE AND LVS PROPERTIES DOCUMENT: T-N65-CL-LS-001 V1.6  
//   @(#) COMMAND FILE DOCUMENT : T-N65-CL-LS-001-C1 
//   @(#) COMMAND FILE VERSION : V1.6b_pre061711 
//   @(#) COMMAND FILE METAL SCHEME : 1P9M 
//   @(#) COMMAND FILE DATE : 06/17/2011 
//   @(#) EDA TOOL VERSION : CALIBRE 2009.2_18.12(LVS) ; StarXtract 2010.12-SP2(CCI) 
//   @(#) SPICE MODEL TITLE        : 65nm GPLUS eDRAM Spice Model (OD3:1.8V, eDRAM_Cell:1.0V) 
//   @(#) DOC. NO.	         : T-N65-CE-SP-003 
//   @(#) SPICE MODEL VERSION      : v1.1  
//   @(#) SPICE MODEL RELEASE DATE : Mar. 31, 2009  
//   @(#) SPICE MODEL TITLE        : 65nm Low-Power eDRAM  Spice Model (OD3:2.0V, eDRAM_Cell:1.2V) 
//   @(#) DOC. NO.	         : T-N65-CE-SP-002 (Not support sense amplifier devices) 
//   @(#) SPICE MODEL VERSION      : v1.1  
//   @(#) SPICE MODEL RELEASE DATE : Apr. 06, 2009 
//   @(#) SPICE MODEL TITLE        : 65nm LOGIC Low Power Salicide Low-K Spice Model (1.2V) ( CLN65LP ) 
//   @(#) DOC. NO.	         : T-N65-CL-SP-009 
//   @(#) SPICE MODEL VERSION      : v1.3  
//   @(#) SPICE MODEL RELEASE DATE : Jun. 05, 2009  
//   @(#) SPICE MIDEL TITLE        : 65nm LOGIC G+ Salicide Low-L 1.0v&1.8v Spice Model (1.0V) ( CLN65G+ ) 
//   @(#) DOC. NO.	         : T-N65-CL-SP-031 
//   @(#) SPICE MODEL VERSION      : v1.3  
//   @(#) SPICE MODEL RELEASE DATE : May. 18, 2011 
//   @(#) SPICE MODEL TITLE        : 65nm LOGIC SALICIDE Low-K IMD Spice Model (1.2V/1.0V/2.5V) (CLN65LPG )  
//   @(#) DOC. NO.	         : T-N65-CL-SP-034-P1  
//   @(#) SPICE MODEL VERSION      : v1.1p1  
//   @(#) SPICE MODEL RELEASE DATE : Dec. 28, 2007  
//   @(#) SPICE MIDEL TITLE        : 65nm LOGIC LP Salicide Low-K Spice Model (1.2V/3.3V) ( CLN65LP ) 
//   @(#) DOC. NO.	         : T-N65-CL-SP-040-P1    
//   @(#) SPICE MODEL VERSION      : v1.2p1  
//   @(#) SPICE MODEL RELEASE DATE : Nov. 15, 2007 
//   @(#) SPICE MIDEL TITLE        : 65nm LOGIC G+ Salicide Low-K Spice Model (1.0v&2.5v) ( CLN65G+ ) 
//   @(#) DOC. NO.	         : T-N65-CL-SP-041-P1    
//   @(#) SPICE MODEL VERSION      : v1.3p1  
//   @(#) SPICE MODEL RELEASE DATE : Dec. 17, 2007  
//   @(#) SPICE MIDEL TITLE        : 65nm LOGIC Salicide Low-K Spice Model (1.0V) ( CLN65ULP ) 
//   @(#) DOC. NO.	         : T-N65-CL-SP-055    
//   @(#) SPICE MODEL VERSION      : v1.2  
//   @(#) SPICE MODEL RELEASE DATE : May. 15, 2009 
//   @(#) SPICE MODEL TITLE        : 65nm HVMOS SALICIDE Low-K IMD Spice Model (2.5V) (CLN65LPHV) (NW approach) 
//   @(#) DOC. NO.                 : T-N65-CL-SP-070    
//   @(#) SPICE MODEL VERSION      : v1.1 
//   @(#) SPICE MODEL RELEASE DATE : Sep. 16, 2010    
//   @(#) SPICE MODEL TITLE        : 65nm Mixed-Signal SALICIDE Low-K IMD Spice Model (1.2V/2.5V) (CMN65LP 1P9M+AL_RDL) 
//   @(#) DOC. NO.	         : T-N65-CM-SP-002    
//   @(#) SPICE MODEL VERSION      : v1.3  
//   @(#) SPICE MODEL RELEASE DATE : Jun. 08, 2009  
//   @(#) SPICE MODEL TITLE        : 65nm Mixed-Signal SALICIDE Low-K IMD Spice Model (1.0V/1.8V) (CMN65G+) 
//   @(#) DOC. NO.	         : T-N65-CM-SP-005    
//   @(#) SPICE MODEL VERSION      : v1.3  
//   @(#) SPICE MODEL RELEASE DATE : Mar. 31, 2011 
//   @(#) SPICE MODEL TITLE        : 65nm Mixed-Signal SALICIDE Low-K IMD Spice Model (1.0V/2.5V) (CMN65G+) 
//   @(#) DOC. NO.	         : T-N65-CM-SP-006    
//   @(#) SPICE MODEL VERSION      : v1.3 
//   @(#) SPICE MODEL RELEASE DATE : Mar. 31, 2011 
//   @(#) SPICE MODEL TITLE        : 65nm Mixed-Signal RF SALICIDE Low-K IMD Spice Model (1.2/2.5/over-drive 3.3V) (CRN65LP) 
//   @(#) DOC. NO.	         : T-N65-CM-SP-007    
//   @(#) SPICE MODEL VERSION      : V1.5 
//   @(#) SPICE MODEL RELEASE DATE : Sep. 01, 2009 
//   @(#) SPICE MODEL TITLE        : 65nm Mixed-Signal RF SALICIDE Low-K IMD Spice Model (1.2/3.3V) (CRN65LP) 
//   @(#) DOC. NO.	         : T-N65-CM-SP-012    
//   @(#) SPICE MODEL VERSION      : V1.4 
//   @(#) SPICE MODEL RELEASE DATE : Sep. 18, 2009 
//   @(#) SPICE MODEL TITLE        : 65nm Mixed-Signal SALICIDE Low-K IMD Spice Model (1.2V/3.3V) (CMN65LP 1P9M+AL_RDL) 
//   @(#) DOC. NO.	         : T-N65-CM-SP-014    
//   @(#) SPICE MODEL VERSION      : v1.0  
//   @(#) SPICE MODEL RELEASE DATE : May. 14, 2007 
//   @(#) SPICE MODEL TITLE        : 65nm Mixed-Signal RF SALICIDE Low-K IMD Spice Model (1.0V/2.5V) (CRN65G+) 
//   @(#) DOC. NO.	         : T-N65-CM-SP-018    
//   @(#) SPICE MODEL VERSION      : v1.0  
//   @(#) SPICE MODEL RELEASE DATE : Dec. 04, 2007  
//   @(#) SPICE MODEL TITLE        : 65nm Mixed-Signal RF SALICIDE Low-K IMD Spice Model (1.0V) (CRN65G+ RDK) 
//   @(#) DOC. NO.	         : T-N65-CM-SP-027    
//   @(#) SPICE MODEL VERSION      : v0.1 
//   @(#) SPICE MODEL RELEASE DATE : Dec. 30, 2010 
//   @(#) SPICE MODEL TITLE        : 65nm Mixed-Signal RF SALICIDE Low-K IMD Spice Model (1.2/2.5/over-drive 3.3V) (CRN65LP) 
//   @(#) DOC. NO.	         : T-N65-CM-SP-034    
//   @(#) SPICE MODEL VERSION      : v0.01 
//   @(#) SPICE MODEL RELEASE DATE : Jan. 10, 2011 
//   @(#) SPICE MODEL TITLE        : 65nm Mixed-Signal RF SALICIDE Low-K IMD Spice Model (1.2/2.5/over-drive 3.3V) (CRN65LP) 
//   @(#) DOC. NO.	         : T-N65-CM-SP-036    
//   @(#) SPICE MODEL VERSION      : v1.5 
//   @(#) SPICE MODEL RELEASE DATE : Jan. 14, 2011 
//   @(#) SPICE MODEL TITLE        : 65nm LOGIC G-process SRAM Spice Model (CLN65G SRAM) 
//   @(#) DOC. NO.	         : CLN65G_sr_v1d1.l    
//   @(#) SPICE MODEL VERSION      : v1.1  
//   @(#) SPICE MODEL RELEASE DATE : Nov. 30, 2006    
//   @(#) SPICE MODEL TITLE        : 65nm LOGIC LPG SRAM Spice Model (CLN65LPG SRAM) 
//   @(#) DOC. NO.	         : CLN65LPG_sr_v1d0.l    
//   @(#) SPICE MODEL VERSION      : v1.0  
//   @(#) SPICE MODEL RELEASE DATE : Mar. 26, 2006    
//   @(#) SPICE MODEL TITLE        : 65nm LOGIC ULP SRAM Spice Model (CLN65ULP SRAM) 
//   @(#) DOC. NO.	         : CLN65ULP_sr_v1d0.l    
//   @(#) SPICE MODEL VERSION      : v1.0  
//   @(#) SPICE MODEL RELEASE DATE : Mar. 28, 2007    
//   @(#) SPICE MODEL TITLE        : 65nm LOGIC LPG SRAM Spice Model (CLN65LPG SRAM) 
//   @(#) DOC. NO.	         : CLN65LPG_sr_v0d1_****.l    
//   @(#) SPICE MODEL VERSION      : v0.1  
//   @(#) SPICE MODEL RELEASE DATE : Jan. 31, 2008    
//   @(#) SPICE MODEL TITLE        : 65nm LOGIC LP SRAM Spice Model (CLN65LP SRAM) 
//   @(#) DOC. NO.	         : CLN65LP_sr_v1d2.l    
//   @(#) SPICE MODEL VERSION      : v1.2  
//   @(#) SPICE MODEL RELEASE DATE : Oct. 13, 2006    
// 
//   TSMC has developed this deck using Mentor Graphics proprietary SVRF and TVF formats.  
//   The deck is to be used only in Calibre tools  
// 
////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////// 
// DISCLAIMER 
// 
// This file usually contains the super set of device extraction rule at TSMC
// processes. However, all of device in basic deck may not be offered at current
// SPICE model. PLEASE ALWAYS REFER TO THE CORRESPONDING SPICE MODEL DOCUMENT
// FOR ANY DEVICE YOU WOULD LIKE USE.
// 
// The information contained herein is provided by TSMC on an "AS IS" basis 
// without any warranty, and TSMC has no obligation to support or otherwise 
// maintain the information.  TSMC disclaims any representation that the 
// information does not infringe any intellectual property rights or proprietary 
// rights of any third parties.  There are no other warranties given by TSMC, 
// whether express, implied or statutory, including, without limitation, implied 
// warranties of merchantability and fitness for a particular purpose. 
// 
// STATEMENT OF USE 
// 
// This information contains confidential and proprietary information of TSMC. 
// No part of this information may be reproduced, transmitted, transcribed, 
// stored in a retrieval system, or translated into any human or computer 
// language, in any form or by any means, electronic, mechanical, magnetic, 
// optical, chemical, manual, or otherwise, without the prior written permission 
// of TSMC.  This information was prepared for informational purpose and is for 
// use by TSMC's customers only.  TSMC reserves the right to make changes in the 
// information at any time and without notice. 
// 
//////////////////////////////////////////////////////////////////////////////// 
// 
//                           CHANGE HISTORY 
//  
//   Date     version   Who                      Description 
// ---------- ------- --------- ------------------------------------------------- 
//   
// Version Change Notice:  
//    
// 06/22/2006  V1.1b  K.M.Liu   1) The logic device is base on the deck version 1.1b 
//             pre_062206       2) The RF devices are following the spice model version v0p2 
//	                      3) Added layers OD25_33(18;3) ; OD25_18(18;4) ; 
//                              4) Change the layer name from P3 to p3; from CROWN to crown 
//			         from SNCT to blc 
//                              5) Added MAC layer for the mismatching devices 
//			      6) Remove the POFUSE layer 
//			      7) Added layer CAP1P5(148:115) for 1.5f Cap. unit 
//			      8) Added layer CAP2P0(148:120) for 2.0f Cap. unit 
//			      9) Added PROBE layers 
// 
// 08/02/2006 V1.1b   Yating Chuang 
//            pre_080206        1) Mapping inter metal resistor to rmxw, top metal resistor to rmzw. 
//                              2) Revise MIM connection.   
// 
// 08/07/2006 V1.1b   Yating Chuang 
//            pre_080706        1) Refine CRTMOM.  
//	    
// 10/16/2006 V1.2a   Yating Chuang 
//                              1) Revise poly_rf, define poly interact with DRAIN as poly_rf. 
//	                      2) Add ndio_w, pdio_w. 
//                              3) DFM LPE enhancement, add option BY SHAPE. 
// 	                      4) Exclude SRAM region in DFM LPE extraction.           
//			      5) Remove switch "#DFEINE MODEL_NAME". 
//			      6) DFM and WPE enhancement. 
// 
// 11/09/2006 V1.2b   Yating Chuang 
//            pre110906         Follow CRN65 spice model v1.0p5 update. 
//                     	      Generic update :         
//	             	      1) Revise poly(poly interconnection) and poly2(crtmom terminal). 
//		     	      2) Add device MIMCAP_SIN_3T. 
//		     	      3) Rename device MIMCAP_SIN, merge MIMCAP_1P5_SIN, MIMCAP_2P0_SIN, and newly added MIMCAP_1P0_SIN. 
//		              MMRF update : 
//	             	      1) Add nmos_rf no dnw devices, mapping to the original nmos_rf devices. 
//	        	      2) Add device MIMCAP_WOUM_SIN_RF, mim cap w/o under metal. 
//			      3) Rename device MIMCAP_UM_SIN_RF, merge MIMCAP_UM_1P5_SIN_RF, MIMCAP_UM_2P0_SIN_RF, and newly added MIMCAP_UM_1P0_SIN_RF.  
//			      4) Refine inductor, add a dummy layer IND_NR to define RF inductor NR. 
// 
// 12/25/2006 V1.2b   Yating Chuang 
//            pre122506	      Generic update : 
//	                      1) Remove tvia, using the original VIAx( exclude mimcap VIAx ) instead of tvia. 
//                              2) Mapping inter metal resistor to rmxw, top metal resistor to rmzw. 
//			      3) Add nch_25od_mac,pch_25od_mac, and nch_25_dnwod_mac. 
//			      4) Follow CMN65 spice model v1.0p1 update, add nch_na25_mac. 
//			      5) Add MOMDMY21, exclude dummy OD under MOM device. 
//			       
// 02/14/2007 V1.2b2   Yating Chuang 
//                              Follow CRN65LP spice model v1.0 update. 
//			      Generic update : 
//			      1) Add nonUTM inductors, spiral_sym_mza_a, spiral_std_mza_a, and spiral_sym_ct_mza_a. 
//			      2) Add nomUTM inductors( not general offered, no model ), spiral_sym_mz_x, spiral_std_mz_x, and spiral_sym_ct_mz_x. 
//			      3) Follow T-N65-CL-SP-034 v0.1 spice model, cover layer DCO(90;0) for LPG devices. 
//			         Add LPG devices, nch_lpgna, nch_lpg, nch_lpghvt, pch_lpg, pch_lpghvt, pdio_lpg, ndio_lpg, pdio_lpghvt, ndio_lpghvt, ndio_lpgna, nmoscap_lpg. 
//			      4) Follow SRAM team's request. 
//			         (50;12) for _dpsr, _hvtdpsr, (50;13) for _dphcsr, _hvtdphcsr.   
//			         Add SRAM devices, nchpg_dpsr, nchpd_dpsr, nchpg_hvtdpsr, nchpd_hvtdpsr, nchpg_dphcsr, nchpd_dphcsr, nchpg_hvtdphcsr, nchpd_hvtdphcsr. 
//			      5) Add CB/CB2 into AP connection.     
//			      6) Add cross-couple crtmom, crtmom_mx. 
//			      7) Add nch_25ud_mac, nch_25_dnwud_mac, pch_25ud_mac 
//			      8) Revise false parameter in parallel crtmom devices.   
//			      9) Add switch "NW_RING". 
//			      10) Follow T-N65-CL-SP-041-P1 v1.2p2 spice model, add nch_na25od, nch_na25ud, nch_na25od_mac, nch_na25ud_mac, and nch_na33_mac. 
//			      MMRF update : 
//			      1) Rename UTM inductors, add postfix _mu_z. 
//			      2) Add moscap_rf_hvt and moscap_rf_hvt_nw. 
//			      3) Rename Mtop resirtor rmzw to rmt in UTM process.  
//                              4) Add spiral sanity check, irregular connection inside inductor region is not allow. 
// 03/29/2007 V1.2c   Yating Chuang 
//            pre032907         1) Add eDRAM device, nmoscap_od1t. 
//	                      2) Add 1.8V ESD non-LDD NMOS devices, nch_esd18. 
//			      3) WPE enhancement, fix small floating-point problem in TVF function.  
//			      4) Remove CB2 and AP interconnection. 
//			      5) Revise spiral parameter "gdis".  
//			      6) Add HVMOS devices, pch_hv25_spw, nch_hv25_sdnw. 
// 04/25/2007 V1.2c   Yating Chuang 
//            pre042507         1) Add nchpg_wosr, nchpd_wosr for 0.9 TP_HC SRAM devices. 
// 05/07/2007 V1.2c   Yating Chuang 
//            pre050707         1) Add devices ndio_na25od, ndio_na25ud. 
//	                      2) Rename postfix of spirals; Mza_a to mza_a, Mz_x to mzx, and Mu_z to mu_z. 
// 05/28/2007 V1.2c    Yating Chuang  
//                              1) Add switches "STD_LIB_9_TRACK" and "STD_LIB_11_TRACK" for WPE evaluation in STD cells. 
//			      2) Revise floating well check. 
// 06/07/2007 V1.2c1   Yating Chuang 
//                              1) Add ERC rule into "ERC SELECT CHECK", check ERC in LVS stage. 
//			         "e.g. calibre -lvs -spi layout.net lvs_command_file" 
//				 Please read file TSMC_DOC_WM/ERC_USAGE.pdf for detailed information. 
//			      2) Revise logic opration, ngate_rf not inside nwell, pgate_rf inside nwell. 
// 06/15/2007 V1.2d    Yating Chuang 
//            pre061507         1) Add UHVT devices, nch_uhvt and pch_uhvt. 
// 07/25/2007 V1.2d    Yating Chuang 
//            pre072507         1) Add ULP SRAM devices; nchpg_ulpsr, nchpd_ulpsr, nchpg_ulpdpsr, nchpd_ulpdpsr, pchpu_ulpsr and pchpu_ulpdpsr. 
//	                      2) Add LPG SRAM devices; nchpg_lpgsr,nchpd_lpgsr and pchpu_lpgsr.      
// 09/19/2007 V1.2d    Yating Chuang			       
//			      1) Update n_pplug for soft-connect check. 			       
//                              2) Update auxiliary layer of nch_25 from nthin1 to nthin. 
//			      3) Follow CRN65LP v1.2 model update. 
//			         Add linear cap devices : lincap, lincap_25, lincap_rf, and lincap_rf_25. 
//				 Add udc mimcap devices : mimcap_um_sin_udc_rf, mimcap_woum_sin_udc_rf, mimcap_sin_udc, and mimcap_sin_udc_3t. 
//				 Add mu_a inductors : spiral_std_mu_a, spiral_sym_mu_a, and spiral_sym_ct_mu_a.  
// 
//11/16/2007  V1.2e   Y.J.Wang  1) Modified diff exclude RODMY to be diff exclude (RODMY AND SRM).				  
// 			       2) Modified baseband lincap and lincap_25 devices to be 2T device. 
//			       3) Adding new HVNMOS for NW approach named "nch_hv25_snw", it covered by HVD(91;3). 
//			       4) Seperate WPE boundary for I/O 3.3V PMOS from other PMOS. 
//			        
// 12/20/2007  V1.2f   Y.J.Wang  1) Modified HV MOS to be asymmetry device, source/drain can not be swappable. 
// 
// 01/16/2008  V1.3a  Y.J.Wang    1) Adding new devices pmoscap_rf, pmoscap_rf25, and lowcpad devices.  
// 01/23/2008		        2) Adding connection for checking RTMOM.	 
// 
// 02/27/2008  V1.3b  Y.J.Wang   1) Adding new switch "FILTER_DGS_TIED_MOS". 
// 			       2) Update Document of deck usage. 
//			       3) Update 1tr decap formation. 
//			       4) Adding LPG SRAM TP 0.1158 cell in, nchpd_lpgtpsr,nchpg_lpgtpsr, and pchpu_lpgtpsr. 
// 
// 05/12/2008  V1.3c  Y.J.Wang   1) Modifying gate formation of hvt sram without NOT layer SRAM16. 
// 			       2) Not merge dummy poly into PO for definition of resistor and polyCont, poly_term.  
//			          But poly interconnect will include DPO layer. 
//			       3) Modified pwdnw formation and NPN device will not extract pwdnw device when turn-on "extract_dnwdio" switch. 	   
// 06/17/2008                    4) Change the bulk terminal type of mimcap_woum_sin_rf to meet all substrate types:NW/PW/DNW/NTN. 
// 
// 07/14/2008         Y.J.Wang   5) Update Calibre DFM macro code to reduce run time. 
// 			       6) Update ERC rules check of mnpg/mppg to include all core/IO/HV MOS in (exclude SRAM bit-cell and RF MOS). 
//			       7) Change hcell to be xcell and put all RF pcells in deck to fit new cell-blocking format.  
//			       8) Add switch "CELLIMP" to switch N65LP sram and N65G sram, turn-on this switch to use wisr/wosr of N65LP sram model. 
//			       9) Add new RF 5T/6T svt/hvt/lvt/IO devices in N65 process. 
//			      10) Add new RF high current diodes :ndio_hia_rf and pdio_hia_rf in N65 process. 
//			      11) The wpe params : sca/scb/scc of RF MOS only support GUI mode (only for N65 calibre viw and assura extractview). 
//			      12) Add new macro hvd devices : nch_hv25_sdnw_mac, nch_hv25_snw_mac and pch_hv25_spw_mac. 
// 
// 10/21/2008                   13) Revised metal/poly/od resistors for not include DUMMY DUM/DPO/DOD for resistor formation. 
//			      14) Remove floating gate checking in ERC section, because DRM has rule PO.R.8 to define it. 
//			      15) Adding connection between HVD terminals and diffusion to avoid disconnect for OD connection. 
//			      16) Adding ERC switch for each ERC rules, some are default turn-off, and use it by customer decision. 
//			      17) Adding two CAD layers: SRM15(50;15) and SRM16(50;16) for N65/N55 0.832 and N650.909 && N55 0.928 dimension. 
//			      18) Excluding TCDDMY in floating nwell ERC check based while use DRC fill utility to avoid false errors. 
//  			        
// 12/08/2008  V1.4a  Y.J.Wang   1) Adding small BJT for shrink base area, small bjt devices use BJTDMY(110;0)+BJTDMY1(110;1). 
// 			       2) Modify recognition layer of pchpu_wosr and pchpu_wisr device to exist in switch "CELLIMP" turning-on(N65LP sram). 
//			       3) Supporting probe device up to top-1 metal layer, ex: support probe5 in 1p6m with turn-off top2_thick switch. 
//			       4) Move LVS DEVICE TYPE RESISTOR section outside the switch definition. 
//			       5) Revise model extraction names of 25od33 devices ex: nch_na25od33, ndio_na25od33, 5T/6T 25od33 RFMOS. 
// 
// 08/17/2009  V1.4a_special Y.J.Wang  1). Blocking "crtmom*" and "crtmom_mx*" cells. 
//				     2). Adding pmoscap_rf18 device, align with N55 UTM process. 
//				     3). Adding new 2T base-band mimcap by using CTMDMYUD(148;10). 
//				     4). Adding new 3T RF with shielding mimcap_um_sin_rf by using RFDMYUD(161;10). 
//				     5). Based on newest edram spice mode, pch_1tr will be renamed as pch_edc device. 
// 
// 09/30/2009  V1.5a  Y.J.Wang   1) Based on CRN65LP model card, adding new shottky barrier diode devices. SBDDMY(113;0) used for these devices. 
// 			       2) Revised radius equation of spiral devices for correctly calculating values. 
//			       3) Remove area parameter extraction of BJT devices in LPE flow(turn-on RC_DECK). 
//			       4) Revised WPE/LOD TVF function and use DFM property equation for DFM macroes,  
//			          it could improve runtime of DFM_LPE extraction. Remove BY SHAPE command.  
//			       5) Revised SRM layer from 50 to (50;0) and update usage documents.  
//			       6) Not support sense amplifier device in model T-N65-CE-SP-002 v1.1. 
// 
// 11/20/2009  V1.5b_pre  Y.J.Wang   1) Update WPE TVF function equation (minor change) for switches STD_LIB_9/11_TRACK usage. 
//			           2) Adding VDDM and VSSM as power/ground name group. 
//			           3) Adding disclaimer about VIRTUAL CONNECT COLON YES command. 
//			           4) Based on newest DRM and LP Model, ALRDL has 2 thickness: 14k and 28k and cannot be co-existed. 
//			              It will use switch AP_UT to seperate two model names rm10(=rmap) and rmap_ut. 
//				      Please notice rmap_ut device only can exist in LP process. 
// 
// 03/05/2010  V1.5b_pre Y.J.Wang	   5) Adding IO 1.8v Native RFMOS device.		   
// 				   6) Modify gate formation that allow base-band MOS put inside RFDMY but outside RFMOS guard-ring region.  
// 
// 03/17/2010  V1.5b_pre Y.J.Wang    7) Adding cm_decap device in N65 process. 
// 
// 04/09/2010  V1.5b_pre Y.J.Wang    8) Based on newest spice model, remove lowcpad_d0 device. 
// 				   9) Seperate lowcpad device for top2_thick and top1_thick, there are different layout structures. 
// 
// 01/14/2011  V1.6a     Y.J.Wang    1). Add new power/ground port names : TVDD and TVSS 
// 				   2). Add RF RBC cells: nmos_rf_diff_nw, nmos_rf_cross_nw, nmos_rf_cas_nw and rfesd_rf1~rfesd_rf8. 
//				       Limited all terminals of nmos_rf_diff cannot be swappable. 
//				   3). Add nwell/psub parasitic diodes: pnwdio, model name will be nwdio. 
//				   4). Add RF transmission line devices: sline_gscpw_mu and sline_ms_mu. 
//				   5). Add 10 RDK cells for future usage: nmos_rf_rdf, pmos_rf_rdf, moscap_rf_rdk, crtmom_rf_rdk, 
//				       spiral_std_mu_z_rdk, spiral_sym_mu_z_rdk, and spiral_sym_ct_mu_z_rdk, rppolyl_rf_rdk,  
//				       rppolys_rf_rdk and rppolywo_rf_rdk. All devices must be covered by RDKDMY(208;2) layer. 
//				   6). Revised bulk terminal from poly2 to poly for MOM devices, will not exclude poly inside MOMDMY region. 
//				   7). Revised gate logic operation for SRAM MOS gatecap enhancement. 
//				   8). Revised tndiff/tpdiff to exclude HVD/RFMOS terminals to avoid overlapping. 
//				   9). Revised lowcpad devices, both top1_thick and top2_thick MUST have VIA(top-1) underneath. 
//				  10). Revised nmoscap type of devices to enhance gatecap blocking. 
//				  11). Updated usage document. 
// 
// 
// 03/31/2011 V1.6b_pre033111	  F.Y.Hsiao    
// 				  1). Revised nplug and pplug to interact odCont instead of CO for edram devices. 
// 				  2). Changes swap function of txline devices : sline_gscpw_mu and sline_ms_mu. 
// 				  3). Add new special spiral devices: MU_A_4X, MU_A2W, MU_A4W and MU_A_A types. 
// 
// 06/17/2011 V1.6b_pre061711       M.H.Tsai 
//				  1). Remove diff_mom which is coverd by tndiff 
//				  2). Remove layer HVD_N(91;1) and related devices, cause of the process doesn't support 
//				  3). Revise device formation 
//				  4). Add fmom and fmom_mx 
//				  5). Revise model version. 
// 
//////////////////////////////////////////////////////////////////////////////// 
// 
//				DEVICE FORMULA 
//	 CORE == 1.0v or 1.2v  
//	 I/O  == 2.5v or 3.3v or 1.8v 
//   ----- ----------------------------- ---------------------------------- 
//   NAME     DESCRIPTION                   DEVICE LAYER OPERATION 
//   ----- ----------------------------- ---------------------------------- 
//   M[nch]           CORE Nominal VT NMOS      ((NGATE-OD25-OD18-OD33-NT_Ni)-DNW-SRM-OD1T-DCO)  
//   M[nch_dnw]       CORE Nominal VT NMOS/DNW  ((NGATE-OD25-OD18-OD33-NT_Ni)*DNW-SRM-OD1T)  
//   M[nch_lvt]       CORE LOW-VT NMOS          ((NGATE-OD25-OD18-OD33-NT_Ni)-DNW*VTL_N-SRM) 
//   M[nch_lvt_dnw]   CORE LOW-VT NMOS/DNW      ((NGATE-OD25-OD18-OD33-NT_Ni)*DNW*VTL_N-SRM) 
//   M[nch_hvt]       CORE HIGH-VT NMOS         ((NGATE-OD25-OD18-OD33-NT_Ni)-DNW*VTH_N-SRM-DCO)  
//   M[nch_hvt_dnw]   CORE HIGH-VT NMOS/DNW     ((NGATE-OD25-OD18-OD33-NT_Ni)*DNW*VTH_N-SRM)  
//   M[nch_uhvt]      CORE ULTRA-HIGH-VT NMOS     ((NGATE-OD25-OD18-OD33-NT_Ni)-DNW-OD1T*UHVT_N) 
//   M[nch_uhvt_dnw]  CORE ULTRA-HIGH-VT NMOS/DNW ((NGATE-OD25-OD18-OD33-NT_Ni)*DNW-OD1T*UHVT_N) 
//   M[nch_ulvt]      CORE ULTRA-LOW-VT NMOS      ((NGATE-OD25-OD18-OD33-NT_Ni)-DNW-OD1T*VTUL_N) 
//   M[nch_ulvt_dnw]  CORE ULTRA-LOW-VT NMOS/DNW  ((NGATE-OD25-OD18-OD33-NT_Ni)*DNW-OD1T*VTUL_N) 
//   M[nch_mlvt]      CORE ILVT NMOS            ((NGATE-OD25-OD18-OD33-NT_Ni)-DNW*ILVT-SRM) 
//   M[nch_mlvt_dnw]  CORE ILVT NMOS/DNW        ((NGATE-OD25-OD18-OD33-NT_Ni)*DNW*ILVT-SRM) 
// 
//   M[nch_na]       CORE native device         ((NGATE-OD25-OD18-OD33)*NT_Ni-SRM-DCO) 
//   M[nch_lpg]      LPG Nominal VT NMOS        ((NGATE-OD25-OD18-OD33-NT_Ni)-DNW-SRM-OD1T*DCO)  
//   M[nch_lpghvt]   LPG HIGH-VT NMOS           ((NGATE-OD25-OD18-OD33-NT_Ni)-DNW*VTH_N-SRM*DCO)  
//   M[nch_lpgna]    LPG native device          ((NGATE-OD25-OD18-OD33)*NT_Ni-SRM*DCO)  
//   M[nchpg_sr]     SRAM passgate NMOS         ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM*SRAMPSGT-SRM12-SRM13-SRM14-SRAM16-DCO)  
//   M[nchpd_sr]     SRAM pulldown NMOS         ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM-SRAMPSGT-SRM12-SRM13-SRM14-SRAM16-DCO) 
//   M[nchpg_lpgsr]  SRAM LPG passgate NMOS     ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM*SRAMPSGT-SRM12-SRM13-SRM14-SRAM16*DCO)  
//   M[nchpd_lpgsr]  SRAM LPG pulldown NMOS     ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM-SRAMPSGT-SRM12-SRM13-SRM14-SRAM16*DCO) 
//   M[nchpg_hvtsr]  SRAM High VT passgate NMOS  ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N*VTH_N-UHVT_N*SRM*SRAMPSGT-SRM12-SRM13-SRM14-SRM17)  
//   M[nchpd_hvtsr]  SRAM High VT pulldown NMOS  ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N*VTH_N-UHVT_N*SRM-SRAMPSGT-SRM12-SRM13-SRM14-SRM17)    
//   M[nchpg_dpsr]   SRAM passgate NMOS 0.974 DP ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM*SRAMPSGT*SRM12-SRM14-SRM17-DCO)  
//   M[nchpd_dpsr]   SRAM pulldown NMOS 0.974 DP ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM-SRAMPSGT*SRM12-SRM14-SRM17-DCO) 
//   M[nchpg_lpgdpsr]  SRAM LPG passgate NMOS 0.974 DP ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM*SRAMPSGT*SRM12-SRM14-SRM17*DCO)  
//   M[nchpd_lpgdpsr]  SRAM LPG pulldown NMOS 0.974 DP ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM-SRAMPSGT*SRM12-SRM14-SRM17*DCO) 
//   M[nchpg_hvtdpsr]  SRAM High VT passgate NMOS 0.974 DP ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N*VTH_N-UHVT_N*SRM*SRAMPSGT*SRM12-SRM14-SRM17)  
//   M[nchpd_hvtdpsr]  SRAM High VT pulldown NMOS 0.974 DP ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N*VTH_N-UHVT_N*SRM-SRAMPSGT*SRM12-SRM14-SRM17)    
//   M[nchpg_dphcsr]   SRAM passgate NMOS 1.15 DP      ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM*SRAMPSGT*SRM13-SRM14)  
//   M[nchpd_dphcsr]   SRAM pulldown NMOS 1.15 DP      ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM-SRAMPSGT*SRM13-SRM14) 
//   M[nchpg_hvtdphcsr]  SRAM High VT passgate NMOS 1.15 DP ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N*VTH_N-UHVT_N*SRM*SRAMPSGT*SRM13-SRM14)  
//   M[nchpd_hvtdphcsr]  SRAM High VT pulldown NMOS 1.15 DP ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N*VTH_N-UHVT_N*SRM-SRAMPSGT*SRM13-SRM14)    
//   M[nchpg_ulpsr]    SRAM ULP passgate NMOS          ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N*VTH_N-UHVT_N*SRM*SRAMPSGT-SRM12*SRM17-SRM14)  
//   M[nchpd_ulpsr]    SRAM ULP pulldown NMOS          ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N*VTH_N-UHVT_N*SRM-SRAMPSGT-SRM12*SRM17-SRM14)    
//   M[nchpg_ulpdpsr]  SRAM ULP passgate NMOS DP       ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N*VTH_N-UHVT_N*SRM*SRAMPSGT*SRM12*SRM17-SRM14)  
//   M[nchpd_ulpdpsr]  SRAM ULP pulldown NMOS DP       ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N*VTH_N-UHVT_N*SRM-SRAMPSGT*SRM12*SRM17-SRM14)    
//   M[nchpg_lpgtpsr]  SRAM LPG passgate NMOS 0.1158 TP ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM*SRAMPSGT*SRM14*DCO)  
//   M[nchpd_lpgtpsr]  SRAM LPG pulldown NMOS 0.1158 TP ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM-SRAMPSGT*SRM14*DCO) 
//   M[nchpg_wosr]  SRAM G SVT passgate NMOS 0.9 TP       ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM*SRAMPSGT*SRM16-SRM14)  
//   M[nchpd_wosr]  SRAM G SVT pulldown NMOS 0.9 TP       ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM-SRAMPSGT*SRM16-SRM14)  
//   M[nchpg_wosr]  SRAM LP SVT passgate NMOS HC    ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM*SRAMPSGT*SRM11-SRM10-SRM16-SRM14)  
//   M[nchpd_wosr]  SRAM LP SVT pulldown NMOS HC    ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM-SRAMPSGT*SRM11-SRM10-SRM16-SRM14)    
//   M[nchpg_wisr]  SRAM SVT passgate NMOS UHD   ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM*SRAMPSGT*SRM10-SRM11-SRM16-SRM14)  
//   M[nchpd_wisr]  SRAM SVT pulldown NMOS UHD   ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_N-UHVT_N*SRM-SRAMPSGT*SRM10-SRM11-SRM16-SRM14) 
//   M[nch_timer]   SRAM timer NMOS              ((NGATE-OD25-OD18-OD33-NT_Ni-VTL_N-VTH_-UHVT_NN*SRM*SRAMTIMER)  
//   M[nch_w]          eDRAM Nominal VT NMOS         ((NGATE-OD25-OD18-OD33-NT_Ni)-DNW-SRM*OD1T-p3-VTUL_N)  
//   M[nch_dnw_w]      eDRAM Nominal VT NMOS/DNW     ((NGATE-OD25-OD18-OD33-NT_Ni)*DNW-SRM*OD1T-p3)  
//   M[nch_w_lvt]      eDRAM ULTRA-LOW-VT NMOS       ((NGATE-OD25-OD18-OD33-NT_Ni)-DNW-SRM*OD1T-p3*VTUL_N)  
//   M[nch_dnw_w_lvt]  eDRAM ULTRA-LOW-VT NMOS/DNW   ((NGATE-OD25-OD18-OD33-NT_Ni)*DNW-SRM*OD1T-p3*VTUL_N) 
//   M[nch_dnw_1tr]    eDRAM 1TR NMOS/DNW            ((NGATE-OD25-OD18-OD33-NT_Ni)*DNW-SRM*OD1T*p3)  
// 
//   M[nch_18]            I/O Nominal VT NMOS                ((NGATE*OD18-OD25-OD33-NT_Ni-RH)-DNW)  
//   M[nch_esd18]         I/O esd non-LDD NMOS               ((NGATE*OD18-OD25-OD33-NT_Ni*RPO*RH)-DNW)  
//   M[nch_25]            I/O Nominal VT NMOS                ((NGATE*OD25-OD33-OD18-NT_Ni-OD25_18-OD25_33-OD25_28)-DNW)  
//   M[nch_25ud]          I/O Nominal VT NMOS                ((NGATE*OD25*OD25_18-OD33-OD18-NT_Ni)-DNW)  
//   M[nch_25od]          I/O Nominal VT NMOS                ((NGATE*OD25*OD25_33-OD33-OD18-NT_Ni)-DNW)  
//   M[nch_25od28]        I/O Nominal VT NMOS                ((NGATE*OD25*OD25_28-OD33-OD18-NT_Ni)-DNW)  
//   LDDN[nch_hv25_snw]   Asymmetry HVD NMOS w/i NW approach  ((NGATE*OD25-NT_Ni*HVD_NW)-DNW)  
//   M[nch_33]  		I/O Nominal VT NMOS                ((NGATE*OD33-OD25-OD18-NT_Ni)-DNW)  
//   M[nch_18_dnw] 	I/O Nominal VT NMOS/DNW            ((NGATE*OD18-OD25-OD33-NT_Ni)*DNW)-RH  
//   M[nch_esd18_dnw] 	I/O esd non-LDD NMOS/DNW           ((NGATE*OD18-OD25-OD33-NT_Ni*RPO*RH)*DNW)  
//   M[nch_25_dnw] 	I/O Nominal VT NMOS/DNW            ((NGATE*OD25-OD33-OD18-NT_Ni-OD25_18-OD25_33-OD25_28)*DNW)  
//   M[nch_25_dnwud] 	I/O Nominal VT NMOS/DNW            ((NGATE*OD25*OD25_18-OD33-OD18-NT_Ni)*DNW)  
//   M[nch_25_dnwod] 	I/O Nominal VT NMOS/DNW            ((NGATE*OD25*OD25_33-OD33-OD18-NT_Ni)*DNW)  
//   M[nch_25od28_dnw] 	I/O Nominal VT NMOS/DNW            ((NGATE*OD25*OD25_28-OD33-OD18-NT_Ni)*DNW)  
//   M[nch_33_dnw] 	I/O Nominal VT NMOS/DNW            ((NGATE*OD33-OD25-OD18-NT_Ni)*DNW)  
//   M[nch_na18]   	I/O native device                  ((NGATE*OD18-OD25-OD33)*NT_Ni)   
//   M[nch_na25]   	I/O native device                  ((NGATE*OD25-OD33-OD18-OD25_33-OD25_18)*NT_Ni)   
//   M[nch_na25ud] 	I/O native device                  ((NGATE*OD25*OD25_18-OD33-OD18)*NT_Ni)   
//   M[nch_na25od] 	I/O native device                  ((NGATE*OD25*OD25_33-OD33-OD18)*NT_Ni)   
//   M[nch_na33]   	I/O native device                  ((NGATE*OD33-OD25-OD18)*NT_Ni)   
//   M[pch]      		CORE Nominal VT PMOS               ((PGATE-OD25-OD33-OD18)-SRM-OD1T-DCO)  
//   M[pch_hvt]   	CORE High-VT PMOS                  ((PGATE-OD25-OD33-OD18*VTH_P)-SRM-DCO) 
//   M[pch_lvt]   	CORE LOW-VT PMOS                   (PGATE-OD25-OD33-OD18*VTL_P-SRM) 
//   M[pch_ulvt]  	CORE ULTRA-LOW-VT PMOS             ((PGATE-OD25-OD33-OD18)*VTUL_P-OD1T) 
//   M[pch_uhvt]  	CORE ULTRA-HIGH-VT PMOS            ((PGATE-OD25-OD33-OD18)*UHVT_P-OD1T) 
//   M[pch_mlvt]          CORE ILVT PMOS                     (PGATE-OD25-OD33-OD18*ILVT-SRM) 
// 
//   M[pchpu_sr]          SRAM PMOS                     ((PGATE-OD25-OD33-OD18)-VTH_P*SRM-SRM12-SRM13-SRM14-DCO)  
//   M[pchpu_lpgsr]       SRAM LPG PMOS                 ((PGATE-OD25-OD33-OD18)-VTH_P*SRM-SRM12-SRM13-SRM14*DCO)  
//   M[pchpu_hvtsr]       SRAM High VT PMOS             ((PGATE-OD25-OD33-OD18)*VTH_P*SRM-SRM12-SRM13-SRM14-SRM17) 
//   M[pchpu_dpsr]        SRAM PMOS 0.974 DP            ((PGATE-OD25-OD33-OD18)-VTH_P*SRM*SRM12-SRM13-SRM14-SRM17-DCO)  
//   M[pchpu_lpgdpsr]     SRAM LPG PMOS 0.974 DP        ((PGATE-OD25-OD33-OD18)-VTH_P*SRM*SRM12-SRM13-SRM14-SRM17*DCO)  
//   M[pchpu_hvtdpsr]     SRAM High VT PMOS 0.974 DP    ((PGATE-OD25-OD33-OD18)*VTH_P*SRM*SRM12-SRM17-SRM14) 
//   M[pchpu_dphcsr]      SRAM PMOS 1.15 DP             ((PGATE-OD25-OD33-OD18)-VTH_P*SRM-SRM12*SRM13-SRM14)  
//   M[pchpu_hvtdphcsr]   SRAM High VT PMOS 1.15 DP     ((PGATE-OD25-OD33-OD18)*VTH_P*SRM-SRM12*SRM13-SRM14) 
//   M[pchpu_ulpsr]       SRAM ULP PMOS                 ((PGATE-OD25-OD33-OD18)*VTH_P*SRM-SRM12-SRM14*SRM17) 
//   M[pchpu_ulpdpsr]     SRAM ULP PMOS DP              ((PGATE-OD25-OD33-OD18)*VTH_P*SRM*SRM12-SRM14*SRM17) 
//   M[pchpu_lpgtpsr]     SRAM LPG PMOS 0.1158 TP       ((PGATE-OD25-OD33-OD18)-VTH_P*SRM*SRM14*DCO)  
//   M[pch_timer]         SRAM timer PMOS               ((PGATE-OD25-OD18-OD33)-VTL_P-VTUL_P*SRM*SRAMTIMER)  
//   M[pch_w]             eDRAM Nominal VT PMOS         ((PGATE-OD25-OD33-OD18)-SRM*OD1T-p3-VTUL_P)  
//   M[pch_w_lvt]         eDRAM ULTRA-LOW-VT PMOS       ((PGATE-OD25-OD33-OD18)-SRM*OD1T-p3*VTUL_P)  
//   M[pch_edc]           eDRAM 1TR PMOS                ((PGATE-OD25-OD33-OD18)-SRM*OD1T*p3)  
//   M[pchpu_wosr]        SRAM SVT pullup PMOS HC       ((PGATE-OD25-OD18-OD33-VTL_P-VTH_P-UHVT_P*SRM*SRM11-SRM10-SRM14)    
//   M[pchpu_wisr]        SRAM SVT pullup PMOS UHD      ((PGATE-OD25-OD18-OD33-VTL_P-VTH_P-UHVT_P*SRM*SRM10-SRM11-SRM14) 
//   M[pch_lpg]           LPG Nominal VT PMOS           ((PGATE-OD25-OD33-OD18)-SRM-OD1T*DCO)  
//   M[pch_lpghvt]        LPG High-VT PMOS              ((PGATE-OD25-OD33-OD18*VTH_P)-SRM*DCO)  
//   M[pch_18]            I/O Nominal VT PMOS           (PGATE*OD18-OD25-OD33)  
//   M[pch_25]            I/O Nominal VT PMOS           (PGATE*OD25-OD33-OD18-OD25_18-OD25_33-OD25_28-HVD_P)  
//   M[pch_25ud]          I/O Nominal VT PMOS           (PGATE*OD25*OD25_18-OD33-OD18-HVD_P)  
//   M[pch_25od]          I/O Nominal VT PMOS           (PGATE*OD25*OD25_33-OD33-OD18-HVD_P)  
//   M[pch_25od28]        I/O Nominal VT PMOS           (PGATE*OD25*OD25_28-OD33-OD18-HVD_P)  
//   LDDP[pch_hv25_spw]   Asymmetry HVD PMOS            (PGATE*OD25*HVD_P)  
//   M[pch_33]            I/O Nominal VT PMOS           (PGATE*OD33-OD25-OD18)  
// 
//   rnwod          N-Well resistor under OD 2T         (NWDMYi*NW*(ODI*RPO))  
//   rnwod_m        N-Well resistor under OD 3T         (NWDMY1*NW*(ODI*RPO))  
//   rnwsti         N-Well resister under STI 2T        (NWDMYi*NW-(ODI*RPO))  
//   rnwsti_m       N-Well resister under STI 3T        (NWDMY1*NW-(ODI*RPO))  
//   rpodwo         P+diff resistor w/o Silicide        (RPDMYi*ODI*PP*RPO*RH*NW)  
//   rpodwo_m       P+diff resistor w/o Silicide        (RPDMY1*ODI*PP*RPO*RH*NW)  
//   rnodwo         N+diff resistor w/o Silicide        (RPDMYi*ODI*NP*RPO*RH-NW)  
//   rnodwo_m       N+diff resistor w/o Silicide        (RPDMY1*ODI*NP*RPO*RH-NW)  
//   rnodl          N+diff resistor w/i Silicide >=2 2T (RPDMYi*ODI*NP-RPO-NW)  
//   rnodl_m        N+diff resistor w/i Silicide >=2 3T (RPDMY1*ODI*NP-RPO-NW)  
//   rnods          N+diff resistor w/i Silicide <2 2T  (RPDMYi*ODI*NP-RPO-NW)  
//   rnods_m        N+diff resistor w/i Silicide <2 3T  (RPDMY1*ODI*NP-RPO-NW)  
//   rpodl          P+diff resistor w/i Silicide >=2 2T (RPDMYi*ODI*PP-RPO*NW)  
//   rpodl_m        P+diff resistor w/i Silicide >=2 3T (RPDMY1*ODI*PP-RPO*NW)  
//   rpods          P+diff resistor w/i Silicide <2 2T  (RPDMYi*ODI*PP-RPO*NW)  
//   rpods_m        P+diff resistor w/i Silicide <2 3T  (RPDMY1*ODI*PP-RPO*NW)  
//  
//   rppolywo       P+Poly resistor w/o Silicide 2T     (RPDMYi*POI*PP*RPO*RH-RFDMY) 
//   rppolywo_m     P+Poly resistor w/o Silicide 3T     (RPDMY1*POI*PP*RPO*RH-RFDMY) 
//   rnpolywo       N+Poly resistor w/o Silicide 2T     (RPDMYi*POI*NP*RPO*RH)  
//   rnpolywo_m     N+Poly resistor w/o Silicide 3T     (RPDMY1*POI*NP*RPO*RH) 
//   rnpolyl        N+Poly resistor w/i Silicide >=2 2T (RPDMYi*POI*NP-RPO)  
//   rnpolyl_m      N+Poly resistor w/i Silicide >=2 3T (RPDMY1*POI*NP-RPO)  
//   rnpolys        N+Poly resistor w/i Silicide <2 2T  (RPDMYi*POI*NP-RPO)  
//   rnpolys_m      N+Poly resistor w/i Silicide <2 3T  (RPDMY1*POI*NP-RPO)  
//   rppolyl        P+Poly resistor w/i Silicide >=2 2T (RPDMYi*POI*PP-RPO-RFDMY)  
//   rppolyl_m      P+Poly resistor w/i Silicide >=2 3T (RPDMY1*POI*PP-RPO-RFDMY)  
//   rppolys        P+Poly resistor w/i Silicide <2 2T  (RPDMYi*POI*PP-RPO-RFDMY)  
//   rppolys_m      P+Poly resistor w/i Silicide <2 3T  (RPDMY1*POI*PP-RPO-RFDMY)  
// 
//   rm1         METAL1 resistor                     (RMDMY1*M1) 
//   rm2         METAL2 resistor                     (RMDMY2*M2) 
//   rm3         METAL3 resistor                     (RMDMY3*M3) 
//   rm4         METAL4 resistor                     (RMDMY4*M4) 
//   rm5         METAL5 resistor                     (RMDMY5*M5) 
//   rm6         METAL6 resistor                     (RMDMY6*M6) 
//   rm7         METAL7 resistor                     (RMDMY7*M7) 
//   rm8         METAL8 resistor                     (RMDMY8*M8) 
//   rm9         METAL9 resistor                     (RMDMY9*M9) 
// 
// 
//   rm10      AP resistor                         (RMDMYAP*AP) 
//   D[PDIO]      CORE diode P+/NW              (DIODMY*OD*PP-OD25-OD33-OD18*NW-OD1T-DCO-HIADMY)  
//   D[PDIO_lpg]  LPG diode P+/NW               (DIODMY*OD*PP-OD25-OD33-OD18*NW-OD1T*DCO-HIADMY)  
//   D[NDIO]      CORE diode N+/PW              (DIODMY*OD*NP-OD25-OD33-OD18*PSUB-OD1T-DCO-HIADMY)  
//   D[NDIO_lpg]  LPG diode N+/PW		      (DIODMY*OD*NP-OD25-OD33-OD18*PSUB-OD1T*DCO-HIADMY)	 
//   D[PDIO_w]    eDRAM diode P+/NW             (DIODMY*OD*PP-OD25-OD33-OD18*NW*OD1T-HIADMY)  
//   D[NDIO_w]    eDRAM diode N+/PW             (DIODMY*OD*NP-OD25-OD33-OD18*PSUB*OD1T-HIADMY)  
//   D[NWDIO]     CORE diode NW/PW              (DIODMY*NW*NP*PP-OD25-OD33-OD18-HIADMY)  
//   D[PDIO_hvt]  CORE High-VT diode P+/NW      (DIODMY*OD*PP-OD25-OD33-OD18*NW*VTH_P-DCO-HIADMY)  
//   D[PDIO_lpghvt] LPG High-VT diode P+/NW     (DIODMY*OD*PP-OD25-OD33-OD18*NW*VTH_P*DCO-HIADMY)  
//   D[NDIO_hvt]  CORE High-VT diode N+/PW      (DIODMY*OD*NP-OD25-OD33-OD18*PSUB*VTH_N-DCO-HIADMY)  
//   D[NDIO_lpghvt] LPG High-VT diode N+/PW     (DIODMY*OD*NP-OD25-OD33-OD18*PSUB*VTH_N*DCO-HIADMY) 
//   D[PDIO_lvt]  CORE Low-VT diode P+/NW       (DIODMY*OD*PP-OD25-OD33-OD18*NW*VTL_P-HIADMY)  
//   D[NDIO_lvt]  CORE Low-VT diode N+/PW       (DIODMY*OD*NP-OD25-OD33-OD18*PSUB*VTL_N-HIADMY) 
//   D[PDIO_uhvt]  CORE ultra High-VT diode P+/NW (DIODMY*OD*PP-OD25-OD33-OD18*NW*UHVT_P-DCO-HIADMY)  
//   D[NDIO_uhvt]  CORE ultra High-VT diode N+/PW (DIODMY*OD*NP-OD25-OD33-OD18*PSUB*UHVT_N-DCO-HIADMY)  
//   D[PDIO_mlvt] CORE ILVT diode P+/NW         (DIODMY*OD*PP-OD25-OD33-OD18*NW*ILVT-HIADMY)  
//   D[NDIO_mlvt] CORE ILVT diode N+/PW         (DIODMY*OD*NP-OD25-OD33-OD18*PSUB*ILVT-HIADMY) 
//   D[PDIO_18]   I/O diode P+/NW               (DIODMY*OD*PP*OD18*NW-HIADMY)  
//   D[PDIO_25]   I/O diode P+/NW               (DIODMY*OD*PP*OD25-OD25_18-OD25_33*NW-HVD_P-HIADMY)  
//   D[PDIO_25UD] I/O diode P+/NW               (DIODMY*OD*PP*OD25*OD25_18*NW-HIADMY)  
//   D[PDIO_25OD] I/O diode P+/NW               (DIODMY*OD*PP*OD25*OD25_33*NW-HIADMY)  
//   D[PDIO_25OD28] I/O diode P+/NW             (DIODMY*OD*PP*OD25*OD25_28*NW-HIADMY)  
//   D[PDIO_33]   I/O diode P+/NW               (DIODMY*OD*PP*OD33*NW-HIADMY)  
//   D[NDIO_18]   I/O diode N+/PW               (DIODMY*OD*NP*OD18*PSUB-HIADMY)  
//   D[NDIO_25]   I/O diode N+/PW               (DIODMY*OD*NP*OD25-OD25_18-OD25_33*PSUB-HIADMY)  
//   D[NDIO_25UD] I/O diode N+/PW               (DIODMY*OD*NP*OD25*OD25_18*PSUB-HIADMY)  
//   D[NDIO_25OD] I/O diode N+/PW               (DIODMY*OD*NP*OD25*OD25_33*PSUB-HIADMY)  
//   D[NDIO_25OD28] I/O diode N+/PW             (DIODMY*OD*NP*OD25*OD25_28*PSUB-HIADMY)  
//   D[NDIO_33]   I/O diode N+/PW               (DIODMY*OD*NP*OD33*PSUB-HIADMY)  
//   D[NWDIO_18]  I/O diode NW/PW               (DIODMY*NW*NP*PP*OD18-HIADMY)  
//   D[NWDIO_25]  I/O diode NW/PW               (DIODMY*NW*NP*PP*OD25-HIADMY)  
//   D[NWDIO_33]  I/O diode NW/PW               (DIODMY*NW*NP*PP*OD33-HIADMY)  
//   D[NDIO_NA]     CORE native diode N+/PW     (DIODMY*OD*NP-OD25-OD33-OD18*PSUB*NT_Ni-DCO-HIADMY)  
//   D[NDIO_LPGNA]  LPG native diode N+/PW      (DIODMY*OD*NP-OD25-OD33-OD18*PSUB*NT_Ni*DCO-HIADMY)  
//   D[NDIO_NA18]   I/O native diode N+/PW      (DIODMY*OD*NP*OD18*PSUB*NT_Ni-HIADMY)  
//   D[NDIO_NA25]   I/O native diode N+/PW      (DIODMY*OD*NP*OD25*PSUB*NT_Ni-HIADMY)  
//   D[NDIO_NA25UD] I/O native diode N+/PW      (DIODMY*OD*NP*OD25*OD25_18*PSUB*NT_Ni-HIADMY)  
//   D[NDIO_NA25OD] I/O native diode N+/PW      (DIODMY*OD*NP*OD25*OD25_33*PSUB*NT_Ni-HIADMY)  
//   D[NDIO_NA33]   I/O native diode N+/PW      (DIODMY*OD*NP*OD33*PSUB*NT_Ni-HIADMY)  
//   D[NDIO_ESD]    IO Diode DB                 (ESD3*NP*OD*RPO)  
//   D[DNWPSUB]     Diode DNW/PSUB              (DNW*PSUB)            
//   D[PWDNW]       Diode PWELL/DNW             (DNW-NW-BJTDMY) 
//   C[CM]          CM capacitor device         (crown*p3*OD-RPO) 
//   C[CM_decap]    CM decap capacitor device   (crown*p3*PO*NP-RPO*EDRAM_DECAP) 
//   Q[NPN10]       NPN10X10                    (DNW*BJTDMY*OD*NP*RPO-BJTDMY1)  
//   Q[NPN5]        NPN5X5                      (DNW*BJTDMY*OD*NP*RPO-BJTDMY1)  
//   Q[NPN2]        NPN2X2                      (DNW*BJTDMY*OD*NP*RPO-BJTDMY1)  
//   Q[PNP10]       CORE PNP-BJT                (BJTDMY*OD*PP*NW*RPO-BJTDMY1)  
//   Q[PNP5]        CORE PNP-BJT                (BJTDMY*OD*PP*NW*RPO-BJTDMY1)  
//   Q[PNP2]        CORE PNP-BJT                (BJTDMY*OD*PP*NW*RPO-BJTDMY1)  
// 
//   Q[NPN10_S]     SMALL NPN10X10              (DNW*BJTDMY*OD*NP*RPO*BJTDMY1)  
//   Q[NPN5_S]      SMALL NPN5X5                (DNW*BJTDMY*OD*NP*RPO*BJTDMY1)  
//   Q[NPN2_S]      SMALL NPN2X2                (DNW*BJTDMY*OD*NP*RPO*BJTDMY1) 
//   Q[PNP10_S]     CORE SMALL PNP-BJT          (BJTDMY*OD*PP*NW*RPO*BJTDMY1)  
//   Q[PNP5_S]      CORE SMALL PNP-BJT          (BJTDMY*OD*PP*NW*RPO*BJTDMY1)  
//   Q[PNP2_S]      CORE SMALL PNP-BJT          (BJTDMY*OD*PP*NW*RPO*BJTDMY1)  
//   nmoscap        MOSCAP Varactor             ((VARGT*NW-OD18-OD25-OD33)-RFDMY-DCO-OD1T-RBCDMY) 
//   nmoscap_lpg    LPG MOSCAP Varactor         ((VARGT*NW-OD18-OD25-OD33)-RFDFM*DCO-RBCDMY) 
//   nmoscap_25     2.5V MOSCAP Varactor        ((VARGT*NW-OD18*OD25-OD33)-RFDMY-RBCDMY) 
//   nmoscap_18     1.8V MOSCAP Varactor        ((VARGT*NW*OD18-OD25-OD33)-RFDMY-RBCDMY) 
//   nmoscap_33     3.3V MOSCAP Varactor        ((VARGT*NW-OD18-OD25*OD33)-RFDMY-RBCDMY) 
// 
//   moscap_rf      	RF Core MOSCAP Varactor          ((VARGT*NW-OD18-OD25-OD33-VTH_P)*RFDMY*DNW-RBCDMY-RDKDMY) 
//   moscap_rf_rdk      	RF Core MOSCAP Varactor RDK      ((VARGT*NW-OD18-OD25-OD33-VTH_P)*RFDMY*DNW-RBCDMY*RDKDMY) 
//   moscap_rf_nw   	RF Core MOSCAP Varactor w/i NW   ((VARGT*NW-OD18-OD25-OD33-VTH_P)*RFDMY-DNW-RBCDMY-RDKDMY) 
//   moscap_rf_hvt  	RF Core MOSCAP HVT Varactor        ((VARGT*NW-OD18-OD25-OD33*VTH_P)*RFDMY*DNW-RBCDMY) 
//   moscap_rf_hvt_nw     RF Core MOSCAP HVT Varactor w/i NW ((VARGT*NW-OD18-OD25-OD33*VTH_P)*RFDMY-DNW-RBCDMY) 
//   moscap_rf18    	RF 1.8V MOSCAP Varactor          ((VARGT*NW*OD18-OD25-OD33)*RFDMY*DNW-RBCDMY) 
//   moscap_rf18_nw 	RF 1.8V MOSCAP Varactor w/i NW   ((VARGT*NW*OD18-OD25-OD33)*RFDMY-DNW-RBCDMY) 
//   moscap_rf25    	RF 2.5V MOSCAP Varactor          ((VARGT*NW-OD18*OD25-OD33)*RFDMY*DNW-RBCDMY) 
//   moscap_rf25_nw 	RF 2.5V MOSCAP Varactor w/i NW   ((VARGT*NW-OD18*OD25-OD33)*RFDMY-DNW-RBCDMY) 
//   moscap_rf33    	RF 3.3V MOSCAP Varactor          ((VARGT*NW-OD18-OD25*OD33)*RFDMY*DNW-RBCDMY) 
//   moscap_rf33_nw 	RF 3.3V MOSCAP Varactor w/i NW   ((VARGT*NW-OD18-OD25*OD33)*RFDMY-DNW-RBCDMY) 
//   pmoscap_rf      	RF Core PMOSCAP Varactor         ((PVARGT*DNW-OD18-OD25-OD33-VTH_P)*RFDMY-RBCDMY) 
//   pmoscap_rf18    	RF 1.8V PMOSCAP Varactor     	 ((PVARGT*DNW*OD18-OD25-OD33-VTH_P)*RFDMY-RBCDMY) 
//   pmoscap_rf25    	RF 2.5V PMOSCAP Varactor     	 ((PVARGT*DNW-OD18*OD25-OD33)*RFDMY-RBCDMY) 
//   rppolyl_rf     RF P+Poly resistor w/i Silicide >=2 3T (RPDMYi*PO*PP-RPO*RFDMY*NW-RDKDMY) 
//   rppolys_rf     RF P+Poly resistor w/i Silicide <2 3T  (RPDMYi*PO*PP-RPO*RFDMY*NW-RDKDMY) 
//   rppolywo_rf    RF P+Poly resistor w/o Silicide 3T     (RPDMYi*PO*PP*RPO*RH*RFDMY*NW-RDKDMY)  
//   rppolyl_rf_rdk     RF RDK P+Poly resistor w/i Silicide >=2 3T (RPDMYi*PO*PP-RPO*RFDMY*NW*RDKDMY) 
//   rppolys_rf_rdk     RF RDK P+Poly resistor w/i Silicide <2 3T  (RPDMYi*PO*PP-RPO*RFDMY*NW*RDKDMY) 
//   rppolywo_rf_rdk    RF RDK P+Poly resistor w/o Silicide 3T     (RPDMYi*PO*PP*RPO*RH*RFDMY*NW*RDKDMY) 
//   nmos_rf              CORE RF NMOS                        ((NGATE-OD18-OD25-OD33-NT_Ni-VTH_N-VTL_N-ILVT)*DNW*RFDMY-RFDMY6T-RBCDMY-RDKDMY) 
//   nmos_rf_rdk          CORE RF NMOS RDK                    ((NGATE-OD18-OD25-OD33-NT_Ni-VTH_N-VTL_N-ILVT)*DNW*RFDMY-RFDMY6T-RBCDMY*RDKDMY) 
//   nmos_rf_nodnw        CORE RF NMOS w/o DNW                ((NGATE-OD18-OD25-OD33-NT_Ni-VTH_N-VTL_N-ILVT)-DNW*RFDMY-RBCDMY-RDKDMY) 
//   nmos_rf_18           1.8V RF NMOS                        ((NGATE*OD18-OD25-OD33-NT_Ni-VTH_N-VTL_N)*DNW*RFDMY-RFDMY6T-RBCDMY) 
//   nmos_rf_18_nodnw     1.8V RF NMOS w/o DNW                ((NGATE*OD18-OD25-OD33-NT_Ni-VTH_N-VTL_N)-DNW*RFDMY-RBCDMY) 
//   nmos_rf_na18         1.8V RF Native NMOS                 ((NGATE*OD18-OD25-OD33*NT_Ni-VTH_N-VTL_N)-DNW*RFDMY-RFDMY6T-RBCDMY) 
//   nmos_rf_25           2.5V RF NMOS                        ((NGATE-OD18*OD25-OD33-OD25_18-OD25_33-NT_Ni-VTH_N-VTL_N)*DNW*RFDMY-RFDMY6T-RBCDMY-HVD_NW) 
//   nmos_rf_25_nodnw     2.5V RF NMOS w/o DNW                ((NGATE-OD18*OD25-OD33-OD25_18-OD25_33-NT_Ni-VTH_N-VTL_N)-DNW*RFDMY-RBCDMY-HVD_NW) 
//   nmos_rf_25od         2.5V RF NMOS over_drive 3.3V            ((NGATE-OD18*OD25-OD33-OD25_18*OD25_33-NT_Ni-VTH_N-VTL_N)*DNW*RFDMY-RFDMY6T-RBCDMY) 
//   nmos_rf_25_nodnwod   2.5V RF NMOS over_drive 3.3V w/o DNW    ((NGATE-OD18*OD25-OD33-OD25_18*OD25_33-NT_Ni-VTH_N-VTL_N)-DNW*RFDMY-RBCDMY) 
//   nmos_rf_25ud         2.5V RF NMOS under_drive 1.8V           ((NGATE-OD18*OD25-OD33*OD25_18-OD25_33-NT_Ni-VTH_N-VTL_N)*DNW*RFDMY-RFDMY6T-RBCDMY) 
//   nmos_rf_25_nodnwud   2.5V RF NMOS under_drive 1.8V w/o DNW   ((NGATE-OD18*OD25-OD33*OD25_18-OD25_33-NT_Ni-VTH_N-VTL_N)-DNW*RFDMY-RBCDMY) 
//   nmos_rf_33           3.3V RF NMOS                     ((NGATE-OD18-OD25*OD33-NT_Ni-VTH_N-VTL_N)*DNW*RFDMY-RFDMY6T-RBCDMY) 
//   nmos_rf_33_nodnw     3.3V RF NMOS w/o DNW             ((NGATE-OD18-OD25*OD33-NT_Ni-VTH_N-VTL_N)-DNW*RFDMY-RBCDMY) 
//   nmos_rf_hvt          HVT RF NMOS                      ((NGATE-OD18-OD25-OD33-NT_Ni*VTH_N-VTL_N)*DNW*RFDMY-RFDMY6T-RBCDMY) 
//   nmos_rf_hvt_nodnw    HVT RF NMOS w/o DNW              ((NGATE-OD18-OD25-OD33-NT_Ni*VTH_N-VTL_N)-DNW*RFDMY-RBCDMY) 
//   nmos_rf_lvt          LVT RF NMOS                      ((NGATE-OD18-OD25-OD33-NT_Ni-VTH_N*VTL_N-ILVT)*DNW*RFDMY-RFDMY6T-RBCDMY) 
//   nmos_rf_lvt_nodnw    LVT RF NMOS w/o DNW              ((NGATE-OD18-OD25-OD33-NT_Ni-VTH_N*VTL_N-ILVT)-DNW*RFDMY-RBCDMY) 
//   nmos_rf_6t     	6T CORE RF NMOS                  ((NGATE-OD18-OD25-OD33-NT_Ni-VTH_N-VTL_N-ILVT)*DNW*RFDMY*RFDMY6T-RBCDMY)  
//   nmos_rf_18_6t  	6T 1.8V RF NMOS                  ((NGATE*OD18-OD25-OD33-NT_Ni-VTH_N-VTL_N)*DNW*RFDMY*RFDMY6T-RBCDMY)  
//   nmos_rf_25_6t  	6T 2.5V RF NMOS                  ((NGATE-OD18*OD25-OD33-OD25_18-OD25_33-NT_Ni-VTH_N-VTL_N)*DNW*RFDMY*RFDMY6T-RBCDMY-HVD_NW)  
//   nmos_rf_25od33_6t	6T 2.5V RF NMOS over-drive 3.3V  ((NGATE-OD18*OD25-OD33-OD25_18*OD25_33-NT_Ni-VTH_N-VTL_N)*DNW*RFDMY*RFDMY6T-RBCDMY)  
//   nmos_rf_25ud18_6t 	6T 2.5V RF NMOS under-drive 1.8V ((NGATE-OD18*OD25-OD33*OD25_18-OD25_33-NT_Ni-VTH_N-VTL_N)*DNW*RFDMY*RFDMY6T-RBCDMY)  
//   nmos_rf_33_6t	6T 3.3V RF NMOS                  ((NGATE-OD18-OD25*OD33-NT_Ni-VTH_N-VTL_N)*DNW*RFDMY*RFDMY6T-RBCDMY)  
//   nmos_rf_hvt_6t     	6T HVT RF NMOS                   ((NGATE-OD18-OD25-OD33-NT_Ni*VTH_N-VTL_N)*DNW*RFDMY*RFDMY6T-RBCDMY)  
//   nmos_rf_lvt_6t 	6T LVT RF NMOS                   ((NGATE-OD18-OD25-OD33-NT_Ni-VTH_N*VTL_N-ILVT)*DNW*RFDMY*RFDMY6T-RBCDMY)  
//  
//   nmos_rf_mlvt        ILVT RF NMOS                   ((NGATE-OD18-OD25-OD33-NT_Ni-VTH_N-VTL_N*ILVT)*DNW*RFDMY-RFDMY6T-RBCDMY) 
//   nmos_rf_mlvt_nodnw  ILVT RF NMOS w/o DNW           ((NGATE-OD18-OD25-OD33-NT_Ni-VTH_N-VTL_N*ILVT)-DNW*RFDMY-RBCDMY) 
//   nmos_rf_mlvt_6t 	6T ILVT RF NMOS               ((NGATE-OD18-OD25-OD33-NT_Ni-VTH_N-VTL_N*ILVT)*DNW*RFDMY*RFDMY6T-RBCDMY) 
// 
//   pmos_rf              CORE RF PMOS                        ((PGATE-OD18-OD25-OD33-NT_Ni-VTH_P-VTL_P-ILVT)*DNW*RFDMY-RFDMY5T-RBCDMY-RDKDMY) 
//   pmos_rf_rdk          CORE RF PMOS RDK                    ((PGATE-OD18-OD25-OD33-NT_Ni-VTH_P-VTL_P-ILVT)*DNW*RFDMY-RFDMY5T-RBCDMY*RDKDMY) 
//   pmos_rf_nw           CORE RF PMOS w/o DNW                ((PGATE-OD18-OD25-OD33-NT_Ni-VTH_P-VTL_P-ILVT)-DNW*RFDMY-RFDMY5T-RBCDMY) 
//   pmos_rf_18           1.8V RF PMOS                        ((PGATE*OD18-OD25-OD33-NT_Ni-VTH_P-VTL_P)*DNW*RFDMY-RFDMY5T-RBCDMY) 
//   pmos_rf_18_nw        1.8V RF PMOS w/o DNW                ((PGATE*OD18-OD25-OD33-NT_Ni-VTH_P-VTL_P)-DNW*RFDMY-RFDMY5T-RBCDMY) 
//   pmos_rf_25           2.5V RF PMOS                        ((PGATE-OD18*OD25-OD33-OD25_18-OD25_33-NT_Ni-VTH_P-VTL_P)*DNW*RFDMY-RFDMY5T-RBCDMY-HVD_P) 
//   pmos_rf_25_nw        2.5V RF PMOS w/o DNW                ((PGATE-OD18*OD25-OD33-OD25_18-OD25_33-NT_Ni-VTH_P-VTL_P)-DNW*RFDMY-RFDMY5T-RBCDMY-HVD_P) 
//   pmos_rf_25od         2.5V RF PMOS over_drive 3.3V        ((PGATE-OD18*OD25-OD33-OD25_18*OD25_33-NT_Ni-VTH_P-VTL_P)*DNW*RFDMY-RFDMY5T-RBCDMY) 
//   pmos_rf_25_nwod      2.5V RF PMOS over_drive 3.3V w/o DNW   ((PGATE-OD18*OD25-OD33-OD25_18*OD25_33-NT_Ni-VTH_P-VTL_P)-DNW*RFDMY-RFDMY5T-RBCDMY) 
//   pmos_rf_25ud         2.5V RF PMOS under_drive 1.8V          ((PGATE-OD18*OD25-OD33*OD25_18-OD25_33-NT_Ni-VTH_P-VTL_P)*DNW*RFDMY-RFDMY5T-RBCDMY) 
//   pmos_rf_25_nwud      2.5V RF PMOS under_drive 1.8V w/o DNW  ((PGATE-OD18*OD25-OD33*OD25_18-OD25_33-NT_Ni-VTH_P-VTL_P)-DNW*RFDMY-RFDMY5T-RBCDMY) 
//   pmos_rf_33           3.3V RF PMOS                     ((PGATE-OD18-OD25*OD33-NT_Ni-VTH_P-VTL_P)*DNW*RFDMY-RFDMY5T-RBCDMY) 
//   pmos_rf_33_nw        3.3V RF PMOS w/o DNW             ((PGATE-OD18-OD25*OD33-NT_Ni-VTH_P-VTL_P)-DNW*RFDMY-RFDMY5T-RBCDMY) 
//   pmos_rf_hvt          HVT RF PMOS                      ((PGATE-OD18-OD25-OD33-NT_Ni*VTH_P-VTL_P)*DNW*RFDMY-RFDMY5T-RBCDMY) 
//   pmos_rf_hvt_nw       HVT RF PMOS w/o DNW              ((PGATE-OD18-OD25-OD33-NT_Ni*VTH_P-VTL_P)-DNW*RFDMY-RFDMY5T-RBCDMY) 
//   pmos_rf_lvt          LVT RF PMOS                      ((PGATE-OD18-OD25-OD33-NT_Ni-VTH_P*VTL_P-ILVT)*DNW*RFDMY-RFDMY5T-RBCDMY) 
//   pmos_rf_lvt_nw       LVT RF PMOS w/o DNW              ((PGATE-OD18-OD25-OD33-NT_Ni-VTH_P*VTL_P-ILVT)-DNW*RFDMY-RFDMY5T-RBCDMY) 
//   pmos_rf_5t        	5T CORE RF PMOS                  ((PGATE-OD18-OD25-OD33-NT_Ni-VTH_P-VTL_P-ILVT)*DNW*RFDMY*RFDMY5T-RBCDMY)  
//   pmos_rf_nw_5t 	5T CORE RF PMOS w/o DNW          ((PGATE-OD18-OD25-OD33-NT_Ni-VTH_P-VTL_P-ILVT)-DNW*RFDMY*RFDMY5T-RBCDMY)  
//   pmos_rf_18_5t	5T 1.8V RF PMOS                  ((PGATE*OD18-OD25-OD33-NT_Ni-VTH_P-VTL_P)*DNW*RFDMY*RFDMY5T-RBCDMY)  
//   pmos_rf_18_nw_5t  	5T 1.8V RF PMOS w/o DNW          ((PGATE*OD18-OD25-OD33-NT_Ni-VTH_P-VTL_P)-DNW*RFDMY*RFDMY5T-RBCDMY)  
//   pmos_rf_25_5t     	5T 2.5V RF PMOS                  ((PGATE-OD18*OD25-OD33-OD25_18-OD25_33-NT_Ni-VTH_P-VTL_P)*DNW*RFDMY*RFDMY5T-RBCDMY-HVD_P)  
//   pmos_rf_25_nw_5t  	5T 2.5V RF PMOS w/o DNW          ((PGATE-OD18*OD25-OD33-OD25_18-OD25_33-NT_Ni-VTH_P-VTL_P)-DNW*RFDMY*RFDMY5T-RBCDMY)  
//   pmos_rf_25od33_5t 	5T 2.5V RF PMOS over-drive 3.3V  ((PGATE-OD18*OD25-OD33-OD25_18*OD25_33-NT_Ni-VTH_P-VTL_P)*DNW*RFDMY*RFDMY5T-RBCDMY)  
//   pmos_rf_25od33_nw_5t   5T 2.5V RF PMOS w/o DNW over-drive 3.3V  ((PGATE-OD18*OD25-OD33-OD25_18*OD25_33-NT_Ni-VTH_P-VTL_P)-DNW*RFDMY*RFDMY5T-RBCDMY)  
//   pmos_rf_25ud18_5t 	5T 2.5V RF PMOS under-drive 1.8V         ((PGATE-OD18*OD25-OD33*OD25_18-OD25_33-NT_Ni-VTH_P-VTL_P)*DNW*RFDMY*RFDMY5T-RBCDMY)  
//   pmos_rf_25ud18_nw_5t   5T 2.5V RF PMOS w/o DNW under-drive 1.8V ((PGATE-OD18*OD25-OD33*OD25_18-OD25_33-NT_Ni-VTH_P-VTL_P)-DNW*RFDMY*RFDMY5T-RBCDMY)  
//   pmos_rf_33_5t     	5T 3.3V RF PMOS                  ((PGATE-OD18-OD25*OD33-NT_Ni-VTH_P-VTL_P)*DNW*RFDMY*RFDMY5T-RBCDMY)  
//   pmos_rf_33_nw_5t  	5T 3.3V RF PMOS w/o DNW          ((PGATE-OD18-OD25*OD33-NT_Ni-VTH_P-VTL_P)-DNW*RFDMY*RFDMY5T-RBCDMY)  
//   pmos_rf_hvt_5t     	5T HVT RF PMOS                   ((PGATE-OD18-OD25-OD33-NT_Ni*VTH_P-VTL_P)*DNW*RFDMY*RFDMY5T-RBCDMY)  
//   pmos_rf_hvt_nw_5t  	5T HVT RF PMOS w/o DNW           ((PGATE-OD18-OD25-OD33-NT_Ni*VTH_P-VTL_P)-DNW*RFDMY*RFDMY5T-RBCDMY)  
//   pmos_rf_lvt_5t     	5T LVT RF PMOS                   ((PGATE-OD18-OD25-OD33-NT_Ni-VTH_P*VTL_P-ILVT)*DNW*RFDMY*RFDMY5T-RBCDMY)  
//   pmos_rf_lvt_nw_5t  	5T LVT RF PMOS w/o DNW           ((PGATE-OD18-OD25-OD33-NT_Ni-VTH_P*VTL_P-ILVT)-DNW*RFDMY*RFDMY5T-RBCDMY)  
// 
//   pmos_rf_mlvt         ILVT RF PMOS                   ((PGATE-OD18-OD25-OD33-NT_Ni-VTH_P-VTL_P*ILVT)*DNW*RFDMY-RFDMY5T-RBCDMY) 
//   pmos_rf_mlvt_nw      ILVT RF PMOS w/o DNW           ((PGATE-OD18-OD25-OD33-NT_Ni-VTH_P-VTL_P*ILVT)-DNW*RFDMY-RFDMY5T-RBCDMY) 
//   pmos_rf_mlvt_5t     	5T ILVT RF PMOS                ((PGATE-OD18-OD25-OD33-NT_Ni-VTH_P-VTL_P*ILVT)*DNW*RFDMY*RFDMY5T-RBCDMY)  
//   pmos_rf_mlvt_nw_5t  	5T ILVT RF PMOS w/o DNW        ((PGATE-OD18-OD25-OD33-NT_Ni-VTH_P-VTL_P*ILVT)-DNW*RFDMY*RFDMY5T-RBCDMY) 
//   xjvar                XJ varactor                     (VAR*RFDMY*NW*DNW*NP*PP*OD-RBCDMY)      
//   xjvar_nw             XJ varactor w/o DNW             (VAR*RFDMY*NW-DNW*NP*PP*OD-RBCDMY)      
//   ndio_hia_rf	        RF high-current ESD N+/PW DIODE ((DIODMY*OD*NP-OD25-OD33-OD18*PSUB-OD1T-DCO)*RFDMY*HIADMY-RBCDMY) 
//   pdio_hia_rf	        RF high-current ESD P+/NW DIODE ((DIODMY*OD*PP-OD25-OD33-OD18*NW-OD1T-DCO)*RFDMY*HIADMY-RBCDMY) 
//   sbd_rf         	RF Schottky Barrier Diode w/i DNW (NW*ODI*SBDDMY*RFDMY-VAR*PP*NP*DNW-RBCDMY)  
//   sbd_rf_nw            RF Schottky Barrier Diode w/o DNW (NW*ODI*SBDDMY*RFDMY-VAR*PP*NP-DNW-RBCDMY)  
// 
// 
//   probe1               Probe M1                        (M1*PROBEM1) 
//   probe2               Probe M2                        (M2*PROBEM2) 
//   probe3               Probe M3                        (M3*PROBEM3) 
//   probe4               Probe M4                        (M4*PROBEM4) 
//   probe5               Probe M5                        (M5*PROBEM5) 
//   probe6               Probe M6                        (M6*PROBEM6) 
//   probe7               Probe M7                        (M7*PROBEM7) 
//    mimcap_um_sin_rf     RF mimcap w/i shield      (ctm*cbm*shield*M8*RFDMYall) 
//    mimcap_woum_sin_rf	 RF mimcap w/o shield      (ctm*cbm-shield*M8*RFDMY) 
// 
// 
// 
//    mimcap_sin		 mimcap 2T      	   (ctm*cbm-RFDMY-MIM_3TDMY) 
//    mimcap_sin_3t	 mimcap 3T		   (ctm*cbm-RFDMYall*MIM_3TDMY) 
// 
// 
// 
//    fmom                 parallel finger rtmom        ((PO*MOMDMY0*M1*MOMDMY1*M2*MOMDMY2*M3*MOMDMY3)*MAC-RFDMY-MOMDMY22-MOMDMY_2T-RBCDMY)  
//    fmom_mx              parallel finger cross rtmom  ((PO*MOMDMY0*M1*MOMDMY1*M2*MOMDMY2*M3*MOMDMY3)*MAC*MOMDMY22-MOMDMY_2T-RBCDMY) 
//    crtmom               crtmom                    ((PO*MOMDMY0*M1*MOMDMY1*M2*MOMDMY2*M3*MOMDMY3)-RFDMY-MOMDMY_2T-MOMDMY22-RBCDMY)  
//    crtmom_2t            crtmom                    ((PO*MOMDMY0*M1*MOMDMY1*M2*MOMDMY2*M3*MOMDMY3)-RFDMY*MOMDMY_2T-MOMDMY22-RBCDMY)  
//    crtmom_rf            RF crtmom		   ((PO*MOMDMY0*M1*MOMDMY1*M2*MOMDMY2*M3*MOMDMY3)*RFDMY-MOMDMY22-RBCDMY-RDKDMY) 
//    crtmom_rf_rdk        RF crtmom RDK		   ((PO*MOMDMY0*M1*MOMDMY1*M2*MOMDMY2*M3*MOMDMY3)*RFDMY-MOMDMY22-RBCDMY*RDKDMY) 
// 
//    crtmom_mx            cross crtmom              ((PO*MOMDMY0*M1*MOMDMY1*M2*MOMDMY2*M3*MOMDMY3)*MOMDMY22-MOMDMY_2T-RBCDMY) 
//    crtmom_mx            cross crtmom              ((PO*MOMDMY0*M1*MOMDMY1*M2*MOMDMY2*M3*MOMDMY3)*MOMDMY22*MOMDMY_2T-RBCDMY) 
//    lincap              Linear Cap            	    (NGATE-OD18-OD25-OD33*VTDN-RFDMY*DNW*NW) 
//    lincap_25		2.5V Linear Cap 	    (NGATE-OD18*OD25-OD33*VTDN-RFDMY*DNW*NW) 
//    lincap_rf		RF Linear Cap		    (NGATE-OD18-OD25-OD33*VTDN*RFDMY*DNW*NW) 
//    lincap_rf_25	RF 2.5V Linear Cap	    (NGATE-OD18*OD25-OD33*VTDN*RFDMY*DNW*NW) 
//    spiral_std_mu_z      Standard inductor         (M9*M8*IND_STD*IND_RADi*IND_NR-RBCDMY-TLDMY-RDKDMY) 
//    spiral_sym_mu_z      Symmetric inductor        (M9*M8*IND_SYM*IND_RADi*IND_NR-RBCDMY-TLDMY-RDKDMY) 
//    spiral_sym_ct_mu_z   Centro-tap inductor       (M9*M8*M7*IND_CT*IND_RADi*IND_NR-RBCDMY-TLDMY-RDKDMY) 
//    spiral_std_mu_z_rdk      Standard inductor RDK      (M9*M8*IND_STD*IND_RADi*IND_NR-RBCDMY-TLDMY*RDKDMY) 
//    spiral_sym_mu_z_rdk      Symmetric inductor RDK     (M9*M8*IND_SYM*IND_RADi*IND_NR-RBCDMY-TLDMY*RDKDMY) 
//    spiral_sym_ct_mu_z_rdk   Centro-tap inductor RDK    (M9*M8*M7*IND_CT*IND_RADi*IND_NR-RBCDMY-TLDMY*RDKDMY) 
// 
//    sline_gscpw_mu     GSCPW Transmission line(Mu)       (M9*M8*TLDMY*IND_STD) 
//    sline_ms_mu        MS Transmission line(Mu)          (M9*M1*TLDMY*IND_STD) 
//     
//    lowcpad_d15		RF Low-C PAD density 15-23%   (M9*M8*VIA8i*AP*CB*CB2*PO*PP*RFPADDMY*RFPADDMY2-RBCDMY)		 
//    lowcpad_d23		RF Low-C PAD density over 23% (M9*M8*VIA8i*AP*CB*CB2*PO*PP*RFPADDMY*RFPADDMY3-RBCDMY)		   
// 
// 
// 
//   nmos_rf_diff_nw     RBC Differential NMOS w/o DNW  ((NGATE-OD18-OD25-OD33-NT_Ni-VTH_N-VTL_N-ILVT)-DNW*RBCDMY*DIFRBC-RFDMY6T)  
//   nmos_rf_cross_nw    RBC Cross-Couple NMOS w/o DNW  ((NGATE-OD18-OD25-OD33-NT_Ni-VTH_N-VTL_N-ILVT)-DNW*RBCDMY*XCLRBC-RFDMY6T)  
//   nmos_rf_cas_nw      RBC Cascode NMOS w/o DNW       ((NGATE-OD18-OD25-OD33-NT_Ni-VTH_N-VTL_N-ILVT)-DNW*RBCDMY*CASRBC-RFDMY6T) 
//   rfesd_rf1           RBC RFESD 500V_1D_S            ((RBCDMY*RFESDMY*RFESD_R) 
//   rfesd_rf2           RBC RFESD 1KV_1D_S             ((RBCDMY*RFESDMY*RFESD_R) 
//   rfesd_rf3           RBC RFESD 1P5KV_1D1D_S         ((RBCDMY*RFESDMY*RFESD_R) 
//   rfesd_rf4           RBC RFESD 2KV_1D1D_S           ((RBCDMY*RFESDMY*RFESD_R) 
//   rfesd_rf5           RBC RFESD 500V_1D_M            ((RBCDMY*RFESDMY*RFESD_R) 
//   rfesd_rf6           RBC RFESD 1KV_1D_M             ((RBCDMY*RFESDMY*RFESD_R) 
//   rfesd_rf7           RBC RFESD 1P5V_1D1D_M          ((RBCDMY*RFESDMY*RFESD_R) 
//   rfesd_rf8           RBC RFESD 2KV_1D1D_M           ((RBCDMY*RFESDMY*RFESD_R) 
//   ----- ----------------------------- ---------------------------------- 
//   * PO = POI + DPO 
//   * OD = ODI + DOD 
//   * NGATE = ODI * POI * NP - NW  
//   * PGATE = ODI * POI * PP * NW 
//   * VARGT = ODI * POI * NP * NW * VAR 
//   * PVARGT = ODI * POI * PP * VAR 
//   * PSUB  = BULK 
//   * shield = M6 + M5 
//   * RFDMYall = RFDMY + RFDMYUD 
//   * RFESD_R = HIADMY*RFPADDMY*AP*M6*M5*VIA5i*POI*CB*CB2*PP*ODI*NW 
//   * INDDMY = IND_STD 
//////////////////////////////////////////////////////////////////////////////// 
// 
// USER NOTES :  
// 
// 0) Please read file "README" in the package and "DECK_USAGE" document in folder "TSMC_DOC_WM" to find out switch usage and LVS/LPE flow steps of N65 process. 
//  
// 1) The MAC devices must covered by MAC layer ( 208;1 ).  
// 
// 2) mnpg, mppg, ppvdd49, npvss49, floating wells are obtained in ERC rules, you can run LVS to get this information. 
//  
// 3) For Calibre "EDTEXT" file, use .INCLUDE strings.txt.  
//        LAYOUT TEXT  "text string" [x] [y]  (layer num) (cell name)  
//  
// 4) Input layer 'OD' is defined as thin oxide (OD) area which would   
//    be drawn by one generic od mask or by seperated N+OD and P+OD.   
//    Remove layers in the 'OD' entries you don't want to use at   
//    layer definition block.  
//  
// 5) Default setting for property check is 0%. Users should check with  
//    IP/Designe providers for proper tolerance.  
//  
// 6) It's recommended to run Calibre LVS by hierarchical mode since false  
//    errors have been encountered by only flat mode option '-lvs'.  
//  
// 7) Default property resolution for ambiguity is set to 32. It could be  
//    necessary to increase this setting to resolve serious ambiguity.  
//    Uncomment statement 'LVS PROPERTY RESOLUTION MAXIMUM' in this deck  
//    to reset the capability of property resolution.  
//  
// 8) This deck does not extract MOS AS/AD property by default. To turn on the  
//    extraction of MOS AS/AD property, please uncomment the line  
//    "#DEFINE extract_as_ad". It would cause SEED PROMOTION, and pose  
//    much overhead on layout netlist extraction, erc checks, and lvs comparison.  
//  
// 9) Thin oxide layers PDIFF (7;0) and NDIFF (8;0) are not recommended to be  
//    used as tape out layers. Please use OD (6:0) for thin oxide tape out layers.  
//    If PDIFF (7;0) and NDIFF (8;0) layers are used, be sure to check MT (tape out)  
//    form for correctness after modifying this LVS deck (to pass LVS check)  
//  
// 10) This lvs command file does not support four resistors "rrwod,rrwsti,rdnwod,rdnwsti".  
//    Spice model defines them just for providing the sheet resistance of RWELL  
//    and DNW, not for the purpose of forming devices. We can not guarantee the resistance  
//    value if these four devices are applied in customer's design.  
//  
// 11) By default, the two diodes, PWDNW and DNWPSUB, are not extracted in this command   
//     file.  Please turn on the switch, "#DEFINE extract_dnwdio",  
//     to apply the extraction of these two diode.   
// 
// 12) For 2.5V IO HVD device (such as : nch_hv25_snw, pch_hv25_spw, nch_hv25_snw_mac and pch_hv25_spw)  
//     We use WPE BSIM4.5 equation to calculate sca/scb/scc values. However, the boundary of wells about these devices are not clear from 
//     model team's comment. Hence, these extraction values (sca/scb/scc) are only for reference, it is not very accuracy values. 
//      
// 13) For more accuracy, We suggest customer to turn-on switch "DFM_LPE" to run LPE extraction. 
// 
// 14) Virtual Coneection Setting:  
//     By default, VIRTUAL CONNECT COLON is set yes. Please set to "NO" in LVS command file as doing full-chip checking. 
//     VIRTUAL CONNECT COLON YES --> VIRTUAL CONNECT COLON NO 
// 
// 15) This file usually reads all datatype (0-255) for each layer defined.  
//     User customization datatype maybe already included in the layout mapping of this deck.  
//     PLEASE ALWAYS REVIEW THE LAYER DEFINITION AND MODIFY IT FOR USERS' PARTICULAR LAYER USE. 
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//lvs_gen.pl version: 1.97
//calibre.pl version: 1.145

// LVS/RC_DFM switch option
// --------------------
//#define DFM_RULE    //uncomment this line when this deck would like to include DFM rules
#define RC_DECK    //uncomment this line when this deck would be used as a RC command file
//#define ZERO_NRS_NRD    //uncomment this line when this deck would set NRS=0 and NRD=0 
//#define FILTER_DGS_TIED_MOS // uncomment this line to filter MOS with D, G and S tied together (default filter MOS with all pins tied)
#define WELL_TO_PG_CHECK 
// Default is on. Turn on to highlight if nwell connects to ground or psub connects to power.
//#define GATE_TO_PG_CHECK 
// Default is off. Turn on to highlight if a mos gate directly connects to power or ground.
//#define PATH_CHECK 
// Default is off. Turn on to highlight if
//(1) nodes have a path to power but no path to ground
//(2) nodes have a path to ground but no path to power
//(3) nodes have no path to power or ground
//(4) nodes have no path to any label net
#define DS_TO_PG_CHECK 
// Default is on. Turn on to highlight if drain connects to power and source connects to ground.
#define FLOATING_WELL_CHECK 
// Default is on. Turn on to highlight if well does not connect to power or ground. 
//The nwell of moscaps and nwell-resistor are excluded.

VARIABLE WPED 5
VARIABLE PRESCALE 1.0

//#define NW_RING	//uncomment this line to enable the NW ring to separate the node from BULK

// POWER and GROUND name string variable setting
VARIABLE POWER_NAME  "AHVDD"  "AHVDDB"  "AHVDDG"  "AHVDDR"  "AHVDDWELL"  "AVDD"  "AVDDB"  "AVDDBG"  "AVDDG"  "AVDDR"  "AVDWELL"  "DHVDD"  "DVDD"  "HVDDWELL"  "TACVDD"  "TAVD33"  "TAVD33PST"  "TAVDD"  "TAVDDPST"  "TVDD"  "VD33"  "VDD"  "VDD5V"  "VDDESD"  "VDDG"  "VDDM"  "VDDPST"  "VDDSA"  "VDWELL" 

VARIABLE GROUND_NAME  "AGND"  "AHVSS"  "AHVSSB"  "AHVSSG"  "AHVSSR"  "AHVSSUB"  "AVSS"  "AVSSB"  "AVSSBG"  "AVSSG"  "AVSSR"  "AVSSUB"  "DHVSS"  "DVSS"  "GND"  "HVSSUB"  "TAVSS"  "TAVSSPST"  "TVSS"  "VS33"  "VSS"  "VSSESD"  "VSSG"  "VSSM"  "VSSPST"  "VSSUB" 

//#########################################################################
//# ENVIRONMENT SETTING                              
//#########################################################################
// LVS option
// --------------------
//#define extract_as_ad
//

//  RC_BLOCKING SETTING
LAYOUT CELL LIST pcells "crtmom*" "crtmom_2t*" "crtmom_mx*" "crtmom_rf*" "crtmom_rf_rdk*" "fmom*" "fmom_mx*" "lincap_rf*" "lincap_rf_25*" "lowcpad*" "lowcpad*" "mimcap_um_rf*" "mimcap_woum_rf*" "moscap_rf*" "moscap_rf18*" "moscap_rf18_nw*" "moscap_rf25*" "moscap_rf25_nw*" "moscap_rf33*" "moscap_rf33_nw*" "moscap_rf_hvt*" "moscap_rf_hvt_nw*" "moscap_rf_nw*" "moscap_rf_rdk*" "ndio_hia_rf*" "nmos_rf*" "nmos_rf_18*" "nmos_rf_18_6t*" "nmos_rf_18_nodnw*" "nmos_rf_25*" "nmos_rf_25_6t*" "nmos_rf_25_nodnw*" "nmos_rf_25_nodnwod33*" "nmos_rf_25_nodnwud18*" "nmos_rf_25od33*" "nmos_rf_25od33_6t*" "nmos_rf_25ud18*" "nmos_rf_25ud18_6t*" "nmos_rf_33*" "nmos_rf_33_6t*" "nmos_rf_33_nodnw*" "nmos_rf_6t*" "nmos_rf_cas_nw*" "nmos_rf_cross_nw*" "nmos_rf_diff_nw*" "nmos_rf_hvt*" "nmos_rf_hvt_6t*" "nmos_rf_hvt_nodnw*" "nmos_rf_lvt*" "nmos_rf_lvt_6t*" "nmos_rf_lvt_nodnw*" "nmos_rf_mlvt*" "nmos_rf_mlvt_6t*" "nmos_rf_mlvt_nodnw*" "nmos_rf_na18*" "nmos_rf_nodnw*" "nmos_rf_rdk*" "pdio_hia_rf*" "pmos_rf*" "pmos_rf_18*" "pmos_rf_18_5t*" "pmos_rf_18_nw*" "pmos_rf_18_nw_5t*" "pmos_rf_25*" "pmos_rf_25_5t*" "pmos_rf_25_nw*" "pmos_rf_25_nw_5t*" "pmos_rf_25_nwod33*" "pmos_rf_25_nwud18*" "pmos_rf_25od33*" "pmos_rf_25od33_5t*" "pmos_rf_25od33_nw_5t*" "pmos_rf_25ud18*" "pmos_rf_25ud18_5t*" "pmos_rf_25ud18_nw_5t*" "pmos_rf_33*" "pmos_rf_33_5t*" "pmos_rf_33_nw*" "pmos_rf_33_nw_5t*" "pmos_rf_5t*" "pmos_rf_hvt*" "pmos_rf_hvt_5t*" "pmos_rf_hvt_nw*" "pmos_rf_hvt_nw_5t*" "pmos_rf_lvt*" "pmos_rf_lvt_5t*" "pmos_rf_lvt_nw*" "pmos_rf_lvt_nw_5t*" "pmos_rf_mlvt*" "pmos_rf_mlvt_5t*" "pmos_rf_mlvt_nw*" "pmos_rf_mlvt_nw_5t*" "pmos_rf_nw*" "pmos_rf_nw_5t*" "pmos_rf_rdk*" "pmoscap_rf*" "pmoscap_rf18*" "pmoscap_rf25*" "rfesd_rf1*" "rfesd_rf2*" "rfesd_rf3*" "rfesd_rf4*" "rfesd_rf5*" "rfesd_rf6*" "rfesd_rf7*" "rfesd_rf8*" "rppoly_rf*" "rppoly_rf_rdk*" "rppoly_rf*" "rppoly_rf_rdk*" "rppolywo_rf*" "rppolywo_rf_rdk*" "sbd_rf*" "sbd_rf_nw*" "sline_gscpw_mu*" "sline_ms_mu*" "spiral_std_mu_4x_n65*" "spiral_std_mu_4x_n65_custom*" "spiral_std_mu_4x_n65_em*" "spiral_std_mu_a_n65*" "spiral_std_mu_a_n65_custom*" "spiral_std_mu_a_n65_em*" "spiral_std_mu_a_n65*" "spiral_std_mu_a_n65_custom*" "spiral_std_mu_a_n65_em*" "spiral_std_mu_a_n65*" "spiral_std_mu_a_n65_custom*" "spiral_std_mu_a_n65_em*" "spiral_std_mu_z*" "spiral_std_mu_z_rdk*" "spiral_sym_ct_mu_4x_a_n65*" "spiral_sym_ct_mu_4x_a_n65_custom*" "spiral_sym_ct_mu_4x_a_n65_em*" "spiral_sym_ct_mu_a_a_n65*" "spiral_sym_ct_mu_a_a_n65_custom*" "spiral_sym_ct_mu_a_a_n65_em*" "spiral_sym_ct_mu_z*" "spiral_sym_ct_mu_z_rdk*" "spiral_sym_mu_4x_n65*" "spiral_sym_mu_4x_n65_custom*" "spiral_sym_mu_4x_n65_em*" "spiral_sym_mu_a_n65*" "spiral_sym_mu_a_n65_custom*" "spiral_sym_mu_a_n65_em*" "spiral_sym_mu_z*" "spiral_sym_mu_z_rdk*" "xjvar*" "xjvar_nw*" 
LAYOUT PRESERVE CELL LIST pcells

//#define STD_LIB_9_TRACK 	// uncomment this line to estimate 9 track WPE on STD cell, do not uncomment STD_LIB_11_TRACK at the same time.
//#define STD_LIB_11_TRACK	// uncomment this line to estimate 11 track WPE on STD cell, do not uncomment STD_LIB_9_TRACK at the same time.
// n-well approximity parameter       
#IFDEF STD_LIB_9_TRACK       
VARIABLE	PMOS_TOP_EXT 	0.725*1e-6
VARIABLE	NMOS_BOT_EXT 	0.665*1e-6
VARIABLE	MOS_LR_EXT 	5.0*1e-6
#ELSE
#IFDEF STD_LIB_11_TRACK
VARIABLE	PMOS_TOP_EXT    0.945*1e-6	
VARIABLE	NMOS_BOT_EXT    0.744*1e-6	
VARIABLE	MOS_LR_EXT 	5.0*1e-6
#ELSE
VARIABLE	PMOS_TOP_EXT 	0
VARIABLE	NMOS_BOT_EXT 	0
VARIABLE	MOS_LR_EXT 	0
#ENDIF
#ENDIF
    
//LVS HEAP DIRECTORY "/tmp"
//#define extract_dnwdio	// turn-on it to extract parasitic diode between dnw/psub & pwell/dnw
//#define extract_pnwdio	// turn-on it to extract parasitic diode between nwell/psub
//#define CELLIMP 		// turn-on it for LP sram device
//#define AP_UT			// turn-on it for extract ultra-thick AP RDL resistor  

//It's recommended to turn on the "FLATTEN CELL" option when dummy patterns are inserted.
//======================================================================================
//FLATTEN CELL TOP_CELL_DM TOP_CELL_DODDPO  // fill in topcell name of dummy patterns.   
    
LAYOUT PRIMARY "lvs_top"
LAYOUT PATH "lvs_top.gds"
LAYOUT SYSTEM GDSII
//LAYOUT PATH "layout.net"
//LAYOUT SYSTEM SPICE

SOURCE PRIMARY "lvs_top"
SOURCE PATH "lvs_top.cdl"
SOURCE SYSTEM SPICE

DRC RESULTS DATABASE "calibre_drc.db" ASCII // ASCII or GDSII
DRC SUMMARY REPORT "calibre_drc.sum"

ERC RESULTS DATABASE "calibre_erc.db" ASCII // ASCII or GDSII
ERC SUMMARY REPORT "calibre_erc.sum"

LVS REPORT "lvs.rep"
LVS REPORT MAXIMUM 1000 // ALL

#IFDEF RC_DECK
  //MASK RESULTS DATABASE NONE //"mask.db"
#ELSE
  MASK RESULTS DATABASE NONE //"mask.db"
#ENDIF

#IFDEF RC_DECK
  //MASK SVDB DIRECTORY "svdb" QUERY
#ELSE
  MASK SVDB DIRECTORY "svdb" QUERY
#ENDIF
LVS ISOLATE SHORTS YES
LVS REPORT OPTION S

PRECISION 1000
RESOLUTION 1
UNIT LENGTH U

TEXT DEPTH PRIMARY
PORT DEPTH PRIMARY

FLAG SKEW YES
FLAG OFFGRID YES
//LAYOUT ALLOW DUPLICATE CELL YES

LVS SPICE PREFER PINS	         YES
LVS ABORT ON SUPPLY ERROR        NO
LVS ALL CAPACITOR PINS SWAPPABLE YES
LVS RECOGNIZE GATES              NONE
LVS IGNORE PORTS                 NO
LVS CHECK PORT NAMES             YES
LVS REDUCE PARALLEL BIPOLAR      YES
LVS REDUCE PARALLEL MOS          YES
LVS REDUCE PARALLEL DIODES       YES
LVS REDUCE PARALLEL CAPACITORS   YES
LVS REDUCE PARALLEL RESISTORS    YES
LVS REDUCE SERIES RESISTORS      YES      //Smashes series resistors
LVS REDUCE SERIES CAPACITORS     YES      //Smashes series capacitors
LVS REDUCE SPLIT GATES           NO       //Smashes MOS split-gates.
LVS SPICE REPLICATE DEVICES 	 NO
// For hcell blocking
//LVS FILTER UNUSED OPTION B D E O
//Strongly recommand to comment FILTER_DGS_TIED_MOS switch
//AG is to filter MOS with all pins tied together, AB is to filter MOS with D,G,S tied together
#IFNDEF FILTER_DGS_TIED_MOS
LVS FILTER UNUSED OPTION AG RC RE RG
#ELSE
LVS FILTER UNUSED OPTION AB RC RE RG
#ENDIF
LVS PROPERTY RESOLUTION MAXIMUM 65536 // ALL




LVS REDUCE rnwsti_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rnwsti_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rnwod_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rnwod_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rpodwo_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rpodwo_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rnodwo_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rnodwo_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rpodl_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rpodl_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rnodl_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rnodl_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rpods_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rpods_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rnods_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rnods_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rppolys_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rppolys_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rnpolys_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rnpolys_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rppolyl_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rppolyl_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rnpolyl_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rnpolyl_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rppolywo_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rppolywo_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rnpolywo_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rnpolywo_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]



LAYOUT BASE LAYER ODI POI NP PP CO 


VIRTUAL CONNECT COLON YES

LVS POWER NAME POWER_NAME 
LVS GROUND NAME GROUND_NAME 
//#############################################
//# MAPPING                                   #
//#############################################
LAYER MAC            300 
LAYER MAP 208 DATATYPE 1 300 //  Dummy layer for MAC devices
LAYER RDKDMY         301 
LAYER MAP 208 DATATYPE 2 301 //  Dummy layer for RF RDK devices
LAYER DNW             1  //  Deep N-Well
LAYER NW              3  //  N-Well
LAYER ODI             6  7  8  //  Active area, thin oxide for device, or interconnection
LAYER DOD            302 
LAYER MAP 6 DATATYPE 1 302 //  Dummy OD
LAYER NT_Ni           11  //   Native NMOS blocked implant
LAYER VTL_N           12  //  CORE Low VT NMOS
LAYER VTL_P           13  //  CORE Low VT PMOS
LAYER OD33            15  //  Thick Oxide (dual gate oxide) for 3.3V device
LAYER OD18            16  //  FOR 1.8V device 
LAYER POI             17  //  Gate poly, poly Si
LAYER DPO            303 
LAYER MAP 17 DATATYPE 1 303 //  Dummy poly
LAYER ILVT           304 
LAYER MAP 17 DATATYPE 51 304 //  for LP process ilvt devices
LAYER OD25           305 
LAYER MAP 18 DATATYPE 0 305 //  Thick Oxide (dual gate oxide) for 2.5V device
LAYER OD25_33        306 
LAYER MAP 18 DATATYPE 3 306 //  2.5V device over_drive 3.3V
LAYER OD25_18        307 
LAYER MAP 18 DATATYPE 4 307 //  2.5V device under_drive 1.8V
LAYER OD25_28        308 
LAYER MAP 18 DATATYPE 5 308 //  2.5V device over_drive 2.8V,CIS model only
LAYER crown           102  // 
LAYER p3              103  // 
LAYER OD1T            27  // 
LAYER CAP1TDMY        78  // 
LAYER blc             101  // 
LAYER EDRAM_DECAP    309 
LAYER MAP 92 DATATYPE 1 309 //  used for DECAP mimcap
LAYER PP              25  //  P+ S/D Implant
LAYER NP              26  //  N+ S/D Implant
LAYER RPO             29  //  Non silicided area definition
LAYER CO              30  //  Contact Window
LAYER M1              31  //  Metal1
LAYER DUM1           310 
LAYER MAP 31 DATATYPE 1 310 //  dummy Metal1 for X metal
LAYER M2              32  //  Metal2
LAYER DUM2           311 
LAYER MAP 32 DATATYPE 1 311 //  dummy Metal2 for X metal
LAYER M3              33  //  Metal3
LAYER DUM3           312 
LAYER MAP 33 DATATYPE 1 312 //  dummy Metal3 for X metal
LAYER M4              34  //  Metal4
LAYER DUM4           313 
LAYER MAP 34 DATATYPE 1 313 //  dummy Metal4 for X metal
LAYER M5              35  //  Metal5
LAYER DUM5           314 
LAYER MAP 35 DATATYPE 1 314 //  dummy Metal5 for X metal
LAYER M6              36  //  Metal6
LAYER DUM6           315 316 
LAYER MAP 36 DATATYPE 1 315
LAYER MAP 36 DATATYPE 21 316 //  dummy Metal6 for X,Y metal
LAYER M7              37  //  Metal7 
LAYER DUM7           317 318 
LAYER MAP 37 DATATYPE 1 317
LAYER MAP 37 DATATYPE 21 318 //  dummy Metal7 for XY metal
LAYER M8              38  //  Metal8
LAYER DUM8           319 320 321 322 
LAYER MAP 38 DATATYPE 1 319
LAYER MAP 38 DATATYPE 21 320
LAYER MAP 38 DATATYPE 41 321
LAYER MAP 38 DATATYPE 81 322 //  dummy Metal8 for XYRZ metal
LAYER M9              39  //  Metal9
LAYER DUM9           323 324 325 326 327 
LAYER MAP 39 DATATYPE 1 323
LAYER MAP 39 DATATYPE 21 324
LAYER MAP 39 DATATYPE 41 325
LAYER MAP 39 DATATYPE 61 326
LAYER MAP 39 DATATYPE 81 327 //  dummy Metal9 for XYZRU metal
LAYER SRM            328 
LAYER MAP 50 DATATYPE 0 328 //  Use"SRM" to cover SRAM cell array to generate VTN_CELL mask.
LAYER SRM10          329 
LAYER MAP 50 DATATYPE 10 329 //  Use"SRM10" to cover LP process SRAM UHD cell array N65LP & N55LP SRAM only.
LAYER SRM11          330 
LAYER MAP 50 DATATYPE 11 330 //  Use"SRM11" to cover LP process SRAM HC cell array N65LP SRAM only.
LAYER SRM12          331 
LAYER MAP 50 DATATYPE 12 331 //  Use"SRM12" to cover SRAM DP 0.974 cell array.
LAYER SRM13          332 
LAYER MAP 50 DATATYPE 13 332 //  Use"SRM13" to cover SRAM DPHC 0.15 cell array.
LAYER SRM14          333 
LAYER MAP 50 DATATYPE 14 333 //  Use"SRM14" to cover SRAM TP 0.1158 cell array.
LAYER SRM15          334 
LAYER MAP 50 DATATYPE 15 334 //  Use"SRM15" to cover LP process SRAM HVT N65&N55 0.832 cell array.
LAYER SRM16          335 
LAYER MAP 50 DATATYPE 16 335 //  Use"SRM16" to cover LP process SRAM HVT N65 0.909 & N55 0.928 cell array.
LAYER SRM17          336 
LAYER MAP 50 DATATYPE 17 336 //  Use"SRM17" to cover SRAM ULP cell array.
LAYER VIA1i           51  //  Via12
LAYER VIA2i           52  //  Via23
LAYER VIA3i           53  //  Via34
LAYER VIA4i           54  //  Via45
LAYER VIA5i           55  //  Via56
LAYER VIA6i           56  //  Via67
LAYER VIA7i           57  //  Via78
LAYER VIA8i           58  //  Via89
LAYER VTH_N           67  //  CORE High VT DEVICE
LAYER VTH_P           68  //  CORE High VT DEVICE
LAYER VAR             143  //  layer to form Varactor
LAYER SBDDMY         337 
LAYER MAP 113 DATATYPE 0 337 //  Dummy layer for schottky barrier diode RF device
LAYER RH              117  //  layer to form diffusion and poly resistor
LAYER HRI             70  //  layer to form HRI poly resistor
LAYER ESD3            147  //  Cover high voltage IO designed by 3.3V NMOS
LAYER CBD             169  //  FOR AL RDL using
LAYER CB              76  //  Passivation opening for Bond Pad   
LAYER CB2             86  //  Passivation-2 opening for Bond Pad	
LAYER AP             338 
LAYER MAP 74 DATATYPE 0 338 //  AL RDL
LAYER DAP            339 
LAYER MAP 74 DATATYPE 1 339 //  Dummay layer for AL RDL
LAYER RV              85  //  FOR AL RDL using
LAYER VTUL_N          151  //  CORE ULTRA LOW VT DEVICE
LAYER VTUL_P          152  //  CORE ULTRA LOW VT DEVICE
LAYER HVD_P          340 
LAYER MAP 91 DATATYPE 2 340 //  HVPMOS
LAYER HVD_NW         341 
LAYER MAP 91 DATATYPE 3 341 //  HVNMOS for NW approach
LAYER UHVT_N          93  //  CORE ULTRA High VT DEVICE
LAYER UHVT_P          94  //  CORE ULTRA Higt VT DEVICE
LAYER RODMY           49  //  dummy layer for LVS to exclude OD area
LAYER BJTDMY         342 
LAYER MAP 110 DATATYPE 0 342 //  BJT dummy layer for LVS
LAYER BJTDMY1        343 
LAYER MAP 110 DATATYPE 1 343 //  Small BJT dummy layer for LVS
LAYER PSUB2           111  //  dummy layer for isolation power domains of PW
LAYER NWDMYi         344 
LAYER MAP 114 DATATYPE 0 344 //  dummy layer to form N-Well resistor
LAYER NWDMY1         345 
LAYER MAP 114 DATATYPE 1 345 //  dummy layer to form N-Well 3 terminals resistor
LAYER RPDMYi         346 
LAYER MAP 115 DATATYPE 0 346 //  dummy layer to form OD/POLY resistor (2-Terminals resistor)
LAYER RPDMY1         347 
LAYER MAP 115 DATATYPE 1 347 //  dummy layer to form OD/POLY resistor (3-Terminals resistor)
LAYER DIODMY          119  //  dummy layer to form diode
LAYER MOMDMY0        348 
LAYER MAP 155 DATATYPE 0 348 //  dummy layer for MOM devices metal0
LAYER MOMDMY1        349 
LAYER MAP 155 DATATYPE 1 349 //  dummy layer for MOM devices metal1
LAYER MOMDMY2        350 
LAYER MAP 155 DATATYPE 2 350 //  dummy layer for MOM devices metal2
LAYER MOMDMY3        351 
LAYER MAP 155 DATATYPE 3 351 //  dummy layer for MOM devices metal3
LAYER MOMDMY4        352 
LAYER MAP 155 DATATYPE 4 352 //  dummy layer for MOM devices metal4
LAYER MOMDMY5        353 
LAYER MAP 155 DATATYPE 5 353 //  dummy layer for MOM devices metal5
LAYER MOMDMY6        354 
LAYER MAP 155 DATATYPE 6 354 //  dummy layer for MOM devices metal6
LAYER MOMDMY7        355 
LAYER MAP 155 DATATYPE 7 355 //  dummy layer for MOM devices metal7
LAYER MOMDMY_2T      356 
LAYER MAP 155 DATATYPE 27 356 //  dummy layer for crtmom_2t and crtmom_mx_4t
LAYER MOMDMY21       357 
LAYER MAP 155 DATATYPE 21 357 //  dummy layer for dummy OD under MOM devices
LAYER MOMDMY22       358 
LAYER MAP 155 DATATYPE 22 358 //  dummy layer for crtmom_mx
LAYER MOMDMY23       359 
LAYER MAP 155 DATATYPE 23 359 //  dummy layer for crtmom_mx pin1 
LAYER MOMDMY24       360 
LAYER MAP 155 DATATYPE 24 360 //  dummy layer for crtmom_mx pin2
LAYER MOMDMY25       361 
LAYER MAP 155 DATATYPE 25 361 //  dummy layer for crtmom_mx plus1 & plus2
LAYER RFDMY           161  //  For RF Device using only ( some layout using datatype 1 )
LAYER RFDMY5T        362 
LAYER MAP 161 DATATYPE 3 362 //  For RF_5T Device using only
LAYER RFDMY6T        363 
LAYER MAP 161 DATATYPE 4 363 //  For RF_6T Device using only
LAYER RFDMYUD        364 
LAYER MAP 161 DATATYPE 10 364 //  New 2T baseband MIMCAP with CTMDMYUD replace original CTMMDY allow devices put under mimcap 
LAYER RMDMY1         365 
LAYER MAP 116 DATATYPE 1 365 //  dummy layer to form METAL-1 resistor
LAYER RMDMY2         366 
LAYER MAP 116 DATATYPE 2 366 //  dummy layer to form METAL-2 resistor
LAYER RMDMY3         367 
LAYER MAP 116 DATATYPE 3 367 //  dummy layer to form METAL-3 resistor
LAYER RMDMY4         368 
LAYER MAP 116 DATATYPE 4 368 //  dummy layer to form METAL-4 resistor
LAYER RMDMY5         369 
LAYER MAP 116 DATATYPE 5 369 //  dummy layer to form METAL-5 resistor
LAYER RMDMY6         370 
LAYER MAP 116 DATATYPE 6 370 //  dummy layer to form METAL-6 resistor
LAYER RMDMY7         371 
LAYER MAP 116 DATATYPE 7 371 //  dummy layer to form METAL-7 resistor
LAYER RMDMY8         372 
LAYER MAP 116 DATATYPE 8 372 //  dummy layer to form METAL-8 resistor
LAYER RMDMY9         373 
LAYER MAP 116 DATATYPE 9 373 //  dummy layer to form METAL-9 resistor
LAYER RMDMYAP        374 
LAYER MAP 116 DATATYPE 16 374 //  dummy layer to form AP resistor
LAYER SRAMPSGT       375 
LAYER MAP 186 DATATYPE 1 375 //  FOR SRAM NMOS passgate
LAYER SRAMCVSS       376 
LAYER MAP 186 DATATYPE 3 376 //  FOR CVSS SRAM
LAYER SRAMTIMER      377 
LAYER MAP 186 DATATYPE 6 377 //  FOR SRAM timer
LAYER IND_STD        378 
LAYER MAP 144 DATATYPE 0 378 //  For RF Inductor device standard
LAYER IND_SYM        379 
LAYER MAP 144 DATATYPE 1 379 //  For RF Inductor device symmetric
LAYER IND_CT         380 
LAYER MAP 144 DATATYPE 2 380 //  For RF Inductor device center-tap
LAYER IND_STD_MUA    381 
LAYER MAP 144 DATATYPE 6 381 //  For RF Inductor device std_mu_a 
LAYER IND_SYM_MUA    382 
LAYER MAP 144 DATATYPE 7 382 //  For RF Inductor device sym_mu_a
LAYER IND_CT_MUA     383 
LAYER MAP 144 DATATYPE 8 383 //  For RF Inductor device ct_mu_a
LAYER IND_STD_MZAA   384 
LAYER MAP 144 DATATYPE 9 384 //  For RF Inductor device std_mza_a 
LAYER IND_SYM_MZAA   385 
LAYER MAP 144 DATATYPE 10 385 //  For RF Inductor device sym_mza_a
LAYER IND_CT_MZAA    386 
LAYER MAP 144 DATATYPE 11 386 //  For RF Inductor device ct_mza_a
LAYER IND_RADi       387 
LAYER MAP 144 DATATYPE 30 387 //  For RF Inductor devices radious
LAYER IND_GDIS       388 
LAYER MAP 144 DATATYPE 31 388 //  For RF Inductor devices guardring distance
LAYER IND_NR         389 
LAYER MAP 144 DATATYPE 32 389 //  For RF Inductor devices nr 
LAYER IND_MP         390 
LAYER MAP 144 DATATYPE 33 390 //  For RF Inductor devices mimus pin 
LAYER IND_D4         391 
LAYER MAP 144 DATATYPE 34 391 //  For RF Inductor devices CTAP pin 
LAYER IND_S          392 
LAYER MAP 144 DATATYPE 35 392 //  For RF Inductor devices spacing 
LAYER IND_PSW        393 
LAYER MAP 144 DATATYPE 41 393 //  For RF Inductor devices passw 
LAYER IND_W          394 
LAYER MAP 144 DATATYPE 42 394 //  For RF Inductor devices width 
LAYER IND_CTW        395 
LAYER MAP 144 DATATYPE 43 395 //  For RF Inductor devices ctapw 
LAYER TLDMY          396 
LAYER MAP 144 DATATYPE 40 396 //  For Transmission line devices 
LAYER DRAIN          397 
LAYER MAP 6 DATATYPE 3 397 //  For RF MOS drain side using only
LAYER ctm             77  //  For MIM device
LAYER cbm             88  //  For MIM device
LAYER CAP1P5         398 
LAYER MAP 148 DATATYPE 115 398 //  For MIM device cap unit 1.5f
LAYER CAP2P0         399 
LAYER MAP 148 DATATYPE 120 399 //  For MIM device cap unit 2.0f
LAYER CAP1P0         400 
LAYER MAP 148 DATATYPE 110 400 //  For MIM device cap unit 1.0f
LAYER MIM_3TDMY      401 
LAYER MAP 148 DATATYPE 21 401 //  For MIM 3T device 
LAYER CTMDMYUD       402 
LAYER MAP 148 DATATYPE 10 402 //  New 2T baseband MIMCAP with CTMDMYUD replace original CTMMDY allow devices put under mimcap 
LAYER PROBEM1        403 
LAYER MAP 75 DATATYPE 1 403 //  M1 probe
LAYER PROBEM2        404 
LAYER MAP 75 DATATYPE 2 404 //  M2 probe
LAYER PROBEM3        405 
LAYER MAP 75 DATATYPE 3 405 //  M3 probe
LAYER PROBEM4        406 
LAYER MAP 75 DATATYPE 4 406 //  M4 probe
LAYER PROBEM5        407 
LAYER MAP 75 DATATYPE 5 407 //  M5 probe
LAYER PROBEM6        408 
LAYER MAP 75 DATATYPE 6 408 //  M6 probe
LAYER PROBEM7        409 
LAYER MAP 75 DATATYPE 7 409 //  M7 probe
LAYER PROBEAP        410 
LAYER MAP 75 DATATYPE 16 410 //  AP probe
LAYER DCO            411 
LAYER MAP 90 DATATYPE 0 411 //  For LPG devices
LAYER TCDDMY         412 
LAYER MAP 165 DATATYPE 1 412 //  Dummy layer to cover CPU pattern for TCD purpose
LAYER VTDN           413 
LAYER MAP 66 DATATYPE 0 413 //  For Linear Cap devices
LAYER RFPADDMY       414 
LAYER MAP 129 DATATYPE 0 414 //  For Gplus RFPAD devices
LAYER RFPADDMY1      415 
LAYER MAP 129 DATATYPE 1 415 //  For Gplus RFPAD devices for density 0-15%
LAYER RFPADDMY2      416 
LAYER MAP 129 DATATYPE 2 416 //  For Gplus RFPAD devices for density 15-23%
LAYER RFPADDMY3      417 
LAYER MAP 129 DATATYPE 3 417 //  For Gplus RFPAD devices for density over 23%
LAYER HIADMY         418 
LAYER MAP 168 DATATYPE 0 418 //  For RF high-current esd diodes dummy layer,must be covered by RFDMY
LAYER RHRI           419 
LAYER MAP 120 DATATYPE 0 419 //  New RHRI implant for HRI resistor 
LAYER CELLM          420 
LAYER MAP 121 DATATYPE 5 420 //  For CIS process Medium N+ device 
LAYER MEDP           421 
LAYER MAP 121 DATATYPE 6 421 //  For CIS process Medium P+ device 
LAYER CAP_IMP        422 
LAYER MAP 121 DATATYPE 4 422 //  For CIS process npolycap_25
LAYER CTP            423 
LAYER MAP 121 DATATYPE 14 423 //  For CIS PIPCAP poly2 layer
LAYER HRP            424 
LAYER MAP 121 DATATYPE 12 424 //  For CIS HRI p+ poly resistor 
LAYER RBCDMY         425 
LAYER MAP 208 DATATYPE 100 425 //  RBCDMY layer for RBC cells of diff,cascode, cross_couple, rfesd and lctank
LAYER DIFRBC         426 
LAYER MAP 208 DATATYPE 101 426 //  RBCDMY layer for RBC differential cell
LAYER XCLRBC         427 
LAYER MAP 208 DATATYPE 102 427 //  RBCDMY layer for RBC cross-couple cell
LAYER CASRBC         428 
LAYER MAP 208 DATATYPE 103 428 //  RBCDMY layer for RBC cascode cell
LAYER GTDMY1         429 
LAYER MAP 208 DATATYPE 104 429 //  RBCDMY layer for RBC gate dummy
LAYER GTDMY2         430 
LAYER MAP 208 DATATYPE 105 430 //  RBCDMY layer for RBC gate dummy
LAYER RFESDMY        431 
LAYER MAP 208 DATATYPE 106 431 //  RBCDMY layer for RBC rfesd cells, fixed layout
LAYER IND_TEXT       432
LAYER MAP 144 TEXTTYPE 39 432
LAYER RBC_TEXT       433
LAYER MAP 208 TEXTTYPE 108 433
TEXT LAYER 131 ATTACH 131 metal1
PORT LAYER TEXT 131
TEXT LAYER 126 ATTACH 126 metal10
PORT LAYER TEXT 126
TEXT LAYER 132 ATTACH 132 metal2
PORT LAYER TEXT 132
TEXT LAYER 133 ATTACH 133 metal3
PORT LAYER TEXT 133
TEXT LAYER 134 ATTACH 134 metal4
PORT LAYER TEXT 134
TEXT LAYER 135 ATTACH 135 metal5
PORT LAYER TEXT 135
TEXT LAYER 136 ATTACH 136 metal6
PORT LAYER TEXT 136
TEXT LAYER 137 ATTACH 137 metal7
PORT LAYER TEXT 137
TEXT LAYER 138 ATTACH 138 metal8
PORT LAYER TEXT 138
TEXT LAYER 139 ATTACH 139 metal9
PORT LAYER TEXT 139
//#IFDEF RC_DECK
TEXT LAYER 149 ATTACH 149 poly
PORT LAYER TEXT 149
//#ENDIF

//#IFNDEF RC_DECK

#IFNDEF DFM_RULE
LAYER MAP 149 TEXTTYPE 1 434
TEXT LAYER 434 ATTACH 434 poly
PORT LAYER TEXT 434
#ENDIF
//#ENDIF
TEXT LAYER 139 ATTACH 139 sline_m9m
PORT LAYER TEXT 139
TEXT LAYER 139 ATTACH 139 sline_m9p
PORT LAYER TEXT 139
//#############################################
//# LOGIC OPERATION POOL                      #
//#############################################

//Form BULK layer
DRC:1 = EXTENT
BULK  = SIZE DRC:1 BY 0.005

//* Define device -- nmos nch
rpolywo1 = POI AND RH 
rpolywo2 = rpolywo1 AND RPO 
RPDMY = RPDMYi OR RPDMY1 
OD = ODI OR DOD 
rodsrm = RODMY AND SRM 
diffa = OD NOT rodsrm 
diff = diffa INTERACT CO 
rp1 = RPDMY NOT INTERACT diff 
p1rdum = rp1 INTERACT POI  //  poly1 resistor dummy
rpolywo = rpolywo2 INTERACT p1rdum 
poly1 = POI NOT rpolywo 
rpoly1 = POI AND p1rdum 
rpoly = rpoly1 NOT INTERACT RPO 
poly21 = poly1 NOT rpoly 
poly = poly21 OR DPO  //  Poly interconnect 
dumpo1 = poly INSIDE diff 
dumpo2 = dumpo1 NOT INTERACT CO 
realpo = poly NOT dumpo2 
rodwo1 = diff AND RH 
rodwo2 = rodwo1 AND RPO 
drdum = RPDMY INTERACT diff  //  diff resistor dummy
rodwo3 = rodwo2 INTERACT drdum 
rodwo = rodwo3 INTERACT ODI 
mdiff1 = diff NOT rodwo 
rod1 = diff AND drdum 
rod2 = rod1 NOT INTERACT RPO 
rod = rod2 INTERACT ODI 
mdiff = mdiff1 NOT rod 
gate11 = realpo AND mdiff 
poly_rbc_dmy1 = realpo AND RBCDMY 
GTDMY = GTDMY1 OR GTDMY2 
poly_rbc_dmy = poly_rbc_dmy1 NOT INTERACT GTDMY 
gate1 = gate11 NOT poly_rbc_dmy 
RFDMY_pure = RFDMY NOT INTERACT RBCDMY 
gate_a_rfi = gate1 AND RFDMY_pure  //  All RF devices except RBC cells
poly_rf1 = poly INTERACT CO 
poly_rf = poly_rf1 INTERACT DRAIN  //  only poly interact DRAIN are valid for pure RF
gate_rfb = gate_a_rfi AND poly_rf 
gate_a = gate1 NOT gate_rfb 
gate_a_rbc = gate1 AND RBCDMY  //  RBC RF cells
poly_rbc = poly_rf1 INTERACT GTDMY  //  only poly interact GTDMY are valid for RBC
gate_rbc = gate_a_rbc AND poly_rbc 
gate_b = gate_a NOT gate_rbc 
gate_a_rf = gate_a_rbc OR gate_a_rfi 
rf_diff = mdiff INTERACT DRAIN 
poly_rf_all = gate_a_rf INTERACT rf_diff 
poly_rf_noco = poly_rf_all NOT INTERACT CO 
gate = gate_b NOT poly_rf_noco 
gate_nosr = gate NOT SRM 
NWDMY = NWDMYi OR NWDMY1 
nxwell = NW NOT NWDMY  //  define N_well region
gatennw = gate_nosr NOT nxwell  //  gate not inside nwell
tngate1 = gatennw AND NP 
tngate2 = tngate1 NOT OD25 
tngate3 = tngate2 NOT OD33 
tngate4 = tngate3 NOT OD18 
tngate5 = tngate4 NOT NT_Ni 
tngate6 = tngate5 NOT DNW 
nlvgate_org1 = tngate6 AND VTL_N 
ngate1 = tngate6 NOT nlvgate_org1 
nhvgate1 = tngate6 AND VTH_N 
nhvgate2 = nhvgate1 NOT DCO 
ngate2 = ngate1 NOT nhvgate2 
tngate7 = tngate6 NOT OD1T 
nuvgate_org1 = tngate7 AND VTUL_N 
ngate31 = ngate2 NOT nuvgate_org1 
nuhvgate_org1 = tngate6 AND UHVT_N 
ngate3 = ngate31 NOT nuhvgate_org1 
ngate4 = ngate3 NOT OD1T 
ngate5 = ngate4 NOT ILVT 
ngate_org1 = ngate5 NOT DCO 
ngate_org = COPY ngate_org1 
ngate = ngate_org NOT MAC  //  CORE NMOS

//***** Define connectivity/via layer -- tndiff ****
nthin1 = mdiff AND NP 
ydio_a = ESD3 AND OD 
ydio_c = SIZE ydio_a BY -0.2 
ydio_d = ydio_c AND NP 
ydio_e = ydio_d AND RPO 
ydio_f = ydio_e NOT NW 
ydio_g = ESD3 AND POI 
ydio_h = SIZE ydio_g BY 0.2 
ydio_i = ydio_f NOT ydio_h 
ydio_j = SIZE ydio_i BY -0.8 
ydio = SIZE ydio_j BY 0.6 
nthin = nthin1 NOT ydio  //  define N+ thin oxide
tndiffa = nthin NOT gate1  //  define N+ diffusion region
diffb = diffa NOT diff 
ndiffb = diffb AND NP 
tndiff_ori = tndiffa OR ndiffb 
s_tndiff1 = tndiff_ori NOT DRAIN 
gate_rf = gate_rfb NOT VAR 
gate_rf_all = gate_rbc OR gate_rf 
s_tndiff = s_tndiff1 INTERACT gate_rf_all 
tndiff_ori1 = tndiff_ori NOT s_tndiff 
s_tndiff_cas1 = s_tndiff1 INTERACT GTDMY2 
s_tndiff_cas = s_tndiff_cas1 INTERACT CO 
tndiff_ori2 = tndiff_ori1 NOT s_tndiff_cas 
d_tndiff = tndiff_ori AND DRAIN 
tndiff = tndiff_ori2 NOT d_tndiff 

//***** Define connectivity/via layer -- psub ****
ppsub = BULK NOT NW  //  define total p_sub region
psub2s = SIZE PSUB2 BY 0.01 
psubband = psub2s NOT PSUB2  //   psub separator band (doughnut).
psub = ppsub NOT psubband 

//* Define device -- nmos nch_dnw
tdgate1a = tngate5 AND DNW 
tdgate1 = tdgate1a NOT OD1T 
n1lvgate_org1 = tdgate1 AND VTL_N 
nrgate1 = tdgate1 NOT n1lvgate_org1 
n1hvgate1 = tdgate1 AND VTH_N 
n1hvgate_org1 = n1hvgate1 NOT DCO 
nrgate2 = nrgate1 NOT n1hvgate_org1 
n1uvgate_org1 = tdgate1 AND VTUL_N 
nrgate31 = nrgate2 NOT n1uvgate_org1 
n1uhvgate_org1 = tdgate1 AND UHVT_N 
nrgate3 = nrgate31 NOT n1uhvgate_org1 
nrgate4 = nrgate3 NOT ILVT 
nrgate_org1 = nrgate4 NOT DCO 
nrgate_org = COPY nrgate_org1 
nrgate = nrgate_org NOT MAC  //  CORE NMOS on DNW

//* Define device -- nmos nch_mac
ngate_mac = ngate_org AND MAC  //  CORE NMOS MAC

//* Define device -- nmos nch_dnw_mac
nrgate_mac = nrgate_org AND MAC  //  CORE NMOS on DNW MAC

//* Define device -- nmos nch_hvt
nhvgate_org = COPY nhvgate2 
nhvgate = nhvgate_org NOT MAC  //  CORE HIGH_VT NMOS

//* Define device -- nmos nch_hvt_dnw
n1hvgate_org = COPY n1hvgate_org1 
n1hvgate = n1hvgate_org NOT MAC  //  CORE HIGH_VT NMOS on DNW

//* Define device -- nmos nch_hvt_mac
nhvgate_mac = nhvgate_org AND MAC  //  CORE HIGH_VT NMOS MAC

//* Define device -- nmos nch_hvt_dnw_mac
n1hvgate_mac = n1hvgate_org AND MAC  //  CORE HIGH_VT NMOS on DNW MAC

//* Define device -- nmos nch_lvt
nlvgate_org = COPY nlvgate_org1 
nlvgate = nlvgate_org NOT MAC  //  CORE LOW_VT NMOS

//* Define device -- nmos nch_lvt_dnw
n1lvgate_org = COPY n1lvgate_org1 
n1lvgate = n1lvgate_org NOT MAC  //  CORE LOW_VT NMOS on DNW

//* Define device -- nmos nch_lvt_mac
nlvgate_mac = nlvgate_org AND MAC  //  CORE LOW_VT NMOS MAC

//* Define device -- nmos nch_lvt_dnw_mac
n1lvgate_mac = n1lvgate_org AND MAC  //  CORE LOW_VT NMOS on DNW

//* Define device -- nmos nch_ulvt
nuvgate_org = COPY nuvgate_org1 
nuvgate = nuvgate_org NOT MAC  //  CORE ULTRA VT NMOS

//* Define device -- nmos nch_ulvt_dnw
n1uvgate_org = COPY n1uvgate_org1 
n1uvgate = n1uvgate_org NOT MAC  //  CORE ULTRA VT NMOS on DNW

//* Define device -- nmos nch_ulvt_mac
nuvgate_mac = nuvgate_org AND MAC  //  CORE ULTRA VT NMOS MAC

//* Define device -- nmos nch_ulvt_dnw_mac
n1uvgate_mac = n1uvgate_org AND MAC  //  CORE ULTRA VT NMOS on DNW MAC

//* Define device -- nmos nch_uhvt
nuhvgate_org = COPY nuhvgate_org1 
nuhvgate = nuhvgate_org NOT MAC  //  CORE ULTRA High VT NMOS

//* Define device -- nmos nch_uhvt_dnw
n1uhvgate_org = COPY n1uhvgate_org1 
n1uhvgate = n1uhvgate_org NOT MAC  //  CORE ULTRA High VT NMOS on DNW

//* Define device -- nmos nch_uhvt_mac
nuhvgate_mac = nuhvgate_org AND MAC  //  CORE ULTRA High VT NMOS MAC

//* Define device -- nmos nch_uhvt_dnw_mac
n1uhvgate_mac = n1uhvgate_org AND MAC  //  CORE ULTRA High VT NMOS on DNW MAC

//* Define device -- nmos nch_lpg
ngatelpg1 = tngate5 NOT nlvgate_org1 
ngatelpg2 = ngatelpg1 NOT nhvgate2 
ngatelpg3 = ngatelpg2 NOT nuvgate_org1 
ngatelpg4 = ngatelpg3 NOT nuhvgate_org1 
ngatelpg5 = ngatelpg4 NOT OD1T 
ngatelpg6 = ngatelpg5 NOT ILVT 
nhvgate1a = tngate5 AND VTH_N 
nhvgatelpg = nhvgate1a AND DCO  //  CORE HIGH_VT LPG NMOS
ngatelpg7 = ngatelpg6 NOT nhvgatelpg 
ngatelpg = ngatelpg7 AND DCO  //  CORE LPG NMOS

//* Define device -- nmos nch_lpgna
nlgate1 = tngate4 AND NT_Ni 
nlgate2 = nlgate1 NOT VTL_N 
nlgate3 = nlgate2 NOT VTH_N 
nlgate4 = nlgate3 NOT VTUL_N 
nlgate5 = nlgate4 NOT DNW 
nlgate6 = nlgate5 NOT ILVT 
nlgatelpg = nlgate6 AND DCO  //  CORE LPG Devices

//* Define device -- nmos nch_na
nlgate7 = nlgate6 NOT DCO 
nlgate = nlgate7 NOT MAC  //  CORE Native Devies

//* Define device -- nmos nch_na_mac
nlgate_mac = nlgate7 AND MAC  //  CORE Native Devies MAC

//* Define device -- nmos nch_w
ngate_1ta = tngate5 AND OD1T 
ngate_1tb = ngate_1ta NOT VTL_N 
ngate_1tc = ngate_1tb NOT VTH_N 
ngate_1td = ngate_1tc NOT VTUL_N 
ngate_1te = ngate_1td NOT CAP1TDMY 
ngate_1tf = ngate_1te NOT INTERACT p3 
ngate_w1t = ngate_1tf NOT DNW  //  eDRAM nch_w device

//* Define device -- nmos nch_w_lvt
ngate_1tg = ngate_1tc AND VTUL_N 
ngate_1th = ngate_1tg NOT CAP1TDMY 
ngate_1ti = ngate_1th NOT INTERACT p3 
ngate_w1t_lvt = ngate_1ti NOT DNW  //  eDRAM nch_w_lvt device

//* Define device -- nmos nch_dnw_w
ngate_dnw_w = ngate_1tf AND DNW  //  eDRAM nch_dnw_w device

//* Define device -- nmos nch_dnw_w_lvt
ngate_dnw_w_lvt = ngate_1ti AND DNW  //  eDRAM nch_dnw_w_lvt device

//* Define device -- nmos nch_dnw_1tr
ngate_1te_dnw = ngate_1te AND DNW 
ngate_1tr = ngate_1te_dnw INTERACT p3  //   eDRAM nch_dnw_1tr device

//* Define device -- nmos nch_mlvt
nilvtgate_org1 = ngate3 AND ILVT 
nilvtgate_org = COPY nilvtgate_org1 
nilvtgate = nilvtgate_org NOT MAC  //  LP NMOS MLVT device

//* Define device -- nmos nch_mlvt_dnw
n1ilvtgate_org1 = nrgate3 AND ILVT 
n1ilvtgate_org = COPY n1ilvtgate_org1 
n1ilvtgate = n1ilvtgate_org NOT MAC  //  CORE LP NMOS MLVT device on DNW

//* Define device -- nmos nch_mlvt_mac
nilvtgate_mac = nilvtgate_org AND MAC  //  LP NMOS MLVT device MAC

//* Define device -- nmos nch_mlvt_dnw_mac
n1ilvtgate_mac = n1ilvtgate_org AND MAC  //  CORE LP NMOS MLVT device on DNW MAC

//* Define device -- nmos nchpg_sr
gate_s1 = gate AND SRM 
gatennw_s = gate_s1 NOT nxwell  //  gate not inside nwell
ngate_s1 = gatennw_s AND NP 
ngate_s2 = ngate_s1 NOT OD25 
ngate_s3 = ngate_s2 NOT OD33 
ngate_s4 = ngate_s3 NOT OD18 
ngate_s5 = ngate_s4 NOT VTL_N 
ngate_s611 = ngate_s5 NOT VTUL_N 
ngate_s612 = ngate_s611 NOT UHVT_N 
ngate_s61 = ngate_s612 NOT SRAMTIMER 
ngate_s62 = ngate_s61 NOT SRM14 
ngate_s63 = ngate_s62 NOT SRM12 
ngate_s64 = ngate_s63 NOT SRM13 
ngate_s65 = ngate_s64 NOT SRM17 
ngate_s6 = ngate_s65 NOT SRM16 
ngate_s_org1 = ngate_s6 NOT VTH_N 
#IFDEF CELLIMP
LPSRM10 = COPY SRM10
#ELSE
LPSRM10 = SRM10 NOT (SIZE SRM10 BY 0.005)
#ENDIF
ngate_s_org2 = ngate_s_org1 NOT LPSRM10 
#IFDEF CELLIMP
LPSRM11 = COPY SRM11
#ELSE
LPSRM11 = SRM11 NOT (SIZE SRM11 BY 0.005)
#ENDIF
ngate_s_org = ngate_s_org2 NOT LPSRM11 
ngate_s = ngate_s_org NOT DCO 
ngate_spg = ngate_s AND SRAMPSGT  //  SRAM NMOS passgate

//* Define device -- nmos nchpd_sr
ngate_spd = ngate_s NOT SRAMPSGT  //  SRAM NMOS pulldown

//* Define device -- nmos nchpg_lpgsr
ngate_slpg = ngate_s_org AND DCO 
ngate_spglpg = ngate_slpg AND SRAMPSGT  //  SRAM LPG NMOS passgate

//* Define device -- nmos nchpd_lpgsr
ngate_spdlpg = ngate_slpg NOT SRAMPSGT  //  SRAM LPG NMOS pulldown

//* Define device -- nmos nchpg_hvtsr
ngate_hvs = ngate_s65 AND VTH_N 
ngate_hvspg = ngate_hvs AND SRAMPSGT  //  SRAM High VT NMOS passgate

//* Define device -- nmos nchpd_hvtsr
ngate_hvspd = ngate_hvs NOT SRAMPSGT  //  SRAM High VT NMOS pulldown

//* Define device -- nmos nch_timer
ngate_st = ngate_s612 AND SRAMTIMER 

//* Define device -- nmos nchpg_dpsr
ngate_s71 = ngate_s62 NOT SRM17 
ngate_s7 = ngate_s71 AND SRM12 
ngate_sdp_org = ngate_s7 NOT VTH_N 
ngate_sdp = ngate_sdp_org NOT DCO 
ngate_spgdp = ngate_sdp AND SRAMPSGT  //  SRAM NMOS passgate ( 50,12 )

//* Define device -- nmos nchpd_dpsr
ngate_spddp = ngate_sdp NOT SRAMPSGT  //  SRAM NMOS pulldown ( 50,12 )

//* Define device -- nmos nchpg_lpgdpsr
ngate_sdplpg = ngate_sdp_org AND DCO 
ngate_spglpgdp = ngate_sdplpg AND SRAMPSGT  //  SRAM LPG NMOS passgate ( 50,12 )

//* Define device -- nmos nchpd_lpgdpsr
ngate_spdlpgdp = ngate_sdplpg NOT SRAMPSGT  //  SRAM LPG NMOS pulldown ( 50,12 )

//* Define device -- nmos nchpg_hvtdpsr
ngate_hvsdp = ngate_s7 AND VTH_N 
ngate_hvspgdp = ngate_hvsdp AND SRAMPSGT  //  SRAM High VT NMOS passgate ( 50,12 )

//* Define device -- nmos nchpd_hvtdpsr
ngate_hvspddp = ngate_hvsdp NOT SRAMPSGT  //  SRAM High VT NMOS pulldown ( 50,12 )

//* Define device -- nmos nchpg_dphcsr
ngate_s8 = ngate_s63 AND SRM13 
ngate_sdphc = ngate_s8 NOT VTH_N 
ngate_spgdphc = ngate_sdphc AND SRAMPSGT  //  SRAM NMOS passgate ( 50,13 )

//* Define device -- nmos nchpd_dphcsr
ngate_spddphc = ngate_sdphc NOT SRAMPSGT  //  SRAM NMOS pulldown ( 50,13 )

//* Define device -- nmos nchpg_hvtdphcsr
ngate_hvsdphc = ngate_s8 AND VTH_N 
ngate_hvspgdphc = ngate_hvsdphc AND SRAMPSGT  //  SRAM High VT NMOS passgate ( 50,13 )

//* Define device -- nmos nchpd_hvtdphcsr
ngate_hvspddphc = ngate_hvsdphc NOT SRAMPSGT  //  SRAM High VT NMOS pulldown ( 50,13 )

//* Define device -- nmos nchpg_wosr
ngate_s9 = ngate_s63 AND SRM16 
ngate_swo1 = ngate_s9 NOT VTH_N  //  For N65 G SRAM
ngate_swo2 = ngate_s_org2 AND LPSRM11  //  For N65 LP SRAM
ngate_swo = ngate_swo1 OR ngate_swo2  //  wosr =  (50;16) || (50;11)
ngate_spgwo = ngate_swo AND SRAMPSGT  //  SRAM NMOS passgate ( 50,16 ) of G + ( 50,11 ) of LP

//* Define device -- nmos nchpd_wosr
ngate_spdwo = ngate_swo NOT SRAMPSGT  //  SRAM NMOS pulldown ( 50,16 ) of G + ( 50,11 ) of LP

//* Define device -- nmos nchpg_wisr
ngate_swi1 = ngate_s_org1 NOT LPSRM11 
ngate_swi = ngate_swi1 AND LPSRM10  //  For N65 LP SRAM
ngate_spgwi = ngate_swi AND SRAMPSGT  //  SRAM NMOS passgate ( 50,10 ) of LP

//* Define device -- nmos nchpd_wisr
ngate_spdwi = ngate_swi NOT SRAMPSGT  //  SRAM NMOS pulldown ( 50,10 ) of LP

//* Define device -- nmos nchpg_ulpsr
ngate_s10 = ngate_s62 AND SRM17 
ngate_s11 = ngate_s10 NOT SRM12 
ngate_sulp = ngate_s11 AND VTH_N 
ngate_spgulp = ngate_sulp AND SRAMPSGT  //  SRAM ULP NMOS passgate ( 50,17 ) 

//* Define device -- nmos nchpd_ulpsr
ngate_spdulp = ngate_sulp NOT SRAMPSGT  //  SRAM ULP NMOS pulldown ( 50,17 )

//* Define device -- nmos nchpg_ulpdpsr
ngate_s12 = ngate_s10 AND SRM12 
ngate_sdpulp = ngate_s12 AND VTH_N 
ngate_spgulpdp = ngate_sdpulp AND SRAMPSGT  //  SRAM ULP NMOS passgate ( 50,17 ) ( 50,12 ) 

//* Define device -- nmos nchpd_ulpdpsr
ngate_spdulpdp = ngate_sdpulp NOT SRAMPSGT  //  SRAM ULP NMOS pulldown ( 50,17 ) ( 50,12 )

//* Define device -- nmos nchpg_lpgtpsr
ngate_s13 = ngate_s61 AND SRM14 
ngate_stp_org = ngate_s13 NOT VTH_N 
ngate_stplpg = ngate_stp_org AND DCO 
ngate_spglpgtp = ngate_stplpg AND SRAMPSGT  //  SRAM LPG NMOS passgate ( 50,14 )

//* Define device -- nmos nchpd_lpgtpsr
ngate_spdlpgtp = ngate_stplpg NOT SRAMPSGT  //  SRAM LPG NMOS pulldown ( 50,14 )

//* Define device -- nmos nch_18
ngate_18a = tngate1 AND OD18 
ngate_18b = ngate_18a NOT NT_Ni 
ngate_18c = ngate_18b NOT DNW 
ngate_18_org1 = ngate_18c NOT VTL_N 
ngate_18_org = ngate_18_org1 NOT INTERACT RH 
ngate_18 = ngate_18_org NOT MAC  //  1.8v NMOS

//* Define device -- nmos nch_18_dnw
dngate_18a = ngate_18b AND DNW 
dngate_18_org1 = dngate_18a NOT VTL_N 
dngate_18_org = dngate_18_org1 NOT INTERACT RH 
dngate_18 = dngate_18_org NOT MAC  //  1.8v NMOS on DNW

//* Define device -- nmos nch_18_mac
ngate_18_mac = ngate_18_org AND MAC  //  1.8v NMOS MAC

//* Define device -- nmos nch_18_dnw_mac
dngate_18_mac = dngate_18_org AND MAC  //  1.8v NMOS on DNW MAC

//* Define device -- nmos nch_esd18
ngate_esd18_org1 = ngate_18_org1 INTERACT RH 
ngate_esd18_org = ngate_esd18_org1 INTERACT RPO 
ngate_esd18 = ngate_esd18_org NOT MAC  //  1.8v esd non-LDD NMOS

//* Define device -- nmos nch_esd18_dnw
dngate_esd18_org1 = dngate_18_org1 INTERACT RH 
dngate_esd18_org = dngate_esd18_org1 INTERACT RPO 
dngate_esd18 = dngate_esd18_org NOT MAC  //  1.8v esd non-LDD NMOS on DNW

//* Define device -- nmos nch_esd18_mac
ngate_esd18_mac = ngate_esd18_org AND MAC  //  1.8v esd non-LDD NMOS MAC

//* Define device -- nmos nch_esd18_dnw_mac
dngate_esd18_mac = dngate_esd18_org AND MAC  //  1.8v esd non-LDD NMOS on DNW MAC

//* Define device -- nmos nch_25
ngate_25a = tngate1 AND OD25 
ngate_25b = ngate_25a NOT NT_Ni 
ngate_25c1 = ngate_25b NOT DNW 
ngate_25c2 = ngate_25c1 NOT CELLM  //  exclude CIS MVT NMOS
ngate_25c = ngate_25c2 NOT CAP_IMP  //  exclude CIS npolycap
ngate_25e = ngate_25c NOT INTERACT HVD_NW 
ngate_25_org = ngate_25e NOT VTL_N 
ngate_25ud1 = ngate_25_org AND OD25_18 
ngate_25z = ngate_25_org NOT ngate_25ud1 
ngate_25od1 = ngate_25_org AND OD25_33 
ngate_25y = ngate_25z NOT ngate_25od1 
ngate_25od281 = ngate_25_org AND OD25_28 
ngate_25x = ngate_25y NOT ngate_25od281 
ngate_25 = ngate_25x NOT MAC  //  2.5v NMOS

//* Define device -- nmos nch_25_dnw
dngate_25a = ngate_25b AND DNW 
dngate_25b = dngate_25a NOT CELLM 
dngate_25c = dngate_25b NOT CAP_IMP 
dngate_25_org = dngate_25c NOT VTL_N 
dngate_25ud1 = dngate_25_org AND OD25_18 
dngate_25z = dngate_25_org NOT dngate_25ud1 
dngate_25od1 = dngate_25_org AND OD25_33 
dngate_25y = dngate_25z NOT dngate_25od1 
dngate_25od281 = dngate_25_org AND OD25_28 
dngate_25x = dngate_25y NOT dngate_25od281 
dngate_25 = dngate_25x NOT MAC  //  2.5v NMOS on DNW

//* Define device -- nmos nch_25_mac
ngate_25_mac = ngate_25x AND MAC  //  2.5v NMOS MAC

//* Define device -- nmos nch_25_dnw_mac
dngate_25_mac = dngate_25x AND MAC  //  2.5v NMOS on DNW MAC

//* Define device -- nmos nch_25ud
ngate_25ud = ngate_25ud1 NOT MAC  //  2.5v NMOS under_drive 1.8v

//* Define device -- nmos nch_25_dnwud
dngate_25ud = dngate_25ud1 NOT MAC  //  2.5v NMOS on DNW under_drive 1.8v

//* Define device -- nmos nch_25ud_mac
ngate_25ud_mac = ngate_25ud1 AND MAC  //  2.5v NMOS under_drive 1.8v MAC

//* Define device -- nmos nch_25_dnwud_mac
dngate_25ud_mac = dngate_25ud1 AND MAC  //  2.5v NMOS on DNW under_drive 1.8v MAC

//* Define device -- nmos nch_25od
ngate_25od = ngate_25od1 NOT MAC  //  2.5v NMOS over_drive 3.3v

//* Define device -- nmos nch_25_dnwod
dngate_25od = dngate_25od1 NOT MAC  //  2.5v NMOS on DNW over_drive 3.3v

//* Define device -- nmos nch_25od_mac
ngate_25od_mac = ngate_25od1 AND MAC  //  2.5v NMOS over_drive 3.3v MAC

//* Define device -- nmos nch_25_dnwod_mac
dngate_25od_mac = dngate_25od1 AND MAC  //  2.5v NMOS on DNW over_drive 3.3v MAC

//* Define device -- lddn nch_hv25_snw
ngate_25hvdw_org = ngate_25c INTERACT HVD_NW  //  HVD NMOS NW
ngate_25hvdw = ngate_25hvdw_org NOT MAC  //  HVD NMOS by NW approach

//***** Define connectivity/via layer -- s_nd25hvdw ****
s_nd25hvdw1 = tndiff_ori NOT HVD_NW 
s_nd25hvdw = s_nd25hvdw1 INTERACT ngate_25hvdw_org 

//* Define device -- lddn nch_hv25_snw_mac
ngate_25hvdw_mac = ngate_25hvdw_org AND MAC  //  HVD MACRO NMOS by NW approach

//* Define device -- nmos nch_33
ngate_33a = tngate1 AND OD33 
ngate_33b = ngate_33a NOT NT_Ni 
ngate_33c = ngate_33b NOT DNW 
ngate_33_org = ngate_33c NOT VTL_N 
ngate_33 = ngate_33_org NOT MAC  //  3.3v NMOS

//* Define device -- nmos nch_33_dnw
dngate_33a = ngate_33b AND DNW 
dngate_33_org = dngate_33a NOT VTL_N 
dngate_33 = dngate_33_org NOT MAC  //  3.3v NMOS on DNW

//* Define device -- nmos nch_33_mac
ngate_33_mac = ngate_33_org AND MAC  //  3.3v NMOS MAC

//* Define device -- nmos nch_33_dnw_mac
dngate_33_mac = dngate_33_org AND MAC  //  3.3v NMOS on DNW MAC

//* Define device -- nmos nch_na25
ngate_25na1 = ngate_25a AND NT_Ni 
ngate_25na2 = ngate_25na1 NOT VTL_N 
ngate_25na3 = ngate_25na2 NOT DNW 
ngate_25na_org = ngate_25na3 NOT CAP_IMP  //  exclude cis npolycap
ngate_25naud1 = ngate_25na_org AND OD25_18 
ngate_25naz = ngate_25na_org NOT ngate_25naud1 
ngate_25naod1 = ngate_25na_org AND OD25_33 
ngate_25nay = ngate_25naz NOT ngate_25naod1 
ngate_25na = ngate_25nay NOT MAC  //  2.5v Native NMOS

//* Define device -- nmos nch_na25_mac
ngate_25na_mac = ngate_25nay AND MAC  //  2.5v Native NMOS MAC

//* Define device -- nmos nch_na25ud
ngate_25naud = ngate_25naud1 NOT MAC  //  2.5v Native NMOS under_drive 1.8v

//* Define device -- nmos nch_na25ud_mac
ngate_25naud_mac = ngate_25naud1 AND MAC  //  2.5v Native NMOS under_drive 1.8v MAC

//* Define device -- nmos nch_na25od
ngate_25naod = ngate_25naod1 NOT MAC  //  2.5v Native NMOS over_drive 3.3v

//* Define device -- nmos nch_na25od_mac
ngate_25naod_mac = ngate_25naod1 AND MAC  //  2.5v Native NMOS over_drive 3.3v MAC

//* Define device -- nmos nch_na18
ngate_18na1 = ngate_18a AND NT_Ni 
ngate_18na2 = ngate_18na1 NOT VTL_N 
ngate_18na_org = ngate_18na2 NOT DNW 
ngate_18na = ngate_18na_org NOT MAC  //  1.8v Native NMOS

//* Define device -- nmos nch_na18_mac
ngate_18na_mac = ngate_18na_org AND MAC  //  1.8v Native NMOS MAC

//* Define device -- nmos nch_na33
ngate_33na1 = ngate_33a AND NT_Ni 
ngate_33na2 = ngate_33na1 NOT VTL_N 
ngate_33na_org = ngate_33na2 NOT DNW 
ngate_33na = ngate_33na_org NOT MAC  //  3.3v Native NMOS

//* Define device -- nmos nch_na33_mac
ngate_33na_mac = ngate_33na_org AND MAC  //  3.3v Native NMOS MAC

//* Define device -- nmos nch_25od28
ngate_25od28 = ngate_25od281 NOT MAC  //  2.5v NMOS over_drive 2.8v

//* Define device -- nmos nch_25od28_mac
ngate_25od28_mac = ngate_25od281 AND MAC  //  2.5v NMOS over_drive 2.8v MAC

//* Define device -- nmos nch_25od28_dnw
dngate_25od28 = dngate_25od281 NOT MAC  //  2.5v NMOS on DNW over_drive 2.8v

//* Define device -- nmos nch_25od28_dnw_mac
dngate_25od28_mac = dngate_25od281 AND MAC  //  2.5v NMOS on DNW over_drive 2.8v MAC

//* Define device -- pmos pch_25od28
gatenw = gate_nosr AND nxwell  //  gate inside nwell
tpgate1 = gatenw AND PP 
pgate_25a1 = tpgate1 AND OD25 
pgate_25a = pgate_25a1 NOT MEDP  //  exclude CIS MVT PMOS 
pgate_25b = pgate_25a NOT INTERACT HVD_P 
pgate_25_org = pgate_25b NOT VTL_P 
pagte_25od281 = pgate_25_org AND OD25_28 
pgate_25od28 = pagte_25od281 NOT MAC  //  2.5v PMOS over_drive 2.8v

//***** Define connectivity/via layer -- tpdiff ****
pthin = mdiff AND PP  //  define P+ thin oxide
tpdiffa = pthin NOT gate1  //  define P+ diffusion region
pdiffb = diffb NOT ndiffb 
tpdiff_ori = tpdiffa OR pdiffb 
s_tpdiff1 = tpdiff_ori NOT DRAIN 
s_tpdiff = s_tpdiff1 INTERACT gate_rf 
tpdiff_ori1 = tpdiff_ori NOT s_tpdiff 
d_tpdiff = tpdiff_ori AND DRAIN 
tpdiff = tpdiff_ori1 NOT d_tpdiff 

//* Define device -- pmos pch_25od28_mac
pgate_25od28_mac = pagte_25od281 AND MAC  //  2.5v PMOS over_drive 2.8v

//* Define device -- pmos pch
tpgate2 = tpgate1 NOT OD25 
tpgate3 = tpgate2 NOT OD33 
tpgate4 = tpgate3 NOT OD18 
plvgate_org1 = tpgate4 AND VTL_P 
pgate1 = tpgate4 NOT plvgate_org1 
phvgate1 = tpgate4 AND VTH_P 
phvgate2 = phvgate1 NOT DCO 
pgate2 = pgate1 NOT phvgate2 
tpgate5 = tpgate3 NOT OD1T 
puvgate_org1 = tpgate5 AND VTUL_P 
pgate31 = pgate2 NOT puvgate_org1 
puhvgate_org1 = tpgate4 AND UHVT_P 
pgate3 = pgate31 NOT puhvgate_org1 
pgate4 = pgate3 NOT ILVT 
pgate5 = pgate4 NOT OD1T 
pgate6 = pgate5 NOT DCO 
pgate_org = COPY pgate6 
pgate = pgate_org NOT MAC  //  CORE PMOS

//* Define device -- pmos pch_mac
pgate_mac = pgate_org AND MAC  //  CORE PMOS MAC

//* Define device -- pmos pch_hvt
phvgate_org = COPY phvgate2 
phvgate = phvgate_org NOT MAC  //  CORE HIGH_VT PMOS

//* Define device -- pmos pch_hvt_mac
phvgate_mac = phvgate_org AND MAC  //  CORE HIGH_VT PMOS MAC

//* Define device -- pmos pch_lvt
plvgate_org = COPY plvgate_org1 
plvgate = plvgate_org NOT MAC  //  CORE LOW_VT PMOS

//* Define device -- pmos pch_lvt_mac
plvgate_mac = plvgate_org AND MAC  //  CORE LOW_VT PMOS MAC

//* Define device -- pmos pch_uhvt
puhvgate_org = COPY puhvgate_org1 
puhvgate = puhvgate_org NOT MAC  //  CORE ULTRA High VT PMOS

//* Define device -- pmos pch_uhvt_mac
puhvgate_mac = puhvgate_org AND MAC  //  CORE ULTRA High VT PMOS MAC

//* Define device -- pmos pch_ulvt
puvgate_org = COPY puvgate_org1 
puvgate = puvgate_org NOT MAC  //  CORE ULTRA LOW VT PMOS

//* Define device -- pmos pch_ulvt_mac
puvgate_mac = puvgate_org AND MAC  //  CORE ULTRA LOW VT PMOS MAC

//* Define device -- pmos pch_lpg
pgatelpg1 = pgate5 AND DCO 
pgatelpg = pgatelpg1 NOT VTH_P  //  CORE LPG PMOS

//* Define device -- pmos pch_lpghvt
phvgatelpg = phvgate1 AND DCO  //  CORE HIGH_VT LPG PMOS

//* Define device -- pmos pch_w
pgate_1ta = tpgate4 AND OD1T 
pgate_1tb = pgate_1ta NOT VTL_P 
pgate_1tc = pgate_1tb NOT VTH_P 
pgate_1td = pgate_1tc NOT VTUL_P 
pgate_1te = pgate_1td NOT CAP1TDMY 
pgate_w1t = pgate_1te NOT INTERACT p3  //  eDRAM pch_w   device

//* Define device -- pmos pch_w_lvt
pgate_1tf = pgate_1tc AND VTUL_P 
pgate_1tg = pgate_1tf NOT CAP1TDMY 
pgate_w1t_lvt = pgate_1tg NOT INTERACT p3  //  eDRAM pch_w_lvt device 

//* Define device -- pmos pch_edc
pgate_1tr = pgate_1te INTERACT p3  //  eDRAM pch_edc device

//* Define device -- pmos pchpu_sr
gatenw_s = gate_s1 AND nxwell  //  gate inside nwell
pgate_s1 = gatenw_s AND PP 
pgate_s2 = pgate_s1 NOT OD25 
pgate_s3 = pgate_s2 NOT OD33 
pgate_s4 = pgate_s3 NOT OD18 
pgate_s5 = pgate_s4 NOT VTL_P 
pgate_s611 = pgate_s5 NOT VTUL_P 
pgate_s612 = pgate_s611 NOT UHVT_P 
pgate_s61 = pgate_s612 NOT SRAMTIMER 
pgate_s62 = pgate_s61 NOT SRM14 
pgate_s63 = pgate_s62 NOT SRM12 
pgate_s64 = pgate_s63 NOT SRM13 
pgate_s6 = pgate_s64 NOT SRM17 
pgate_s_org1 = pgate_s6 NOT VTH_P 
pgate_s_org2 = pgate_s_org1 NOT LPSRM10 
pgate_s_org = pgate_s_org2 NOT LPSRM11 
pgate_s = pgate_s_org NOT DCO  //  SRAM PMOS

//* Define device -- pmos pchpu_lpgsr
pgate_slpg = pgate_s_org AND DCO  //  SRAM LPG PMOS

//* Define device -- pmos pchpu_hvtsr
pgate_hvs = pgate_s6 AND VTH_P  //  SRAM High VT PMOS

//* Define device -- pmos pch_timer
pgate_st = pgate_s612 AND SRAMTIMER 

//* Define device -- pmos pchpu_dpsr
pgate_s71 = pgate_s62 NOT SRM17 
pgate_s7 = pgate_s71 AND SRM12 
pgate_sdp_org = pgate_s7 NOT VTH_P 
pgate_sdp = pgate_sdp_org NOT DCO  //  SRAM PMOS( 50,12 )

//* Define device -- pmos pchpu_lpgdpsr
pgate_sdplpg = pgate_sdp_org AND DCO  //  SRAM LPG PMOS( 50,12 )

//* Define device -- pmos pchpu_hvtdpsr
pgate_hvsdp = pgate_s7 AND VTH_P  //  SRAM High VT PMOS( 50,12 )

//* Define device -- pmos pchpu_dphcsr
pgate_s8 = pgate_s63 AND SRM13 
pgate_sdphc = pgate_s8 NOT VTH_P  //  SRAM PMOS( 50,13 )

//* Define device -- pmos pchpu_hvtdphcsr
pgate_hvsdphc = pgate_s8 AND VTH_P  //  SRAM High VT PMOS( 50,13 )

//* Define device -- pmos pchpu_ulpsr
pgate_s10 = pgate_s62 AND SRM17 
pgate_s11 = pgate_s10 NOT SRM12 
pgate_sulp = pgate_s11 AND VTH_P  //  SRAM ULP PMOS( 50,17 )

//* Define device -- pmos pchpu_ulpdpsr
pgate_s12 = pgate_s10 AND SRM12 
pgate_sdpulp = pgate_s12 AND VTH_P  //  SRAM ULP PMOS( 50,17 ) ( 50,12 )  

//* Define device -- pmos pchpu_lpgtpsr
pgate_s13 = pgate_s61 AND SRM14 
pgate_stp_org = pgate_s13 NOT VTH_P 
pgate_stplpg = pgate_stp_org AND DCO  //  SRAM LPG PMOS( 50,14 )

//* Define device -- pmos pchpu_wosr
pgate_swo = pgate_s_org2 AND LPSRM11  //  SRAM PMOS ( 50,11 ) of N65LP

//* Define device -- pmos pchpu_wisr
pgate_swi1 = pgate_s_org1 NOT LPSRM11 
pgate_swi = pgate_swi1 AND LPSRM10  //  SRAM PMOS ( 50,10 ) of N65LP

//* Define device -- pmos pch_mlvt
pilvtgate_org1 = pgate3 AND ILVT 
pilvtgate_org = COPY pilvtgate_org1 
pilvtgate = pilvtgate_org NOT MAC  //  LP PMOS MLVT device

//* Define device -- pmos pch_mlvt_mac
pilvtgate_mac = pilvtgate_org AND MAC  //  LP PMOS MLVT device MAC

//* Define device -- pmos pch_18
pgate_18a = tpgate1 AND OD18 
pgate_18_org = pgate_18a NOT VTL_P 
pgate_18 = pgate_18_org NOT MAC  //  1.8v PMOS

//* Define device -- pmos pch_18_mac
pgate_18_mac = pgate_18_org AND MAC  //  1.8v PMOS MAC

//* Define device -- pmos pch_25
pgate_25ud1 = pgate_25_org AND OD25_18 
pgate_25z = pgate_25_org NOT pgate_25ud1 
pgate_25od1 = pgate_25_org AND OD25_33 
pgate_25y = pgate_25z NOT pgate_25od1 
pgate_25x = pgate_25y NOT pagte_25od281 
pgate_25 = pgate_25x NOT MAC  //  2.5v PMOS

//* Define device -- pmos pch_25_mac
pgate_25_mac = pgate_25x AND MAC  //  2.5v PMOS MAC

//* Define device -- pmos pch_25ud
pgate_25ud = pgate_25ud1 NOT MAC  //  2.5v PMOS under_drive 1.8v

//* Define device -- pmos pch_25ud_mac
pgate_25ud_mac = pgate_25ud1 AND MAC  //  2.5v PMOS under_drive 1.8v MAC

//* Define device -- pmos pch_25od
pgate_25od = pgate_25od1 NOT MAC  //  2.5v PMOS over_drive 3.3v

//* Define device -- pmos pch_25od_mac
pgate_25od_mac = pgate_25od1 AND MAC  //  2.5v PMOS over_drive 3.3v MAC

//* Define device -- lddp pch_hv25_spw
pgate_25hvd_org = pgate_25a INTERACT HVD_P  //  HVD PMOS
pgate_25hvd = pgate_25hvd_org NOT MAC 

//***** Define connectivity/via layer -- s_pd25hvd ****
s_pd25hvd1 = tpdiff_ori NOT HVD_P 
s_pd25hvd = s_pd25hvd1 INTERACT pgate_25hvd_org 

//* Define device -- lddp pch_hv25_spw_mac
pgate_25hvd_mac = pgate_25hvd_org AND MAC 

//* Define device -- pmos pch_33
pgate_33a = tpgate1 AND OD33 
pgate_33_org = pgate_33a NOT VTL_P 
pgate_33 = pgate_33_org NOT MAC  //  3.3v PMOS

//* Define device -- pmos pch_33_mac
pgate_33_mac = pgate_33_org AND MAC  //  3.3v PMOS MAC

//* Define device -- diode pdio
pdio1a = tpdiff AND DIODMY 
pdio1 = pdio1a NOT HIADMY 
pdio2 = pdio1 AND nxwell 
pdio3 = pdio2 NOT OD25 
pdio4 = pdio3 NOT OD33 
pdio5 = pdio4 NOT OD18 
pdio8 = pdio5 NOT VTL_P 
pdio9 = pdio8 NOT UHVT_P 
cpdio1 = pdio9 NOT VTH_P 
cpdio2 = cpdio1 NOT VTL_P 
cpdio3 = cpdio2 NOT ILVT 
cpdio4 = cpdio3 NOT DCO 
cpdio = cpdio4 NOT OD1T  //  CORE P+/NW DIODE

//* Define device -- diode pdio_lpg
cpdio5 = cpdio3 AND DCO 
cpdiolpg = cpdio5 NOT OD1T  //  CORE P+/NW LPG DIODE

//* Define device -- diode ndio
ndio1a = tndiff AND DIODMY 
ndio1 = ndio1a NOT HIADMY 
ndio2 = ndio1 AND psub 
ndio3 = ndio2 NOT OD25 
ndio4 = ndio3 NOT OD33 
ndio5 = ndio4 NOT OD18 
ndio6 = ndio5 NOT NT_Ni 
ndio9 = ndio6 NOT VTL_N 
ndio10 = ndio9 NOT UHVT_N 
cndio1 = ndio10 NOT VTH_N 
cndio2 = cndio1 NOT VTL_N 
cndio3 = cndio2 NOT ILVT 
cndio4 = cndio3 NOT DCO 
cndio = cndio4 NOT OD1T  //  CORE N+/PW DIODE

//* Define device -- diode ndio_lpg
cndio5 = cndio3 AND DCO 
cndiolpg = cndio5 NOT OD1T  //  CORE N+/PW LPG DIODW

//* Define device -- diode pdio_w
epdio = cpdio4 AND OD1T  //  eDRAM P+/NW DIODE

//* Define device -- diode ndio_w
endio = cndio4 AND OD1T  //  eDRAM N+/PW DIODE

//* Define device -- diode nwdio
DIONW = DIODMY OUTSIDE tpdiff 
nwdio1 = nxwell AND DIONW 
cnwdio1 = nwdio1 NOT OD25 
cnwdio2 = cnwdio1 NOT OD33 
cnwdio = cnwdio2 NOT OD18  //  CORE NW/PW diode

//* Define device -- diode pdio_hvt
pdio6 = pdio5 NOT DCO 
pdioh = pdio6 AND VTH_P  //  CORE P+/NW HIGH_VT DIODE

//* Define device -- diode pdio_lpghvt
pdio7 = pdio5 AND DCO 
pdiohlpg = pdio7 AND VTH_P  //  CORE P+/NW HIGH_VT LPG DIODE

//* Define device -- diode ndio_hvt
ndio7 = ndio6 NOT DCO 
ndioh = ndio7 AND VTH_N  //  CORE N+/PW HIGH_VT DIODE

//* Define device -- diode ndio_lpghvt
ndio8 = ndio6 AND DCO  //  CORE N+/PW HIGH_VT LPG DIODE
ndiohlpg = ndio8 AND VTH_N  //  CORE N+/PW HIGH_VT LPG DIODE

//* Define device -- diode ndio_lvt
ndiol = ndio6 AND VTL_N  //  CORE N+/PW LOW_VT DIODE

//* Define device -- diode pdio_mlvt
pdioilvt = cpdio2 AND ILVT  //  LP PDIO MLVD DIODE

//* Define device -- diode ndio_mlvt
cndioilvt = cndio2 AND ILVT  //  CORE LP N+/PW MLVT DIODE

//* Define device -- diode pdio_lvt
pdiol = pdio5 AND VTL_P  //  CORE P+/NW LOW_VT DIODE

//* Define device -- diode pdio_uhvt
pdiouh = pdio8 AND UHVT_P 

//* Define device -- diode ndio_uhvt
ndiouh = ndio9 AND UHVT_N 

//* Define device -- diode pdio_18
ipdio_18 = pdio2 AND OD18  //  1.8v P+/NW DIODE

//* Define device -- diode ndio_18
ndio_18a = ndio2 AND OD18 
indio_18 = ndio_18a NOT NT_Ni  //  1.8v N+/PW diode

//* Define device -- diode pdio_25
ipdio_25_org1 = pdio2 AND OD25 
ipdio_25_org2 = ipdio_25_org1 NOT MEDP  //  exclude cis mvt pdio
ipdio_25_org = ipdio_25_org2 NOT INTERACT HVD_P 
ipdio_25z = ipdio_25_org NOT OD25_18 
ipdio_25y = ipdio_25z NOT OD25_33 
ipdio_25 = ipdio_25y NOT OD25_28  //  2.5v P+/NW DIODE

//* Define device -- diode ndio_25
ndio_25a1 = ndio2 AND OD25 
ndio_25a = ndio_25a1 NOT CELLM  //  exclude cis mvt ndio
ndio_25c = ndio_25a NOT INTERACT HVD_NW 
indio_25_org = ndio_25c NOT NT_Ni  //  2.5v N+/PW diode
indio_25z = indio_25_org NOT OD25_18 
indio_25y = indio_25z NOT OD25_33 
indio_25 = indio_25y NOT OD25_28  //  2.5v N+/PW DIODE

//* Define device -- diode pdio_25ud
ipdio_25ud = ipdio_25_org AND OD25_18  //  2.5v P+/NW DIODE under_drive 1.8v

//* Define device -- diode ndio_25ud
indio_25ud = indio_25_org AND OD25_18  //  2.5v N+/PW DIODE under_drive 1.8v

//* Define device -- diode pdio_25od
ipdio_25od = ipdio_25_org AND OD25_33  //  2.5v P+/NW DIODE under_drive 3.3v

//* Define device -- diode ndio_25od
indio_25od = indio_25_org AND OD25_33  //  2.5v N+/PW DIODE onder_drive 3.3v

//* Define device -- diode pdio_25od28
ipdio_25od28 = ipdio_25_org AND OD25_28  //  2.5v P+/NW DIODE under_drive 2.8v

//* Define device -- diode ndio_25od28
indio_25od28 = indio_25_org AND OD25_28  //  2.5v N+/PW DIODE onder_drive 2.8v

//* Define device -- diode pdio_33
ipdio_33 = pdio2 AND OD33  //  3.3v P+/NW DIODE

//* Define device -- diode ndio_33
ndio_33a = ndio2 AND OD33 
indio_33 = ndio_33a NOT NT_Ni  //  3.3v N+/PW diode

//* Define device -- diode nwdio_33
inwdio_33 = nwdio1 AND OD33  //  3.3v NW/PW diode

//* Define device -- diode nwdio_25
inwdio_25 = nwdio1 AND OD25  //  2.5v NW/PW diode

//* Define device -- diode nwdio_18
inwdio_18 = nwdio1 AND OD18  //  1.8v NW/PW diode

//* Define device -- diode ndio_na
nndio1 = ndio5 AND NT_Ni 
cndion1 = nndio1 NOT VTH_N 
cndion2 = cndion1 NOT UHVT_N 
cndion3 = cndion2 NOT DCO 
cndion = cndion3 NOT VTL_N 

//* Define device -- diode ndio_lpgna
cndion4 = cndion2 AND DCO 
cndionlpg = cndion4 NOT VTL_N  //  CORE N+/PW Native LPG DIODE

//* Define device -- diode ndio_na18
ndio_18na = ndio_18a AND NT_Ni  //  1.8v N+/PW native diode

//* Define device -- diode ndio_na25
ndio_25na_org = ndio_25c AND NT_Ni 
ndio_25naz = ndio_25na_org NOT OD25_18 
ndio_25na = ndio_25naz NOT OD25_33  //  2.5v N+/PW native diode

//* Define device -- diode ndio_na25ud
ndio_25naud = ndio_25na_org AND OD25_18  //  2.5v N+/PW native diode under_drive 1.8v

//* Define device -- diode ndio_na25od
ndio_25naod = ndio_25na_org AND OD25_33  //  2.5v N+/PW native diode over_drive 3.3v

//* Define device -- diode ndio_na33
ndio_33na = ndio_33a AND NT_Ni  //  3.3v N+/PW native diode

//***** Define connectivity/via layer -- ydio_hole ****
ydio_hole = HOLES ydio 

//* Define device -- bjt pnp10
ttdiff = tpdiff AND BJTDMY 
nbase1k = nxwell NOT INTERACT DNW 
nbase1 = nbase1k AND BJTDMY 
cnbase1 = nbase1 NOT OD25  //  define CORE BJT[PV] base terminal
cemit1a = ttdiff AND cnbase1  //  define CORE BJT[PV] emitter
cemit1 = cemit1a INTERACT RPO  //  emitter need to interact RPO ring
cemit10_org = AREA cemit1  > 99.999  < 100.001 
cemit10_orgi = cemit10_org NOT BJTDMY1 
cemit10 = cemit10_orgi NOT MAC 

//***** Define connectivity/via layer -- coll1 ****
collsur = psub TOUCH nbase1 
coll1a = collsur OR nbase1  //  define both BJTs collector
npnrg = DNW AND BJTDMY  //  define NPN region
nndiff = tndiff AND npnrg 
pbase1 = psub AND npnrg 
cpbase1 = pbase1 NOT OD25  //  define CORE BJT[NV] base terminal
cnemit1a = nndiff AND cpbase1  //  define CORE BJT[NV] emitter
cnemit1 = cnemit1a INTERACT RPO  //  emitter need to interact RPO ring
collsura = collsur TOUCH cnemit1 
inbase1 = nbase1 AND OD25  //  define I/O  BJT[P1] base terminal
inemit1 = nndiff AND inbase1  //  define I/O  BJT[N1] emitter
collsurb = collsur TOUCH inemit1 
collsurall = collsura OR collsurb 
coll1b = coll1a NOT collsurall 
coll1 = coll1b NOT cemit1  //   define pnp collector

//* Define device -- bjt pnp5
cemit5_org = AREA cemit1  > 24.999  < 25.001 
cemit5_orgi = cemit5_org NOT BJTDMY1 
cemit5 = cemit5_orgi NOT MAC 

//* Define device -- bjt pnp2
cemit2_org = AREA cemit1  > 3.999  < 4.001 
cemit2_orgi = cemit2_org NOT BJTDMY1 
cemit2 = cemit2_orgi NOT MAC 

//* Define device -- bjt npn10
cnemit10_org = AREA cnemit1  > 99.999  < 100.001 
cnemit10_orgi = cnemit10_org NOT BJTDMY1 
cnemit10 = cnemit10_orgi NOT MAC 

//***** Define connectivity/via layer -- ncoll1 ****
ncollrg = nxwell AND npnrg 
ncolls = ncollrg TOUCH pbase1 
ncoll1 = ncolls OR pbase1  //  define both BJTs collector

//* Define device -- bjt npn5
cnemit5_org = AREA cnemit1  > 24.999  < 25.001 
cnemit5_orgi = cnemit5_org NOT BJTDMY1 
cnemit5 = cnemit5_orgi NOT MAC 

//* Define device -- bjt npn2
cnemit2_org = AREA cnemit1  > 3.999  < 4.001 
cnemit2_orgi = cnemit2_org NOT BJTDMY1 
cnemit2 = cnemit2_orgi NOT MAC 

//* Define device -- bjt pnp10_s
cemit10_orgs = cemit10_org AND BJTDMY1 
cemit10s = cemit10_orgs NOT MAC 

//* Define device -- bjt pnp5_s
cemit5_orgs = cemit5_org AND BJTDMY1 
cemit5s = cemit5_orgs NOT MAC 

//* Define device -- bjt pnp2_s
cemit2_orgs = cemit2_org AND BJTDMY1 
cemit2s = cemit2_orgs NOT MAC 

//* Define device -- bjt npn10_s
cnemit10_orgs = cnemit10_org AND BJTDMY1 
cnemit10s = cnemit10_orgs NOT MAC 

//* Define device -- bjt npn5_s
cnemit5_orgs = cnemit5_org AND BJTDMY1 
cnemit5s = cnemit5_orgs NOT MAC 

//* Define device -- bjt npn2_s
cnemit2_orgs = cnemit2_org AND BJTDMY1 
cnemit2s = cnemit2_orgs NOT MAC 

//* Define device -- bjt pnp10_mis
cemit10_mac = cemit10_orgi AND MAC 

//* Define device -- bjt pnp5_mis
cemit5_mac = cemit5_orgi AND MAC 

//* Define device -- bjt pnp2_mis
cemit2_mac = cemit2_orgi AND MAC 

//* Define device -- bjt npn10_mis
cnemit10_mac = cnemit10_orgi AND MAC 

//* Define device -- bjt npn5_mis
cnemit5_mac = cnemit5_orgi AND MAC 

//* Define device -- bjt npn2_mis
cnemit2_mac = cnemit2_orgi AND MAC 

//* Define device -- bjt pnp10_s_mis
cemit10s_mac = cemit10_orgs AND MAC 

//* Define device -- bjt pnp5_s_mis
cemit5s_mac = cemit5_orgs AND MAC 

//* Define device -- bjt pnp2_s_mis
cemit2s_mac = cemit2_orgs AND MAC 

//* Define device -- bjt npn10_s_mis
cnemit10s_mac = cnemit10_orgs AND MAC 

//* Define device -- bjt npn5_s_mis
cnemit5s_mac = cnemit5_orgs AND MAC 

//* Define device -- bjt npn2_s_mis
cnemit2s_mac = cnemit2_orgs AND MAC 

//* Define device -- c CM
mim_r1 = crown AND p3 
mim_r2 = mim_r1 AND OD 
mim_r3 = mim_r2 NOT INTERACT RPO 
mim_r = mim_r3 INTERACT blc 

//* Define device -- c CM_decap
mim_r4 = crown AND p3 
PO = POI OR DPO 
mim_r5 = mim_r4 AND PO 
mim_r6 = mim_r5 AND EDRAM_DECAP 
mim_r7 = mim_r6 INTERACT NP 
mim_r_decap = mim_r7 INTERACT blc 

//* Define device -- xdev nmoscap
vargt1 = gatenw AND NP 
VAR_noRF = VAR NOT INTERACT RFDMY 
vargt2 = vargt1 AND VAR_noRF 
vargt3 = vargt2 NOT OD18 
vargt4 = vargt3 NOT OD25 
vargt5 = vargt4 NOT DCO 
vargt7 = vargt5 NOT OD33 
vargt = vargt7 NOT OD1T  //  Varactor on thin oxide

//* Define device -- xdev nmoscap_lpg
vargt6 = vargt4 AND DCO 
vargtlpg = vargt6 NOT OD33  //  LPG Varactor on thin oxide

//* Define device -- xdev nmoscap_25
vargt_25 = vargt2 AND OD25  //  Varactor on 2.5v thick oxide

//* Define device -- xdev nmoscap_18
vargt_18 = vargt2 AND OD18  //  Varactor on 1.8v thick oxide

//* Define device -- xdev nmoscap_33
vargt_33 = vargt2 AND OD33  //  Varactor on 3.3v thick oxide

//* Define device -- xdev rnwsti
trwell = NWDMY AND NW  //  N-well resistor layer
drpo = diff AND RPO 
nwsti_r1 = trwell NOT drpo  //  NWDMY*NW-RPO-diff --> nwsti
nwsti_r = nwsti_r1 INTERACT NWDMYi  //  NWDMY*NW --> nwsti

//* Define device -- xdev rnwod
nwod_r1 = trwell AND drpo 
nwod_r = nwod_r1 INTERACT NWDMYi  //  NWDMY*NW*RPO*diff --> nwod (2-Terminals)

//* Define device -- xdev rppolywo
rppolywo_r1 = rpolywo AND PP  //  P+POLY resistor w/o silicide
RPDMYi_noRF = RPDMYi NOT INTERACT RFDMY 
rppolywo_r = rppolywo_r1 INTERACT RPDMYi_noRF  //   P+POLY resistor w/o silicide (2-Terminals)

//* Define device -- xdev rnpolywo
rnpolywo_r1 = rpolywo AND NP  //  N+POLY resistor w/o silicide
rnpolywo_r = rnpolywo_r1 INTERACT RPDMYi_noRF  //   N+POLY resistor w/o silicide (2-Terminals)

//* Define device -- xdev rpodwo
rpodwo_r11 = rodwo AND PP 
rpodwo_r1 = rpodwo_r11 AND NW 
rpodwo_r = rpodwo_r1 INTERACT RPDMYi  //  P+OD resistor w/o silicide (2-Terminals)

//* Define device -- xdev rnodwo
rnodwo_r11 = rodwo AND NP 
rnodwo_r1 = rnodwo_r11 NOT NW 
rnodwo_r = rnodwo_r1 INTERACT RPDMYi  //  N+OD resistor w/o silicide (2-Terminals)

//* Define device -- xdev rppolyl
rppoly = rpoly AND PP  //  ALL P+POLY resistor w/i silicide
rppoly_edge = rppoly INSIDE EDGE POI 
l_rppoly_eg = LENGTH rppoly_edge  >= 2  < 99999999 
l_rppoly = rppoly WITH EDGE l_rppoly_eg 
rppolyl_r = l_rppoly INTERACT RPDMYi_noRF  //  P+POLY resistor w/i silicide >=  2 (2-Terminals)

//* Define device -- xdev rnpolyl
rnpoly = rpoly AND NP  //  ALL N+POLY resistor w/i silicide
rnpoly_edge = rnpoly INSIDE EDGE POI 
l_rnpoly_eg = LENGTH rnpoly_edge  >= 2  < 99999999 
l_rnpoly = rnpoly WITH EDGE l_rnpoly_eg 
rnpolyl_r = l_rnpoly INTERACT RPDMYi  //  N+POLY resistor w/i silicide >=  2 (2-Terminals)

//* Define device -- xdev rpodl
rpod1 = rod AND PP  //  P+OD resistor w/i silicide
rpod = rpod1 AND NW  //  P+OD resistor w/i silicide
rpod_edge = rpod INSIDE EDGE diff 
l_rpod = LENGTH rpod_edge  >= 2  < 99999999 
rpodl_r1 = rpod WITH EDGE l_rpod 
rpodl_r = rpodl_r1 INTERACT RPDMYi  //  P+OD resistor w/i silicide >= 2 (2-Terminals)

//* Define device -- xdev rnodl
rnod1 = rod AND NP  //  ALL N+OD resistor w/i silicide
rnod = rnod1 NOT NW  //  ALL N+OD resistor w/i silicide
rnod_edge = rnod INSIDE EDGE diff 
l_rnod = LENGTH rnod_edge  >= 2  < 99999999 
rnodl_r1 = rnod WITH EDGE l_rnod 
rnodl_r = rnodl_r1 INTERACT RPDMYi  //  N+OD resistor w/i silicide >= 2  (2-Terminals)

//* Define device -- xdev rppolys
s_rppoly = rppoly NOT l_rppoly 
rppolys_r = s_rppoly INTERACT RPDMYi_noRF  //  P+POLY resistor w/i silicide < 2 (2-Terminals)

//* Define device -- xdev rnpolys
s_rnpoly = rnpoly NOT l_rnpoly 
rnpolys_r = s_rnpoly INTERACT RPDMYi  //  N+POLY resistor w/i silicide < 2 (2-Terminals)

//* Define device -- xdev rpods
rpods_r1 = rpod NOT rpodl_r1 
rpods_r = rpods_r1 INTERACT RPDMYi  //  P+OD resistor w/i silicide < 2 (2-Terminals)

//* Define device -- xdev rnods
rnods_r1 = rnod NOT rnodl_r1 
rnods_r = rnods_r1 INTERACT RPDMYi  //  N+OD resistor w/i silicide < 2  (2-Terminals)

//* Define device -- xdev rm1
M1X = M1 OR CO 
M1Y = M1X OR DUM1 
mt1res1 = M1Y AND RMDMY1 
mt1res = mt1res1 INTERACT M1  //  metal1 resistor

//***** Define connectivity/via layer -- metal1 ****
metal1 = M1Y NOT mt1res  //  metal1 interconnect

//* Define device -- xdev rm2
M2X = M2 OR DUM2 
inddmy1 = IND_STD OR IND_SYM 
inddmy2 = inddmy1 OR IND_CT 
inddmy3 = inddmy2 OR IND_STD_MUA 
inddmy4 = inddmy3 OR IND_SYM_MUA 
inddmy5 = inddmy4 OR IND_CT_MUA 
IND_meander = IND_NR AND RBCDMY  //  Meander ind use (144;32) to be inddmy layer for RBC
INDDMY = inddmy5 OR IND_meander 
M2Y = M2X NOT INDDMY 
mt2res1 = M2Y AND RMDMY2 
mt2res = mt2res1 INTERACT M2  //  metal2 resistor

//***** Define connectivity/via layer -- metal2 ****
metal2 = M2Y NOT mt2res  //  metal2 interconnect

//* Define device -- xdev rm3
M3X = M3 OR DUM3 
M3Y = M3X NOT INDDMY 
mt3res1 = M3Y AND RMDMY3 
mt3res = mt3res1 INTERACT M3  //  metal3 resistor

//***** Define connectivity/via layer -- metal3 ****
metal3 = M3Y NOT mt3res  //  metal3 interconnect

//* Define device -- xdev rm4
M4X = M4 OR DUM4 
M4Y = M4X NOT INDDMY 
mt4res1 = M4Y AND RMDMY4 
mt4res = mt4res1 INTERACT M4  //  metal4 resistor

//***** Define connectivity/via layer -- metal4 ****
metal4 = M4Y NOT mt4res  //  metal4 interconnect

//* Define device -- xdev rm5
M5X = M5 OR DUM5 
M5Y = M5X NOT INDDMY 
mt5res1 = M5Y AND RMDMY5 
mt5res = mt5res1 INTERACT M5  //  metal5 resistor

//***** Define connectivity/via layer -- metal5 ****
metal5 = M5Y NOT mt5res  //  metal5 interconnect

//* Define device -- xdev rm6
M6X = M6 OR DUM6 
M6Y = M6X NOT INDDMY 
mt6res1 = M6Y AND RMDMY6 
mt6res = mt6res1 INTERACT M6  //  metal6 resistor

//***** Define connectivity/via layer -- metal6 ****
metal6 = M6Y NOT mt6res  //  metal6 interconnect

//* Define device -- xdev rm7
M7X = M7 OR DUM7 
M7Y = M7X NOT INDDMY 
mt7res1 = M7Y AND RMDMY7 
mt7res = mt7res1 INTERACT M7  //  metal7 resistor

//***** Define connectivity/via layer -- metal7 ****
metal7 = M7Y NOT mt7res  //  metal7 interconnect

//* Define device -- xdev rm8
M8X = M8 OR DUM8 
M8Y = M8X NOT INDDMY 
mt8res1 = M8Y AND RMDMY8 
mt8res = mt8res1 INTERACT M8  //  metal8 resistor

//***** Define connectivity/via layer -- metal8 ****
metal8 = M8Y NOT mt8res  //  metal8 interconnect

//* Define device -- xdev rm9
M9X = M9 OR DUM9 
M9Y = M9X NOT INDDMY 
mt9res1 = M9Y AND RMDMY9 
mt9res = mt9res1 INTERACT M9  //  metal9 resistor

//***** Define connectivity/via layer -- metal9 ****
metal9 = M9Y NOT mt9res  //  metal9 interconnect

//* Define device -- xdev rm10
APX = AP OR DAP 
M10Y = APX NOT INDDMY 
mtAPres1 = M10Y AND RMDMYAP 
mtAPres = mtAPres1 INTERACT AP  //  metalAP resistor

//***** Define connectivity/via layer -- metal10 ****
metal10 = M10Y NOT mtAPres  //  metalAP interconnect

//* Define device -- xdev rnwsti_m
nwsti_mr = nwsti_r1 INTERACT NWDMY1  //  NWDMY*NW --> nwsti (3-Terminals)

//* Define device -- xdev rnwod_m
nwod_mr = nwod_r1 INTERACT NWDMY1  //  NWDMY*NW*RPO*diff --> nwod (3-Terminals)

//* Define device -- xdev rppolywo_m
RPDMY1_noRF = RPDMY1 NOT INTERACT RFDMY 
rppolywo_d = rppolywo_r1 INTERACT RPDMY1_noRF  //   P+POLY resistor w/o silicide (3-Terminals)

//***** Define connectivity/via layer -- poly_term ****
poly_term1 = POI AND RPDMY1 
poly_term2 = SIZE poly_term1 BY 0.005 
poly_term = poly_term2 NOT poly_term1 

//* Define device -- xdev rnpolywo_m
rnpolywo_d = rnpolywo_r1 INTERACT RPDMY1_noRF  //   N+POLY resistor w/o silicide (3-Terminals)

//* Define device -- xdev rppolyl_m
rppolyl_d1 = l_rppoly NOT rppolyl_r 
rppolyl_d = rppolyl_d1 INTERACT RPDMY1_noRF  //  P+POLY resistor w/i silicide >=  2 (3-Terminals)

//* Define device -- xdev rnpolyl_m
rnpolyl_d1 = l_rnpoly NOT rnpolyl_r 
rnpolyl_d = rnpolyl_d1 INTERACT RPDMY1  //  N+POLY resistor w/i silicide >=  2 (3-Terminals)

//* Define device -- xdev rppolys_m
rppolys_d1 = s_rppoly NOT rppolys_r 
rppolys_d = rppolys_d1 INTERACT RPDMY1_noRF  //  P+POLY resistor w/i silicide < 2 (3-Terminals)

//* Define device -- xdev rnpolys_m
rnpolys_d1 = s_rnpoly NOT rnpolys_r 
rnpolys_d = rnpolys_d1 INTERACT RPDMY1  //  N+POLY resistor w/i silicide < 2 (3-Terminals)

//* Define device -- xdev rpodwo_m
rpodwo_mr = rpodwo_r1 INTERACT RPDMY1  //  P+OD resistor w/o silicide (3-Terminals)

//* Define device -- xdev rnodwo_m
rnodwo_mr = rnodwo_r1 INTERACT RPDMY1  //  N+OD resistor w/o silicide (3-Terminals)

//* Define device -- xdev rpodl_m
rpodl_mr = rpodl_r1 INTERACT RPDMY1  //  P+OD resistor w/i silicide >= 2 (3-Terminals)

//* Define device -- xdev rnodl_m
rnodl_mr = rnodl_r1 INTERACT RPDMY1  //  N+OD resistor w/i silicide >= 2  (3-Terminals)

//* Define device -- xdev rpods_m
rpods_mr = rpods_r1 INTERACT RPDMY1  //  P+OD resistor w/i silicide < 2 (3-Terminals)

//* Define device -- xdev rnods_m
rnods_mr = rnods_r1 INTERACT RPDMY1  //  N+OD resistor w/i silicide < 2  (3-Terminals)

//* Define device -- xdev dnwpsub
dnwdio_b = nxwell INTERACT DNW 
dnwdio_a = nxwell INSIDE DNW 
dnwdio_k = dnwdio_b NOT dnwdio_a 
dnwdio1 = DNW INTERACT dnwdio_k 
rfdmy56 = RFDMY5T OR RFDMY6T 
dnwdio = dnwdio1 NOT rfdmy56 

//***** Define connectivity/via layer -- psub_term ****
psub_term_a = psub2s NOT PSUB2 
psub_term_b = BULK NOT psub_term_a 
psub_term_c = BULK AND DNW 
psub_term_d = BULK NOT psub_term_c 
psub_term_e = psub_term_b AND psub_term_d 
psub_term = psub_term_e INTERACT DNW 

//* Define device -- xdev pwdnw
rwdio1 = DNW NOT nxwell 
rwdio2 = rwdio1 NOT INTERACT BJTDMY 
rwdio = rwdio2 NOT rfdmy56 

//* Define device -- xdev pnwdio
pnwdio1 = nxwell OUTSIDE cnwdio  //  exclude nwdio device 
pnwdio2a = pnwdio1 NOT DNW 
pnwdio2b = pnwdio2a NOT cnbase1  //  exclude PNP
pnwdio2c = pnwdio2b NOT INTERACT NWDMY1  //  exclude 3T NWRES
pnwdio2d = pnwdio2c NOT INTERACT HIADMY  //  exclude HIA pdio
pnwdio2e = pnwdio2d NOT VAR  //  exclude xjvar_nw and moscap_nw
pnwdio2 = pnwdio2e NOT SBDDMY  //  exclude schottky diode
rwel = psub INSIDE DNW 
pnwdio3 = pnwdio1 INSIDE rwel 
pnwdio4 = pnwdio2 OR pnwdio3 
pnwdio_r = pnwdio4 TOUCH psub == 1 //   parasitic nwdio

//* Define device -- xdev nmos_rf_mlvt
gate_rfnnw = gate_rf NOT nxwell  //  gate_rf not inside nwell
ngate_rf1 = gate_rfnnw AND NP 
ngate_rf2 = ngate_rf1 NOT NT_Ni 
OD_thk = OD25 OR OD18 
OD2 = OD_thk OR OD33 
ngate_rf3 = ngate_rf2 NOT OD2 
ngate_rfmlv = ngate_rf3 AND ILVT  //  CORE RF MLVT nmos
ngate_nthin_mlv1 = nthin INTERACT ngate_rfmlv 
ngate_nthin_mlv2 = ngate_nthin_mlv1 INSIDE DNW 
ngate_nthin_mlv = ngate_nthin_mlv2 NOT RFDMY6T  //  nmos_rf_mlvt

//* Define device -- xdev nmos_rf_mlvt_nodnw
ngate_nthin_mlvnodnw = ngate_nthin_mlv1 OUTSIDE DNW  //  nmos_rf_mlvt_nodnw

//* Define device -- xdev pmos_rf_mlvt
gate_rfnw = gate_rf AND nxwell  //  gate_rf inside nwell
pgate_rf1 = gate_rfnw AND PP 
pgate_rf2 = pgate_rf1 NOT NT_Ni 
pgate_rf3 = pgate_rf2 NOT OD2 
pgate_rfmlv = pgate_rf3 AND ILVT  //  CORE RF MLVT pmos gate
pgate_pthin_mlv1 = pthin INTERACT pgate_rfmlv 
pgate_pthin_mlv2 = pgate_pthin_mlv1 INSIDE DNW 
pgate_pthin_mlv = pgate_pthin_mlv2 NOT RFDMY5T  //  pmos_rf_mlvt

//* Define device -- xdev pmos_rf_mlvt_nw
pgate_pthin_mlvnw1 = pgate_pthin_mlv1 OUTSIDE DNW 
pgate_pthin_mlvnw = pgate_pthin_mlvnw1 NOT RFDMY5T  //  pmos_rf_mlvt_nw

//* Define device -- xdev nmos_rf_mlvt_6t
ngate_nthin_mlv_6t = ngate_nthin_mlv2 AND RFDMY6T  //  nmos_rf_mlvt_6t

//* Define device -- xdev pmos_rf_mlvt_5t
pgate_pthin_mlv_5t = pgate_pthin_mlv2 AND RFDMY5T  //  pmos_rf_mlvt_5t

//* Define device -- xdev pmos_rf_mlvt_nw_5t
pgate_pthin_mlvnw_5t = pgate_pthin_mlvnw1 AND RFDMY5T  //  pmos_rf_mlvt_nw_5t

//* Define device -- xdev nmos_rf
ngate_rfa = ngate_rf3 NOT VTH_N 
ngate_rfb = ngate_rfa NOT VTL_N 
ngate_rf = ngate_rfb NOT ILVT  //  CORE RF nmos
ngate_nthin1 = nthin INTERACT ngate_rf 
ngate_nthin2 = ngate_nthin1 INSIDE DNW 
ngate_nthin3 = ngate_nthin2 NOT RDKDMY 
ngate_nthin = ngate_nthin3 NOT RFDMY6T  //  nmos_rf

//* Define device -- xdev nmos_rf_rdk
ngate_nthin_rdk1 = ngate_nthin2 AND RDKDMY 
ngate_nthin_rdk = ngate_nthin_rdk1 NOT RFDMY6T  //  nmos_rf_rdk

//* Define device -- xdev nmos_rf_nodnw
ngate_nthin_nodnw1 = ngate_nthin1 OUTSIDE DNW 
ngate_nthin_nodnw = ngate_nthin_nodnw1 NOT RDKDMY  //  nmos_rf_nodnw

//* Define device -- xdev nmos_rf_hvt
ngate_rfhv = ngate_rf3 AND VTH_N  //  CORE RF HVT nmos
ngate_nthin_hv1 = nthin INTERACT ngate_rfhv 
ngate_nthin_hv2 = ngate_nthin_hv1 INSIDE DNW 
ngate_nthin_hv = ngate_nthin_hv2 NOT RFDMY6T  //  nmos_rf_hvt

//* Define device -- xdev nmos_rf_hvt_nodnw
ngate_nthin_hvnodnw = ngate_nthin_hv1 OUTSIDE DNW  //  nmos_rf_hvt_nodnw

//* Define device -- xdev nmos_rf_lvt
ngate_rflv = ngate_rf3 AND VTL_N  //  CORE RF LVT nmos
ngate_nthin_lv1 = nthin INTERACT ngate_rflv 
ngate_nthin_lv2 = ngate_nthin_lv1 INSIDE DNW 
ngate_nthin_lv = ngate_nthin_lv2 NOT RFDMY6T  //  nmos_rf_lvt

//* Define device -- xdev nmos_rf_lvt_nodnw
ngate_nthin_lvnodnw = ngate_nthin_lv1 OUTSIDE DNW  //  nmos_rf_lvt_nodnw

//* Define device -- xdev nmos_rf_25
ngate_rfio1 = ngate_rf2 AND OD2 
ngate_rfio2 = ngate_rfio1 NOT VTH_N 
ngate_rfio3 = ngate_rfio2 NOT VTL_N 
ngate_rf_25a = ngate_rfio3 AND OD25 
ngate_rf_25b = ngate_rf_25a NOT OD25_33 
ngate_rf_25c = ngate_rf_25b NOT OD25_18 
ngate_rf_25d = ngate_rf_25c NOT OD25_28 
ngate_rf_25 = ngate_rf_25d NOT INTERACT HVD_NW 
ngate_nthin_251 = nthin INTERACT ngate_rf_25 
ngate_nthin_252 = ngate_nthin_251 INSIDE DNW 
ngate_nthin_25 = ngate_nthin_252 NOT RFDMY6T  //  nmos_rf_25

//* Define device -- xdev nmos_rf_25_nodnw
ngate_nthin_25nodnw = ngate_nthin_251 OUTSIDE DNW  //  nmos_rf_25_nodnw

//* Define device -- xdev nmos_rf_25od
ngate_rf_25od = ngate_rf_25a AND OD25_33  //  RF 2.5v nmos over_drive 3.3v
ngate_nthin_253 = nthin INTERACT ngate_rf_25od 
ngate_nthin_254 = ngate_nthin_253 INSIDE DNW 
ngate_nthin_25od = ngate_nthin_254 NOT RFDMY6T  //  nmos_rf_25od33 over_drive 3.3v

//* Define device -- xdev nmos_rf_25_nodnwod
ngate_nthin_25nodnwod = ngate_nthin_253 OUTSIDE DNW  //  nmos_rf_25_nodnw over_drive 3.3v

//* Define device -- xdev nmos_rf_25ud
ngate_rf_25ud = ngate_rf_25a AND OD25_18  //  RF 2.5v nmos over_drive 1.8v
ngate_nthin_255 = nthin INTERACT ngate_rf_25ud 
ngate_nthin_256 = ngate_nthin_255 INSIDE DNW 
ngate_nthin_25ud = ngate_nthin_256 NOT RFDMY6T  //  nmos_rf_25ud18  under_drive 1.8v

//* Define device -- xdev nmos_rf_25_nodnwud
ngate_nthin_25nodnwud = ngate_nthin_255 OUTSIDE DNW  //  nmos_rf_25_nodnw under_drive 1.8v

//* Define device -- xdev nmos_rf_18
ngate_rf_18 = ngate_rfio3 AND OD18  //  RF 1.8V nmos
ngate_nthin_181 = nthin INTERACT ngate_rf_18 
ngate_nthin_182 = ngate_nthin_181 INSIDE DNW 
ngate_nthin_18 = ngate_nthin_182 NOT RFDMY6T  //  nmos_rf_18

//* Define device -- xdev nmos_rf_18_nodnw
ngate_nthin_18nodnw = ngate_nthin_181 OUTSIDE DNW  //  nmos_rf_18_nodnw

//* Define device -- xdev nmos_rf_na18
ngate_rf_18na1 = ngate_rf1 AND NT_Ni 
ngate_rf_18na2 = ngate_rf_18na1 AND OD18 
ngate_rf_18na3 = ngate_rf_18na2 NOT VTH_N 
ngate_rf_18na4 = ngate_rf_18na3 NOT VTL_N 
ngate_rf_18na = ngate_rf_18na4 NOT ILVT  //  IO 1.8v Native RF NMOS
ngate_nthin_18na1 = nthin INTERACT ngate_rf_18na 
ngate_nthin_18na2 = ngate_nthin_18na1 NOT DNW 
ngate_nthin_18na = ngate_nthin_18na2 NOT RFDMY6T  //  nmos_rf_na18

//* Define device -- xdev nmos_rf_33
ngate_rf_33 = ngate_rfio3 AND OD33  //  RF 3.3v nmos
ngate_nthin_331 = nthin INTERACT ngate_rf_33 
ngate_nthin_332 = ngate_nthin_331 INSIDE DNW 
ngate_nthin_33 = ngate_nthin_332 NOT RFDMY6T  //  nmos_rf_33

//* Define device -- xdev nmos_rf_33_nodnw
ngate_nthin_33nodnw = ngate_nthin_331 OUTSIDE DNW  //  nmos_rf_33_nodnw

//* Define device -- xdev nmos_rf_6t
ngate_nthin_6t = ngate_nthin3 AND RFDMY6T  //  nmos_rf_6t

//* Define device -- xdev nmos_rf_hvt_6t
ngate_nthin_hv_6t = ngate_nthin_hv2 AND RFDMY6T  //  nmos_rf_hvt_6t

//* Define device -- xdev nmos_rf_lvt_6t
ngate_nthin_lv_6t = ngate_nthin_lv2 AND RFDMY6T  //  nmos_rf_lvt_6t

//* Define device -- xdev nmos_rf_25_6t
ngate_nthin_25_6t = ngate_nthin_252 AND RFDMY6T  //  nmos_rf_25_6t

//* Define device -- xdev nmos_rf_25od33_6t
ngate_nthin_25od_6t = ngate_nthin_254 AND RFDMY6T  //  nmos_rf_25od33_6t over_drive 3.3v 6T

//* Define device -- xdev nmos_rf_25ud18_6t
ngate_nthin_25ud_6t = ngate_nthin_256 AND RFDMY6T  //  nmos_rf_25ud18_6t under_drive 1.8v 6T

//* Define device -- xdev nmos_rf_18_6t
ngate_nthin_18_6t = ngate_nthin_182 AND RFDMY6T  //  nmos_rf_18_6t

//* Define device -- xdev nmos_rf_33_6t
ngate_nthin_33_6t = ngate_nthin_332 AND RFDMY6T  //  nmos_rf_33_6t

//* Define device -- xdev pmos_rf
pgate_rfa = pgate_rf3 NOT VTH_P 
pgate_rfb = pgate_rfa NOT VTL_P 
pgate_rf = pgate_rfb NOT ILVT  //  CORE RF pmos gate
pgate_pthin1 = pthin INTERACT pgate_rf 
pgate_pthin2 = pgate_pthin1 INSIDE DNW 
pgate_pthin3 = pgate_pthin2 NOT RDKDMY 
pgate_pthin = pgate_pthin3 NOT RFDMY5T  //  pmos_rf

//* Define device -- xdev pmos_rf_rdk
pgate_pthin_rdk1 = pgate_pthin2 AND RDKDMY 
pgate_pthin_rdk = pgate_pthin_rdk1 NOT RFDMY5T  //  pmos_rf_rdk

//* Define device -- xdev pmos_rf_nw
pgate_pthin_nw1 = pgate_pthin1 OUTSIDE DNW 
pgate_pthin_nw = pgate_pthin_nw1 NOT RFDMY5T  //  pmos_rf_nw

//* Define device -- xdev pmos_rf_hvt
pgate_rfhv = pgate_rf3 AND VTH_P  //  CORE RF HVT pmos gatg
pgate_pthin_hv1 = pthin INTERACT pgate_rfhv 
pgate_pthin_hv2 = pgate_pthin_hv1 INSIDE DNW 
pgate_pthin_hv = pgate_pthin_hv2 NOT RFDMY5T  //  pmos_rf_hvt

//* Define device -- xdev pmos_rf_hvt_nw
pgate_pthin_hvnw1 = pgate_pthin_hv1 OUTSIDE DNW 
pgate_pthin_hvnw = pgate_pthin_hvnw1 NOT RFDMY5T  //  pmos_rf_hvt_nw

//* Define device -- xdev pmos_rf_lvt
pgate_rflv = pgate_rf3 AND VTL_P  //  CORE RF LVT pmos gate
pgate_pthin_lv1 = pthin INTERACT pgate_rflv 
pgate_pthin_lv2 = pgate_pthin_lv1 INSIDE DNW 
pgate_pthin_lv = pgate_pthin_lv2 NOT RFDMY5T  //  pmos_rf_lvt

//* Define device -- xdev pmos_rf_lvt_nw
pgate_pthin_lvnw1 = pgate_pthin_lv1 OUTSIDE DNW 
pgate_pthin_lvnw = pgate_pthin_lvnw1 NOT RFDMY5T  //  pmos_rf_lvt_nw

//* Define device -- xdev pmos_rf_25
pgate_rfio1 = pgate_rf2 AND OD2 
pgate_rfio2 = pgate_rfio1 NOT VTH_P 
pgate_rfio3 = pgate_rfio2 NOT VTL_P 
pgate_rf_25a = pgate_rfio3 AND OD25 
pgate_rf_25b = pgate_rf_25a NOT OD25_33 
pgate_rf_25c = pgate_rf_25b NOT OD25_18 
pgate_rf_25d = pgate_rf_25c NOT OD25_28 
pgate_rf_25 = pgate_rf_25d NOT INTERACT HVD_P 
pgate_pthin_251 = pthin INTERACT pgate_rf_25 
pgate_pthin_252 = pgate_pthin_251 INSIDE DNW 
pgate_pthin_25 = pgate_pthin_252 NOT RFDMY5T  //  pmos_rf_25

//* Define device -- xdev pmos_rf_25_nw
pgate_pthin_25nw1 = pgate_pthin_251 OUTSIDE DNW 
pgate_pthin_25nw = pgate_pthin_25nw1 NOT RFDMY5T  //  pmos_rf_25_nw

//* Define device -- xdev pmos_rf_25od
pgate_rf_25od = pgate_rf_25a AND OD25_33  //  RF 2.5v pmos gate over_drive 3.3v
pgate_pthin_253 = pthin INTERACT pgate_rf_25od 
pgate_pthin_254 = pgate_pthin_253 INSIDE DNW 
pgate_pthin_25od = pgate_pthin_254 NOT RFDMY5T  //  pmos_rf_25 over_drive 3.3v

//* Define device -- xdev pmos_rf_25_nwod
pgate_pthin_25nwod1 = pgate_pthin_253 OUTSIDE DNW 
pgate_pthin_25nwod = pgate_pthin_25nwod1 NOT RFDMY5T  //  pmos_rf_25od33_nw over_drive 3.3v

//* Define device -- xdev pmos_rf_25ud
pgate_rf_25ud = pgate_rf_25a AND OD25_18  //  RF 2.5v pmos gate over_drive 1.8v
pgate_pthin_255 = pthin INTERACT pgate_rf_25ud 
pgate_pthin_256 = pgate_pthin_255 INSIDE DNW 
pgate_pthin_25ud = pgate_pthin_256 NOT RFDMY5T  //  pmos_rf_25ud18 under_drive 1.8v

//* Define device -- xdev pmos_rf_25_nwud
pgate_pthin_25nwud1 = pgate_pthin_255 OUTSIDE DNW 
pgate_pthin_25nwud = pgate_pthin_25nwud1 NOT RFDMY5T  //  pmos_rf_25ud18_nw under_drive 1.8v

//* Define device -- xdev pmos_rf_18
pgate_rf_18 = pgate_rfio3 AND OD18  //  RF 1.8V pmos gate
pgate_pthin_181 = pthin INTERACT pgate_rf_18 
pgate_pthin_182 = pgate_pthin_181 INSIDE DNW 
pgate_pthin_18 = pgate_pthin_182 NOT RFDMY5T  //  pmos_rf_18

//* Define device -- xdev pmos_rf_18_nw
pgate_pthin_18nw1 = pgate_pthin_181 OUTSIDE DNW 
pgate_pthin_18nw = pgate_pthin_18nw1 NOT RFDMY5T  //  pmos_rf_18_nw

//* Define device -- xdev pmos_rf_33
pgate_rf_33 = pgate_rfio3 AND OD33  //  RF 3.3v pmos gate
pgate_pthin_331 = pthin INTERACT pgate_rf_33 
pgate_pthin_332 = pgate_pthin_331 INSIDE DNW 
pgate_pthin_33 = pgate_pthin_332 NOT RFDMY5T  //  pmos_rf_33

//* Define device -- xdev pmos_rf_33_nw
pgate_pthin_33nw1 = pgate_pthin_331 OUTSIDE DNW 
pgate_pthin_33nw = pgate_pthin_33nw1 NOT RFDMY5T  //  pmos_rf_33_nw

//* Define device -- xdev pmos_rf_5t
pgate_pthin_5t = pgate_pthin2 AND RFDMY5T  //  pmos_rf_5t

//* Define device -- xdev pmos_rf_nw_5t
pgate_pthin_nw_5t = pgate_pthin_nw1 AND RFDMY5T  //  pmos_rf_nw_5t

//* Define device -- xdev pmos_rf_hvt_5t
pgate_pthin_hv_5t = pgate_pthin_hv2 AND RFDMY5T  //  pmos_rf_hvt_5t

//* Define device -- xdev pmos_rf_hvt_nw_5t
pgate_pthin_hvnw_5t = pgate_pthin_hvnw1 AND RFDMY5T  //  pmos_rf_hvt_nw_5t

//* Define device -- xdev pmos_rf_lvt_5t
pgate_pthin_lv_5t = pgate_pthin_lv2 AND RFDMY5T  //  pmos_rf_lvt_5t

//* Define device -- xdev pmos_rf_lvt_nw_5t
pgate_pthin_lvnw_5t = pgate_pthin_lvnw1 AND RFDMY5T  //  pmos_rf_lvt_nw_5t

//* Define device -- xdev pmos_rf_25_5t
pgate_pthin_25_5t = pgate_pthin_252 AND RFDMY5T  //  pmos_rf_25_5t

//* Define device -- xdev pmos_rf_25_nw_5t
pgate_pthin_25nw_5t = pgate_pthin_25nw1 AND RFDMY5T  //  pmos_rf_25_nw_5t

//* Define device -- xdev pmos_rf_25od33_5t
pgate_pthin_25od_5t = pgate_pthin_254 AND RFDMY5T  //  pmos_rf_25_5t over_drive 3.3v 5T

//* Define device -- xdev pmos_rf_25od33_nw_5t
pgate_pthin_25nwod_5t = pgate_pthin_25nwod1 AND RFDMY5T  //  pmos_rf_25od33_nw_5t over_drive 3.3v

//* Define device -- xdev pmos_rf_25ud18_5t
pgate_pthin_25ud_5t = pgate_pthin_256 AND RFDMY5T  //  pmos_rf_25ud18_5t under_drive 1.8v 5T

//* Define device -- xdev pmos_rf_25ud18_nw_5t
pgate_pthin_25nwud_5t = pgate_pthin_25nwud1 AND RFDMY5T  //  pmos_rf_25ud18_nw_5t under_drive 1.8v 5T

//* Define device -- xdev pmos_rf_18_5t
pgate_pthin_18_5t = pgate_pthin_182 AND RFDMY5T  //  pmos_rf_18_5t

//* Define device -- xdev pmos_rf_18_nw_5t
pgate_pthin_18nw_5t = pgate_pthin_18nw1 AND RFDMY5T  //  pmos_rf_18_nw_5t

//* Define device -- xdev pmos_rf_33_5t
pgate_pthin_33_5t = pgate_pthin_332 AND RFDMY5T  //  pmos_rf_33_5t

//* Define device -- xdev pmos_rf_33_nw_5t
pgate_pthin_33nw_5t = pgate_pthin_33nw1 AND RFDMY5T  //  pmos_rf_33_nw_5t

//* Define device -- xdev xjvar
VAR_RFi = VAR AND RFDMY 
VAR_RF1 = VAR_RFi NOT SBDDMY 
VAR_RF2 = VAR_RF1 NOT RBCDMY 
VAR_RF = VAR_RF2 INTERACT gate_a 
XJ_RF = VAR_RF2 NOT VAR_RF 
jvar1_rf = nxwell AND XJ_RF 
jvar2_rf = jvar1_rf INTERACT tpdiff 
jvar_rf1 = jvar2_rf INTERACT tndiff 
jvar_rf = jvar_rf1 AND DNW 

//* Define device -- xdev xjvar_nw
jvar3_rf = jvar_rf1 AND tpdiff 
tpdiff_jvar = tpdiff AND jvar_rf1 
tndiff_jvar = tndiff AND jvar_rf1 
jvar_rfnw = jvar_rf1 NOT DNW 

//* Define device -- xdev moscap_rf
var_nw_rf = nxwell AND VAR_RF 
var_nw1_rf = var_nw_rf NOT OD18 
var_nw2_rf = var_nw1_rf NOT OD25 
var_nw3_rf1 = var_nw2_rf NOT OD33 
var_nw3_rf2 = var_nw3_rf1 NOT INTERACT VTH_P 
var_nw3_rf3 = var_nw3_rf2 NOT RDKDMY 
var_nw3_rf = var_nw3_rf3 AND DNW  //  moscap_rf

//* Define device -- xdev pmoscap_rf
vargt2_rf = gate_a_rf AND VAR_RF 
OD2a = OD25 OR OD25_18 
OD2b = OD2a OR OD25_33 
OD2c = OD2b OR OD18 
OD2d = OD2c OR OD33 
OD2_mos = OD2d OR OD25_28 
vargt_rf1 = vargt2_rf NOT OD2_mos 
vargt_rf = vargt_rf1 NOT VTH_P  //  RF Varactor on thin oxide

//* Define device -- xdev moscap_rf_rdk
var_nw3_rdk1 = var_nw3_rf2 AND RDKDMY 
var_nw3_rdk = var_nw3_rdk1 AND DNW  //  moscap_rf_rdk

//* Define device -- xdev moscap_rf_nw
var_nw3_rf_nw = var_nw3_rf3 NOT DNW  //  moscap_rf_nw

//* Define device -- xdev moscap_rf_hvt
var_nw3_rf4 = var_nw3_rf1 INTERACT VTH_P 
var_nw3_rf_hvt = var_nw3_rf4 AND DNW 

//* Define device -- xdev moscap_rf_hvt_nw
vargt_rf_hvt = vargt_rf1 AND VTH_P  //  RF Varactor on thin oxide with VTH_P
var_nw3_rf_hvt_nw = var_nw3_rf4 NOT DNW 

//* Define device -- xdev moscap_rf25
var_nw_rf25a = var_nw_rf AND OD25 
var_nw_rf25 = var_nw_rf25a AND DNW 

//* Define device -- xdev pmoscap_rf25
vargt_rf25 = vargt2_rf AND OD25  //  RF Varactor on 2.5v thick oxide

//* Define device -- xdev moscap_rf25_nw
var_nw_rf25_nw = var_nw_rf25a NOT DNW 

//* Define device -- xdev moscap_rf18
var_nw_rf18a = var_nw_rf AND OD18 
var_nw_rf18 = var_nw_rf18a AND DNW 

//* Define device -- xdev pmoscap_rf18
vargt_rf18 = vargt2_rf AND OD18  //  RF Varactor on 1.8v thick oxide

//* Define device -- xdev moscap_rf18_nw
var_nw_rf18_nw = var_nw_rf18a NOT DNW 

//* Define device -- xdev moscap_rf33
var_nw_rf33a = var_nw_rf AND OD33 
var_nw_rf33 = var_nw_rf33a AND DNW 

//* Define device -- xdev moscap_rf33_nw
vargt_rf33 = vargt2_rf AND OD33  //  RF Varactor on 3.3v thick oxide
var_nw_rf33_nw = var_nw_rf33a NOT DNW 

//* Define device -- xdev sbd_rf
SBD_RF1 = SBDDMY AND RFDMY 
SBD_RF = SBD_RF1 NOT VAR 
sbd_nw = nxwell AND SBD_RF 
schottky_n = nthin1 AND sbd_nw 
sbd_rfnw_org1 = sbd_nw INTERACT schottky_n 
pthin1 = mdiff CUT PP 
schottky_p = pthin1 AND sbd_nw 
sbd_rfnw_org = sbd_rfnw_org1 INTERACT schottky_p 
sbd_rfdnw = sbd_rfnw_org INTERACT DNW 

//* Define device -- xdev sbd_rf_nw
sbd_rfnw = sbd_rfnw_org NOT INTERACT DNW 

//* Define device -- xdev rppolyl_rf
rppolyl_rf1 = rppolyl_d1 NOT rppolyl_d 
rppolyl_rf2 = rppolyl_rf1 AND RFDMY 
rppolyl_rf = rppolyl_rf2 NOT RDKDMY  //  RF P+POLY resistor w/i silicide >=  2 (3-Terminals)

//* Define device -- xdev rppolys_rf
rppolys_rf1 = rppolys_d1 NOT rppolyl_d 
rppolys_rf2 = rppolys_rf1 AND RFDMY 
rppolys_rf = rppolys_rf2 NOT RDKDMY  //  RF P+POLY resistor w/i silicide < 2 (3-Terminals)

//* Define device -- xdev rppolywo_rf
rppolywo_rf1 = rppolywo_r1 AND RFDMY 
rppolywo_rf = rppolywo_rf1 NOT RDKDMY  //   RF P+POLY resistor w/o silicide (3-terminals)	

//* Define device -- xdev rppolyl_rf_rdk
rppolyl_rf_rdk = rppolyl_rf2 AND RDKDMY  //  RF RDK P+POLY resistor w/i silicide >=  2 (3-Terminals)

//* Define device -- xdev rppolys_rf_rdk
rppolys_rf_rdk = rppolys_rf2 AND RDKDMY  //  RF RDK P+POLY resistor w/i silicide < 2 (3-Terminals)

//* Define device -- xdev rppolywo_rf_rdk
rppolywo_rf_rdk = rppolywo_rf1 AND RDKDMY  //   RF RDK P+POLY resistor w/o silicide (3-terminals)	

//* Define device -- xdev ndio_hia_rf
ndio_hia1 = ndio1a AND HIADMY 
ndio_hia2 = ndio_hia1 AND psub 
ndio_hia3 = ndio_hia2 NOT OD18 
ndio_hia4 = ndio_hia3 NOT OD25 
ndio_hia5 = ndio_hia4 NOT OD33 
ndio_hia6 = ndio_hia5 NOT DCO 
ndio_hia7 = ndio_hia6 NOT NT_Ni 
ndio_hia8 = ndio_hia7 NOT VTH_N 
ndio_hia9 = ndio_hia8 NOT VTL_N 
ndio_hia10 = ndio_hia9 NOT ILVT 
ndio_hia11 = ndio_hia10 NOT UHVT_N 
ndio_hia12 = ndio_hia11 AND RFDMY 
ndio_hia = ndio_hia12 NOT RBCDMY 

//* Define device -- xdev pdio_hia_rf
pdio_hia1 = pdio1a AND HIADMY 
pdio_hia2 = pdio_hia1 AND nxwell 
pdio_hia3 = pdio_hia2 NOT OD18 
pdio_hia4 = pdio_hia3 NOT OD25 
pdio_hia5 = pdio_hia4 NOT OD33 
pdio_hia6 = pdio_hia5 NOT DCO 
pdio_hia7 = pdio_hia6 NOT VTH_P 
pdio_hia8 = pdio_hia7 NOT VTL_P 
pdio_hia9 = pdio_hia8 NOT ILVT 
pdio_hia10 = pdio_hia9 NOT UHVT_P 
pdio_hia11 = pdio_hia10 AND RFDMY 
pdio_hia = pdio_hia11 NOT RBCDMY 

//***** Define connectivity/via layer -- RFDMY_hia ****
dio_inrf1 = HIADMY AND nxwell 
dio_inrf = dio_inrf1 INSIDE RFDMY 
RFDMY_hia1 = RFDMY INTERACT dio_inrf 
RFDMY_hia = RFDMY_hia1 NOT RBCDMY 
pvar_rf1 = VAR_RF NOT nxwell 
pvar_rf2 = pvar_rf1 AND DNW 
pvar_rf3 = pvar_rf2 NOT OD33 
pvar_rf4 = pvar_rf3 NOT OD18 
pvar_rf = pvar_rf4 NOT OD25 
pvar_rf18a = pvar_rf3 AND OD18 
pvar_rf18 = pvar_rf18a NOT OD25 
pvar_rf25 = pvar_rf4 AND OD25 

//* Define device -- xdev sline_ms_mu
sline_ms_mu_r = INDDMY WITH TEXT "sline_ms_mu" IND_TEXT 

//***** Define connectivity/via layer -- sline_m9p ****
sline_m9 = M9 AND TLDMY 
sline_m9a = sline_m9 AND INDDMY 
sline_m9p = sline_m9a NOT IND_MP 

//***** Define connectivity/via layer -- sline_m9m ****
sline_m9m1 = sline_m9a AND IND_MP 
sline_m9p2 = SIZE sline_m9p BY 0.001 
sline_m9m = sline_m9m1 NOT sline_m9p2 

//* Define device -- xdev sline_gscpw_mu
sline_cpw_mu_r = INDDMY WITH TEXT "sline_gscpw_mu" IND_TEXT 

//***** Define connectivity/via layer -- sline_m8 ****
sline_m8a = M8 AND TLDMY 
sline_m8 = sline_m8a AND INDDMY 

//* Define device -- xdev spiral_std_mu_z
std_ind1 = M9 AND IND_STD 
std_ind21 = M8 AND IND_STD 
IND_RAD = IND_RADi NOT RBCDMY  //  IND_RAD should not interact RBCDMY for regular spiral devices
std_ind2 = std_ind21 INTERACT IND_RAD 
std_ind3 = std_ind1 OR std_ind2 
std_ind4 = std_ind3 INTERACT IND_RAD 
std_ind = std_ind4 NOT RDKDMY  //  mu_z (1z1u top2 thick) std spiral

//* Define device -- xdev spiral_std_mu_z_rdk
std_ind_m = std_ind1 AND std_ind2 

//***** Define connectivity/via layer -- indm9p ****
indm9b = SIZE INDDMY BY 0.005 
indm9a = indm9b NOT INTERACT TLDMY 
indm9 = indm9a AND M9Y 
indm9p1 = indm9 NOT IND_MP 
indm9p2 = indm9p1 NOT INTERACT IND_MP 
indm9p = indm9p2 NOT IND_D4 

//***** Define connectivity/via layer -- indm9m ****
indm9m = indm9 AND IND_MP 

//* Define device -- xdev spiral_sym_mu_z
sym_ind1 = M9 AND IND_SYM 
sym_ind2 = M8 AND IND_SYM 
sym_ind3 = sym_ind1 OR sym_ind2 
sym_ind4 = sym_ind3 INTERACT IND_RAD 
sym_ind = sym_ind4 NOT RDKDMY  //  mu_z(1z1u top2 thick) sym spiral

//* Define device -- xdev spiral_sym_mu_z_rdk
sym_ind_m = sym_ind1 AND sym_ind2 

//* Define device -- xdev spiral_sym_ct_mu_z
ct_ind1 = M9 AND IND_CT 
ct_ind2 = M8 AND IND_CT 
ct_inda1 = ct_ind1 OR ct_ind2 
ct_inda = ct_inda1 INTERACT IND_NR 
ct_ind3 = M7 AND IND_CT 
ct_ind4 = ct_inda OR ct_ind3 
ct_ind5 = ct_ind4 INTERACT IND_RAD 
ct_ind = ct_ind5 NOT RDKDMY  //  mu_z(1z1u top2_thick) ctap spiral

//* Define device -- xdev spiral_sym_ct_mu_z_rdk
ct_ind_m = ct_ind1 AND ct_ind2 

//***** Define connectivity/via layer -- indm9c ****
indm9p3 = indm9p2 AND IND_D4 
indm9p4 = indm9p3 INTERACT indm9p 
IND_D41 = IND_D4 NOT indm9p4 
IND_D42 = IND_D41 NOT indm9m 
IND_D4i = SIZE IND_D42 BY -0.001 
indm9c1 = indm9 AND IND_D4i 
indm8 = indm9a AND M8Y 
indm9c2 = indm8 AND IND_D4i 
indm9c4 = indm9c1 OR indm9c2 
indm7 = indm9a AND M7Y 
indm9c3 = indm7 AND IND_D4i 
indm9c = indm9c4 OR indm9c3 
std_ind_rdk = std_ind4 AND RDKDMY  //  mu_z (1z1u top2 thick) std spiral(RDK)
sym_ind_rdk = sym_ind4 AND RDKDMY  //  mu_z(1z1u top2 thick) sym spiral(RDK)
ct_ind_rdk = ct_ind5 AND RDKDMY  //  mu_z(1z1u top2_thick) ctap spiral(RDK)

//* Define device -- xdev mimcap_sin_3t
mim_top = ctm AND cbm 

//***** Define connectivity/via layer -- PROBEM1_T ****
PROBEM1_T1 = SIZE PROBEM1 BY 0.005 
PROBEM1_T = PROBEM1_T1 NOT PROBEM1 

//***** Define connectivity/via layer -- PROBEM2_T ****
PROBEM2_T1 = SIZE PROBEM2 BY 0.005 
PROBEM2_T = PROBEM2_T1 NOT PROBEM2 

//***** Define connectivity/via layer -- PROBEM3_T ****
PROBEM3_T1 = SIZE PROBEM3 BY 0.005 
PROBEM3_T = PROBEM3_T1 NOT PROBEM3 

//***** Define connectivity/via layer -- PROBEM4_T ****
PROBEM4_T1 = SIZE PROBEM4 BY 0.005 
PROBEM4_T = PROBEM4_T1 NOT PROBEM4 

//***** Define connectivity/via layer -- PROBEM5_T ****
PROBEM5_T1 = SIZE PROBEM5 BY 0.005 
PROBEM5_T = PROBEM5_T1 NOT PROBEM5 

//***** Define connectivity/via layer -- PROBEM6_T ****
PROBEM6_T1 = SIZE PROBEM6 BY 0.005 
PROBEM6_T = PROBEM6_T1 NOT PROBEM6 

//***** Define connectivity/via layer -- PROBEM7_T ****
PROBEM7_T1 = SIZE PROBEM7 BY 0.005 
PROBEM7_T = PROBEM7_T1 NOT PROBEM7 

//* Define device -- xdev lincap
lin_nw1 = nxwell AND VTDN 
lin_nw2 = lin_nw1 NOT RFDMY 
lin_nw3 = lin_nw2 NOT OD25 
lin_nw = lin_nw3 AND DNW  //  Linear Cap
lingt1 = vargt1 AND VTDN 
lingt = lingt1 NOT OD25 

//* Define device -- xdev lincap_25
lin_nw4 = lin_nw2 AND OD25 
lin_nw_25 = lin_nw4 AND DNW  //  2.5 Linear Cap
lingt_25 = lingt1 AND OD25 

//* Define device -- xdev lincap_rf
lin_nw5 = lin_nw1 AND RFDMY 
lin_nw6 = lin_nw5 NOT OD25 
lin_nw_rf = lin_nw6 AND DNW  //  RF Linear Cap
lingt2 = gate_a_rf AND NW 
lingt3 = lingt2 AND NP 
lingt4 = lingt3 AND VTDN 
lingt_rf = lingt4 NOT OD25 

//* Define device -- xdev lincap_rf_25
lin_nw7 = lin_nw5 AND OD25 
lin_nw_rf_25 = lin_nw7 AND DNW  //  RF 2.5 Linear Cap
lingt_rf_25 = lingt4 AND OD25 

//* Define device -- xdev lowcpad_d23
ap_pad = AP AND RFPADDMY 
m9_pad = M9 AND RFPADDMY 
rfpad1 = ap_pad AND m9_pad 
m8_pad = M8 AND RFPADDMY 
rfpad2 = rfpad1 INTERACT m8_pad 
rfpad3 = rfpad2 AND PP 
rfpad4 = rfpad3 AND PO 
rfpad5 = rfpad4 INTERACT CB 
rfpad6 = rfpad5 INTERACT CB2 
rfpad7 = rfpad6 INTERACT VIA8i 
rfpad = rfpad7 NOT RBCDMY 
m1_pad = M1 AND RFPADDMY 
m2_pad = M2 AND RFPADDMY 
bot_dmy1 = m1_pad OR m2_pad 
m3_pad = M3 AND RFPADDMY 
bot_dmy2 = bot_dmy1 OR m3_pad 
m4_pad = M4 AND RFPADDMY 
bot_dmy3 = bot_dmy2 OR m4_pad 
m5_pad = M5 AND RFPADDMY 
bot_dmy4 = bot_dmy3 OR m5_pad 
m6_pad = M6 AND RFPADDMY 
bot_dmy5 = bot_dmy4 OR m6_pad 
m7_pad = M7 AND RFPADDMY 
bot_dmy6 = bot_dmy5 OR m7_pad 
bot_dmy = COPY bot_dmy6 

//* Define device -- xdev nmos_rf_diff_nw
nthin_diff1 = rf_diff AND DIFRBC 
ngate_rfc1 = gate_rbc NOT nxwell 
ngate_rfc2 = ngate_rfc1 AND NP 
ngate_rfc = ngate_rfc2 NOT NT_Ni 
gate_rbc_diff = ngate_rfc AND DIFRBC 
nthin_diff_ori = nthin_diff1 INTERACT gate_rbc_diff 
nthin_diff_nw = nthin_diff_ori NOT INTERACT DNW 

//* Define device -- xdev nmos_rf_cross_nw
nthin_xcouple1 = rf_diff AND XCLRBC 
gate_rbc_xcoup = ngate_rfc AND XCLRBC 
nthin_xcouple_ori = nthin_xcouple1 INTERACT gate_rbc_xcoup 
nthin_xcouple_nw = nthin_xcouple_ori NOT INTERACT DNW 

//* Define device -- xdev nmos_rf_cas_nw
nthin_cas1 = rf_diff AND CASRBC 
gate_rbc_cas = ngate_rfc AND CASRBC 
nthin_cas_ori = nthin_cas1 INTERACT gate_rbc_cas 
nthin_cas_nw = nthin_cas_ori NOT INTERACT DNW 

//***** Define connectivity/via layer -- gate_rbc_casb ****
gate_rbc_casb = gate_rbc_cas INTERACT GTDMY2 

//***** Define connectivity/via layer -- gate_rbc_cast ****
gate_rbc_cast = gate_rbc_cas INTERACT GTDMY1 

//* Define device -- xdev rfesd_rf1
rfesd_dmy1 = RFESDMY AND RBCDMY 
rfpad_a = rfpad7 AND RBCDMY 
rfesd_dmy = rfesd_dmy1 INTERACT rfpad_a 
rfesd_r1a = RBCDMY WITH TEXT "rfesd_rf1" RBC_TEXT 
rfesd_r1 = rfesd_dmy INTERACT rfesd_r1a 

//***** Define connectivity/via layer -- cpad ****
hiadmy_rbc = HIADMY AND RBCDMY 
cpad1 = metal9 INTERACT hiadmy_rbc 
cpad2 = cpad1 INTERACT indm9m 
cpad = cpad2 NOT INTERACT indm9p 

//* Define device -- xdev rfesd_rf2
rfesd_r2a = RBCDMY WITH TEXT "rfesd_rf2" RBC_TEXT 
rfesd_r2 = rfesd_dmy INTERACT rfesd_r2a 

//* Define device -- xdev rfesd_rf3
rfesd_r3a = RBCDMY WITH TEXT "rfesd_rf3" RBC_TEXT 
rfesd_r3 = rfesd_dmy INTERACT rfesd_r3a 

//* Define device -- xdev rfesd_rf4
rfesd_r4a = RBCDMY WITH TEXT "rfesd_rf4" RBC_TEXT 
rfesd_r4 = rfesd_dmy INTERACT rfesd_r4a 

//* Define device -- xdev rfesd_rf5
rfesd_r5a = RBCDMY WITH TEXT "rfesd_rf5" RBC_TEXT 
rfesd_r5 = rfesd_dmy INTERACT rfesd_r5a 

//* Define device -- xdev rfesd_rf6
rfesd_r6a = RBCDMY WITH TEXT "rfesd_rf6" RBC_TEXT 
rfesd_r6 = rfesd_dmy INTERACT rfesd_r6a 

//* Define device -- xdev rfesd_rf7
rfesd_r7a = RBCDMY WITH TEXT "rfesd_rf7" RBC_TEXT 
rfesd_r7 = rfesd_dmy INTERACT rfesd_r7a 

//* Define device -- xdev rfesd_rf8
rfesd_r8a = RBCDMY WITH TEXT "rfesd_rf8" RBC_TEXT 
rfesd_r8 = rfesd_dmy INTERACT rfesd_r8a 

//***** Define connectivity/via layer -- polyCont ****
polyCont = CO INTERACT POI 

//***** Define connectivity/via layer -- PROBEM6_B ****
PROBEM6_B = PROBEM6_T AND BULK 

//***** Define connectivity/via layer -- mom3p1 ****
mom3p11 = metal3 AND MOMDMY23 
mom3p1 = mom3p11 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- PROBEM5_B ****
PROBEM5_B = PROBEM5_T AND BULK 

//***** Define connectivity/via layer -- ipbase1 ****
ipbase1 = pbase1 AND OD25  //  define I/O  BJT[N1] base terminal

//***** Define connectivity/via layer -- PROBEM2_B ****
PROBEM2_B = PROBEM2_T AND BULK 

//***** Define connectivity/via layer -- PROBEM1_B ****
PROBEM1_B = PROBEM1_T AND BULK 

//***** Define connectivity/via layer -- mom5m1 ****
mom5p11 = metal5 AND MOMDMY23 
mom5m1 = mom5p11 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- mom7p1 ****
mom7p11 = metal7 AND MOMDMY23 
mom7p1 = mom7p11 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- iemit1 ****
iemit1 = ttdiff AND inbase1  //  define I/O  BJT[P1] emitter

//***** Define connectivity/via layer -- PROBEM4_B ****
PROBEM4_B = PROBEM4_T AND BULK 

//***** Define connectivity/via layer -- mom6m1 ****
mom6p11 = metal6 AND MOMDMY23 
mom6m1 = mom6p11 NOT INTERACT MOMDMY25 

//* Define ERC or other layers
stimer = SRM NOT SRAMTIMER 
dfm_gate1 = gate1 NOT INTERACT stimer 
dfm_gate2 = SIZE dfm_gate1 BY WPED
nw_ntn = NW OR NT_Ni 
nIO = OD2 NOT nw_ntn  //  nmos IO for WPE (clear tone)
c_nmIO_aux = dfm_gate2 AND nIO 

//***** Define connectivity/via layer -- RFDMY_hia_psub ****
RFDMY_hia_psub = RFDMY_hia NOT nxwell 

//***** Define connectivity/via layer -- PROBEM7_B ****
PROBEM7_B = PROBEM7_T AND BULK 

//***** Define connectivity/via layer -- mom7m2 ****
mom7p21 = metal7 AND MOMDMY24 
mom7m2 = mom7p21 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- mom7m1 ****
mom7m1 = mom7p11 NOT INTERACT MOMDMY25 
d_nmcore = OD2 OR nw_ntn  //  nmos core for WPE (Dark tone)
nCore = BULK NOT d_nmcore  //  nmos core for WPE (clear tone)
c_nmcore_aux = dfm_gate2 AND nCore 

//***** Define connectivity/via layer -- n_psub ****
n_psub = BULK NOT psubband 

//***** Define connectivity/via layer -- mom4m2 ****
mom4p21 = metal4 AND MOMDMY24 
mom4m2 = mom4p21 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- pplug ****
pplug1 = tpdiff AND psub 
odCont1 = CO INTERACT OD 
p3Cont = CO INTERACT p3 
odCont = odCont1 NOT p3Cont 
pplug2 = pplug1 INTERACT odCont 
tndiffco = tndiff INTERACT odCont 
pplug3 = pplug1 INTERACT tndiffco 
pplug = pplug2 OR pplug3  //  define p_sub contact

//***** Define connectivity/via layer -- d_nd25hvdw ****
d_nd25hvdw = tndiff_ori AND HVD_NW 

//***** Define connectivity/via layer -- MOM_field4 ****
MOM_field4 = M4 AND MOMDMY4 

//***** Define connectivity/via layer -- rfdmy56_via ****
rfdmy56_via1 = rfdmy56 AND psub 
rwel_rfdmy56 = rwel INSIDE rfdmy56 
rfdmy56_via2 = rfdmy56_via1 NOT rwel_rfdmy56 
nw_dnw = NW INTERACT rwel 
rfdmy56_via = rfdmy56_via2 NOT nw_dnw 

//***** Define connectivity/via layer -- mom4m1 ****
mom4p11 = metal4 AND MOMDMY23 
mom4m1 = mom4p11 NOT INTERACT MOMDMY25 
c_pmall1 = NW NOT NT_Ni 
pCore = c_pmall1 NOT OD33  //  pmos all for WPE (clear tone)
c_pmcore_aux = dfm_gate2 AND pCore 

//***** Define connectivity/via layer -- MOM_field5 ****
MOM_field5 = M5 AND MOMDMY5 

//***** Define connectivity/via layer -- mom5p1 ****
mom5p1 = mom5p11 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- VIA9 ****
VIA9a = RV OR CBD 
VIA9 = VIA9a OR CB 
erc_nmos_gates = tngate1 NOT VAR 

//***** Define connectivity/via layer -- ydio_ass ****
ydio_ass = COPY ydio 

//***** Define connectivity/via layer -- gate1_not_IO2 ****
gate1_not_IO1 = gate1 NOT OD25 
gate1_not_IO2 = gate1_not_IO1 NOT OD33 

//***** Define connectivity/via layer -- rf_hia_via ****
rf_hia_via1 = SIZE RFDMY_hia_psub BY 0.005 
rf_hia_via2 = rf_hia_via1 NOT RFDMY_hia_psub 
rf_hia_via = rf_hia_via2 AND psub 
gate_a1 = gate1 NOT stimer 

//***** Define connectivity/via layer -- indm10c ****
indm10 = indm9a AND M10Y 
indm10c = indm10 INTERACT IND_D4 

//***** Define connectivity/via layer -- MOM_field2 ****
MOM_field2 = M2 AND MOMDMY2 

//***** Define connectivity/via layer -- VIA1 ****
VIA1 = COPY VIA1i  //  VIA1

//***** Define connectivity/via layer -- MOM_field7 ****
MOM_field7 = M7 AND MOMDMY7 

//***** Define connectivity/via layer -- nxwell_npn ****
ncollsa = ncolls TOUCH cemit1 
ncollsb = ncolls TOUCH iemit1 
ncollall = ncollsa OR ncollsb 
nxwell_npn = ncolls NOT ncollall 

//***** Define connectivity/via layer -- mom6p1 ****
mom6p1 = mom6p11 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- nplug ****
nplug1 = tndiff AND nxwell 
nplug2 = nplug1 INTERACT odCont 
tpdiffco = tpdiff INTERACT odCont 
nplug3 = nplug1 INTERACT tpdiffco 
nplug = nplug2 OR nplug3  //  define N_well contact
erc_pmos_gates = tpgate1 NOT VAR 

//***** Define connectivity/via layer -- mom5p2 ****
mom5p21 = metal5 AND MOMDMY24 
mom5p2 = mom5p21 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- ntap ****
xwell = NW OUTSIDE NWDMY 
ntapx = tndiff AND xwell 
ntap1 = ntapx NOT BJTDMY 
ntap2 = ntap1 INTERACT CO 
ntap3 = ntap1 INTERACT tpdiffco 
ntap = ntap2 OR ntap3 

//***** Define connectivity/via layer -- poly_nw_via ****
poly_nw_via = poly_term AND nxwell 

//***** Define connectivity/via layer -- MOM_field3 ****
MOM_field3 = M3 AND MOMDMY3 

//***** Define connectivity/via layer -- hiaplug ****
hiaplug1 = tpdiff AND RFDMY_hia 
hiaplug2 = hiaplug1 INTERACT CO 
hiaplug3 = hiaplug1 INTERACT tndiffco 
hiaplug4 = hiaplug2 OR hiaplug3 
hiaplug = hiaplug4 NOT nxwell 
nt_n = COPY NT_Ni 
c_nt_n_aux = dfm_gate2 AND nt_n 
nxwell_float1 = nxwell NOT INTERACT VAR  //  exclude nwell under VAR for floating nwell check
nxwell_float2 = nxwell_float1 NOT INTERACT trwell  //  exclude nwell resistor for floating nwell check
nxwell_float = nxwell_float2 NOT TCDDMY  //  exclude dummy nwell under TCDDMY

//***** Define connectivity/via layer -- PROBEM3_B ****
PROBEM3_B = PROBEM3_T AND BULK 

//***** Define connectivity/via layer -- VIA2 ****
VIA2 = COPY VIA2i  //  VIA2

//***** Define connectivity/via layer -- MOM_field6 ****
MOM_field6 = M6 AND MOMDMY6 
pIO = c_pmall1 AND OD33  //  pmos IO 3.3V WPE

//***** Define connectivity/via layer -- mom5m2 ****
mom5m2 = mom5p21 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- dnwc ****
dnwc = DNW AND nxwell 

//***** Define connectivity/via layer -- tiod ****
tioda = diff NOT tpdiff 
tiodb = tioda NOT tndiff 
tiod1 = tiodb NOT PO 
tiod2 = tiod1 NOT RPO 
tiod3 = tiod2 NOT RPDMY 
tiod = tiod3 NOT NWDMY  //  RPO, RPDMY, NWDMY cut ti-od

//***** Define connectivity/via layer -- mom4p2 ****
mom4p2 = mom4p21 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- VIA5 ****
VIA5 = COPY VIA5i  //  VIA5

//***** Define connectivity/via layer -- mom6m2 ****
mom6p21 = metal6 AND MOMDMY24 
mom6m2 = mom6p21 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- mom7p2 ****
mom7p2 = mom7p21 INTERACT MOMDMY25 
c_pmIO_aux = dfm_gate2 AND pIO 

//***** Define connectivity/via layer -- d_pd25hvd ****
d_pd25hvd = tpdiff_ori AND HVD_P 

//***** Define connectivity/via layer -- VIA3 ****
VIA3 = COPY VIA3i  //  VIA3

//***** Define connectivity/via layer -- mom3m2 ****
mom3p21 = metal3 AND MOMDMY24 
mom3m2 = mom3p21 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- VIA4 ****
VIA4 = COPY VIA4i  //  VIA4

//***** Define connectivity/via layer -- mom4p1 ****
mom4p1 = mom4p11 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- mom3p2 ****
mom3p2 = mom3p21 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- VIA6 ****
VIA6 = COPY VIA6i  //  VIA6

//***** Define connectivity/via layer -- mom6p2 ****
mom6p2 = mom6p21 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- n_pplug ****
n_pplug1 = mdiff INTERACT odCont 
n_pplug2 = n_pplug1 AND PP 
n_pplug3 = n_pplug2 NOT nxwell 
n_pplug4 = n_pplug3 NOT rwel 
n_pplug = n_pplug4 AND n_psub 

//***** Define connectivity/via layer -- poly_psub_via ****
poly_psub_via = poly_term AND psub 

//***** Define connectivity/via layer -- mom3m1 ****
mom3m1 = mom3p11 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- ptap ****
ptap1 = tpdiff AND psub 
ptap2 = ptap1 INTERACT CO 
ptap3 = ptap1 INTERACT tndiffco 
ptap = ptap2 OR ptap3 

//***** Define connectivity/via layer -- MOM_field1 ****
MOM_field1 = M1 AND MOMDMY1 
//#############################################
//# CONNECTION                                #
//#############################################
CONNECT MOM_field1 metal1
CONNECT MOM_field2 MOM_field1 BY VIA1
CONNECT MOM_field2 metal2
CONNECT MOM_field3 MOM_field2 BY VIA2
CONNECT MOM_field3 metal3
CONNECT MOM_field4 MOM_field3 BY VIA3
CONNECT MOM_field4 metal4
CONNECT MOM_field5 MOM_field4 BY VIA4
CONNECT MOM_field5 metal5
CONNECT MOM_field6 MOM_field5 BY VIA5
CONNECT MOM_field6 metal6
CONNECT MOM_field7 MOM_field6 BY VIA6
CONNECT MOM_field7 metal7
CONNECT cemit1 tpdiff
CONNECT cnbase1 tndiff BY nplug
CONNECT cnemit1 tndiff
CONNECT cpad metal9
CONNECT cpbase1 tpdiff BY pplug
CONNECT d_nd25hvdw tndiff
CONNECT d_pd25hvd tpdiff
CONNECT d_tndiff tndiff
CONNECT d_tpdiff tpdiff
CONNECT gate1 poly
CONNECT gate1_not_IO2 poly
CONNECT gate_rbc_casb poly
CONNECT gate_rbc_cast poly
CONNECT gate_rbc_diff poly
CONNECT gate_rbc_xcoup poly
CONNECT iemit1 tpdiff
CONNECT inbase1 tndiff BY nplug
CONNECT inemit1 tndiff
CONNECT ipbase1 tpdiff BY pplug
CONNECT metal1 d_nd25hvdw BY odCont
CONNECT metal1 d_pd25hvd BY odCont
CONNECT metal1 d_tndiff BY odCont
CONNECT metal1 d_tpdiff BY odCont
CONNECT metal1 p3 BY p3Cont
CONNECT metal1 poly BY polyCont
CONNECT metal1 s_nd25hvdw BY odCont
CONNECT metal1 s_pd25hvd BY odCont
CONNECT metal1 s_tndiff BY odCont
CONNECT metal1 s_tndiff_cas BY odCont
CONNECT metal1 s_tpdiff BY odCont
CONNECT metal1 schottky_n BY odCont
CONNECT metal1 schottky_p BY odCont
CONNECT metal1 tndiff BY odCont
CONNECT metal1 tpdiff BY odCont
CONNECT metal10 indm10c
CONNECT metal10 metal9 BY VIA9
CONNECT metal2 metal1 BY VIA1
CONNECT metal3 metal2 BY VIA2
CONNECT metal3 mom3m1
CONNECT metal3 mom3m2
CONNECT metal3 mom3p1
CONNECT metal3 mom3p2
CONNECT metal4 metal3 BY VIA3
CONNECT metal4 mom4m1
CONNECT metal4 mom4m2
CONNECT metal4 mom4p1
CONNECT metal4 mom4p2
CONNECT metal5 metal4 BY VIA4
CONNECT metal5 mom5m1
CONNECT metal5 mom5m2
CONNECT metal5 mom5p1
CONNECT metal5 mom5p2
CONNECT metal6 metal5 BY VIA5
CONNECT metal6 mom6m1
CONNECT metal6 mom6m2
CONNECT metal6 mom6p1
CONNECT metal6 mom6p2
CONNECT metal7 indm9c
CONNECT metal7 metal6 BY VIA6
CONNECT metal7 mom7m1
CONNECT metal7 mom7m2
CONNECT metal7 mom7p1
CONNECT metal7 mom7p2
CONNECT metal8 indm9c
CONNECT metal8 sline_m8
CONNECT metal9 indm9c
CONNECT metal9 indm9m
CONNECT metal9 indm9p
CONNECT metal9 sline_m9m
CONNECT metal9 sline_m9p
CONNECT n_pplug tpdiff
CONNECT ncoll1 nxwell_npn
CONNECT nplug tndiff
CONNECT ntap tndiff
CONNECT poly crown BY blc
CONNECT poly poly_rf
CONNECT pplug tpdiff
CONNECT ptap tpdiff
CONNECT s_nd25hvdw tndiff
CONNECT s_pd25hvd tpdiff
CONNECT s_tndiff tndiff
CONNECT s_tndiff_cas tndiff
CONNECT s_tpdiff tpdiff
CONNECT tiod tndiff
CONNECT tiod tpdiff
CONNECT tndiff crown BY blc
CONNECT tndiff nxwell_npn BY nplug
CONNECT tndiff tpdiff
CONNECT tndiff ydio_ass
CONNECT tndiff ydio_hole
CONNECT tpdiff crown BY blc

#IFDEF RC_DECK
CONNECT  poly gate
CONNECT  nxwell poly_term BY poly_nw_via
CONNECT  nxwell PROBEM5_T BY PROBEM5_B
CONNECT  nxwell PROBEM2_T BY PROBEM2_B
CONNECT  nxwell DNW BY dnwc
CONNECT  nxwell PROBEM3_T BY PROBEM3_B
CONNECT  nxwell PROBEM7_T BY PROBEM7_B
CONNECT  nxwell PROBEM1_T BY PROBEM1_B
CONNECT  nxwell PROBEM4_T BY PROBEM4_B
CONNECT  nxwell PROBEM6_T BY PROBEM6_B
CONNECT  psub poly_term BY poly_psub_via
CONNECT  psub PROBEM5_T BY PROBEM5_B
CONNECT  psub PROBEM2_T BY PROBEM2_B
CONNECT  psub RFDMY_hia_psub BY rf_hia_via
CONNECT  psub PROBEM3_T BY PROBEM3_B
CONNECT  psub PROBEM7_T BY PROBEM7_B
CONNECT  psub PROBEM1_T BY PROBEM1_B
CONNECT  psub rfdmy56 BY rfdmy56_via
CONNECT  psub PROBEM4_T BY PROBEM4_B
CONNECT  psub PROBEM6_T BY PROBEM6_B
CONNECT  tpdiff rwel BY pplug
CONNECT  tpdiff psub_term BY pplug
CONNECT  tpdiff psub BY pplug
CONNECT  tpdiff RFDMY_hia BY hiaplug
CONNECT  tpdiff coll1 BY pplug
CONNECT  tndiff nxwell BY nplug
#ELSE
SCONNECT nxwell poly_term BY poly_nw_via
SCONNECT nxwell PROBEM5_T BY PROBEM5_B
SCONNECT nxwell PROBEM2_T BY PROBEM2_B
SCONNECT nxwell DNW BY dnwc
SCONNECT nxwell PROBEM3_T BY PROBEM3_B
SCONNECT nxwell PROBEM7_T BY PROBEM7_B
SCONNECT nxwell PROBEM1_T BY PROBEM1_B
SCONNECT nxwell PROBEM4_T BY PROBEM4_B
SCONNECT nxwell PROBEM6_T BY PROBEM6_B
SCONNECT psub poly_term BY poly_psub_via
SCONNECT psub PROBEM5_T BY PROBEM5_B
SCONNECT psub PROBEM2_T BY PROBEM2_B
SCONNECT psub RFDMY_hia_psub BY rf_hia_via
SCONNECT psub PROBEM3_T BY PROBEM3_B
SCONNECT psub PROBEM7_T BY PROBEM7_B
SCONNECT psub PROBEM1_T BY PROBEM1_B
SCONNECT psub rfdmy56 BY rfdmy56_via
SCONNECT psub PROBEM4_T BY PROBEM4_B
SCONNECT psub PROBEM6_T BY PROBEM6_B
SCONNECT tpdiff rwel BY pplug
#IFNDEF NW_RING
  SCONNECT tpdiff n_psub BY n_pplug
#ENDIF
SCONNECT tpdiff psub_term BY pplug
SCONNECT tpdiff psub BY pplug
SCONNECT tpdiff RFDMY_hia BY hiaplug
SCONNECT tpdiff coll1 BY pplug
SCONNECT tndiff nxwell BY nplug
#ENDIF
//#############################################
//# FORM DEVICE                               #
//#############################################

#IFDEF RC_DECK_BLA

#IFDEF DFM_RULE
INCLUDE ./DFM/dfm_device

DEVICE LDDP(pch_hv25_spw) pgate_25hvd d_pd25hvd(D) poly(G) s_pd25hvd(S) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_hv25_spw netlist element "M" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_25hvd, s_pd25hvd ) + perimeter_coincide(pgate_25hvd, d_pd25hvd)) / 2
   L=area(pgate_25hvd) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE LDDP(pch_hv25_spw) pgate_25hvd_mac d_pd25hvd(D) poly(G) s_pd25hvd(S) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_hv25_spw_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_25hvd_mac, s_pd25hvd ) + perimeter_coincide(pgate_25hvd_mac, d_pd25hvd)) / 2
   L=area(pgate_25hvd_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE LDDN(nch_hv25_snw) ngate_25hvdw d_nd25hvdw(D) poly(G) s_nd25hvdw(S) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_hv25_snw netlist element "M" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25hvdw, s_nd25hvdw ) + perimeter_coincide(ngate_25hvdw, d_nd25hvdw)) / 2
   L=area(ngate_25hvdw) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE LDDN(nch_hv25_snw) ngate_25hvdw_mac d_nd25hvdw(D) poly(G) s_nd25hvdw(S) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_hv25_snw_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25hvdw_mac, s_nd25hvdw ) + perimeter_coincide(ngate_25hvdw_mac, d_nd25hvdw)) / 2
   L=area(ngate_25hvdw_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

ngatez1 = SIZE ngate BY 0.005
ngatez = ngatez1 AND nthin1
DEVICE MN(nch) ngatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch CMACRO dfm_nmos_core

DEVICE MN(nch_18) ngate_18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_18, tndiff ) + perimeter_inside(ngate_18, tndiff)) / 2
   L=area(ngate_18) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_18_dnw) dngate_18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_18, tndiff ) + perimeter_inside(dngate_18, tndiff)) / 2
   L=area(dngate_18) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_18_dnw) dngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_18_mac, tndiff ) + perimeter_inside(dngate_18_mac, tndiff)) / 2
   L=area(dngate_18_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_18) ngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_18_mac, tndiff ) + perimeter_inside(ngate_18_mac, tndiff)) / 2
   L=area(ngate_18_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25) ngate_25 poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25, tndiff ) + perimeter_inside(ngate_25, tndiff)) / 2
   L=area(ngate_25) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25_dnw) dngate_25 poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_25, tndiff ) + perimeter_inside(dngate_25, tndiff)) / 2
   L=area(dngate_25) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25_dnw) dngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_25_mac, tndiff ) + perimeter_inside(dngate_25_mac, tndiff)) / 2
   L=area(dngate_25_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25_dnwod) dngate_25od poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_25od, tndiff ) + perimeter_inside(dngate_25od, tndiff)) / 2
   L=area(dngate_25od) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25_dnwod) dngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_25od_mac, tndiff ) + perimeter_inside(dngate_25od_mac, tndiff)) / 2
   L=area(dngate_25od_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25_dnwud) dngate_25ud poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_25ud, tndiff ) + perimeter_inside(dngate_25ud, tndiff)) / 2
   L=area(dngate_25ud) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25_dnwud) dngate_25ud_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_25ud_mac, tndiff ) + perimeter_inside(dngate_25ud_mac, tndiff)) / 2
   L=area(dngate_25ud_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25) ngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25_mac, tndiff ) + perimeter_inside(ngate_25_mac, tndiff)) / 2
   L=area(ngate_25_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25od) ngate_25od poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25od, tndiff ) + perimeter_inside(ngate_25od, tndiff)) / 2
   L=area(ngate_25od) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25od28) ngate_25od28 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25od28 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25od28, tndiff ) + perimeter_inside(ngate_25od28, tndiff)) / 2
   L=area(ngate_25od28) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25od28_dnw) dngate_25od28 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25od28 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_25od28, tndiff ) + perimeter_inside(dngate_25od28, tndiff)) / 2
   L=area(dngate_25od28) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25od28_dnw) dngate_25od28_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25od28_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_25od28_mac, tndiff ) + perimeter_inside(dngate_25od28_mac, tndiff)) / 2
   L=area(dngate_25od28_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25od28) ngate_25od28_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25od28_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25od28_mac, tndiff ) + perimeter_inside(ngate_25od28_mac, tndiff)) / 2
   L=area(ngate_25od28_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25od) ngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25od_mac, tndiff ) + perimeter_inside(ngate_25od_mac, tndiff)) / 2
   L=area(ngate_25od_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25ud) ngate_25ud poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25ud, tndiff ) + perimeter_inside(ngate_25ud, tndiff)) / 2
   L=area(ngate_25ud) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25ud) ngate_25ud_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25ud_mac, tndiff ) + perimeter_inside(ngate_25ud_mac, tndiff)) / 2
   L=area(ngate_25ud_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_33) ngate_33 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_33, tndiff ) + perimeter_inside(ngate_33, tndiff)) / 2
   L=area(ngate_33) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_33_dnw) dngate_33 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_33, tndiff ) + perimeter_inside(dngate_33, tndiff)) / 2
   L=area(dngate_33) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_33_dnw) dngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_33_mac, tndiff ) + perimeter_inside(dngate_33_mac, tndiff)) / 2
   L=area(dngate_33_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_33) ngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_33_mac, tndiff ) + perimeter_inside(ngate_33_mac, tndiff)) / 2
   L=area(ngate_33_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

nrgatez1 = SIZE nrgate BY 0.005
nrgatez = nrgatez1 AND nthin1
DEVICE MN(nch_dnw) nrgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch CMACRO dfm_nmos_core

DEVICE MN(nch_dnw_1tr) ngate_1tr poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nch_1tr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_1tr, tndiff ) + perimeter_inside(ngate_1tr, tndiff)) / 2
   L=area(ngate_1tr) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

nrgate_macz1 = SIZE nrgate_mac BY 0.005
nrgate_macz = nrgate_macz1 AND nthin1
DEVICE MN(nch_dnw) nrgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_mac netlist element "X" CMACRO dfm_nmos_core

DEVICE MN(nch_dnw_w) ngate_dnw_w poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_w [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_dnw_w, tndiff ) + perimeter_inside(ngate_dnw_w, tndiff)) / 2
   L=area(ngate_dnw_w) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_dnw_w_lvt) ngate_dnw_w_lvt poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nch_w_lvt [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_dnw_w_lvt, tndiff ) + perimeter_inside(ngate_dnw_w_lvt, tndiff)) / 2
   L=area(ngate_dnw_w_lvt) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nch_esd18) ngate_esd18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_esd18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_esd18, tndiff ) + perimeter_inside(ngate_esd18, tndiff)) / 2
   L=area(ngate_esd18) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_esd18_dnw) dngate_esd18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_esd18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_esd18, tndiff ) + perimeter_inside(dngate_esd18, tndiff)) / 2
   L=area(dngate_esd18) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_esd18_dnw) dngate_esd18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_esd18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_esd18_mac, tndiff ) + perimeter_inside(dngate_esd18_mac, tndiff)) / 2
   L=area(dngate_esd18_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_esd18) ngate_esd18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_esd18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_esd18_mac, tndiff ) + perimeter_inside(ngate_esd18_mac, tndiff)) / 2
   L=area(ngate_esd18_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

nhvgatez1 = SIZE nhvgate BY 0.005
nhvgatez = nhvgatez1 AND nthin1
DEVICE MN(nch_hvt) nhvgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_hvt CMACRO dfm_nmos_core

n1hvgatez1 = SIZE n1hvgate BY 0.005
n1hvgatez = n1hvgatez1 AND nthin1
DEVICE MN(nch_hvt_dnw) n1hvgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_hvt CMACRO dfm_nmos_core

n1hvgate_macz1 = SIZE n1hvgate_mac BY 0.005
n1hvgate_macz = n1hvgate_macz1 AND nthin1
DEVICE MN(nch_hvt_dnw) n1hvgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_hvt_mac netlist element "X" CMACRO dfm_nmos_core

nhvgate_macz1 = SIZE nhvgate_mac BY 0.005
nhvgate_macz = nhvgate_macz1 AND nthin1
DEVICE MN(nch_hvt) nhvgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_hvt_mac netlist element "X" CMACRO dfm_nmos_core

ngatelpgz1 = SIZE ngatelpg BY 0.005
ngatelpgz = ngatelpgz1 AND nthin1
DEVICE MN(nch_lpg) ngatelpgz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_lpg CMACRO dfm_nmos_core

nhvgatelpgz1 = SIZE nhvgatelpg BY 0.005
nhvgatelpgz = nhvgatelpgz1 AND nthin1
DEVICE MN(nch_lpghvt) nhvgatelpgz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_lpghvt CMACRO dfm_nmos_core

DEVICE MN(nch_lpgna) nlgatelpg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_lpgna [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(nlgatelpg, tndiff ) + perimeter_inside(nlgatelpg, tndiff)) / 2
   L=area(nlgatelpg) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

nlvgatez1 = SIZE nlvgate BY 0.005
nlvgatez = nlvgatez1 AND nthin1
DEVICE MN(nch_lvt) nlvgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_lvt CMACRO dfm_nmos_core

n1lvgatez1 = SIZE n1lvgate BY 0.005
n1lvgatez = n1lvgatez1 AND nthin1
DEVICE MN(nch_lvt_dnw) n1lvgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_lvt CMACRO dfm_nmos_core

n1lvgate_macz1 = SIZE n1lvgate_mac BY 0.005
n1lvgate_macz = n1lvgate_macz1 AND nthin1
DEVICE MN(nch_lvt_dnw) n1lvgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_lvt_mac netlist element "X" CMACRO dfm_nmos_core

nlvgate_macz1 = SIZE nlvgate_mac BY 0.005
nlvgate_macz = nlvgate_macz1 AND nthin1
DEVICE MN(nch_lvt) nlvgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_lvt_mac netlist element "X" CMACRO dfm_nmos_core

ngate_macz1 = SIZE ngate_mac BY 0.005
ngate_macz = ngate_macz1 AND nthin1
DEVICE MN(nch) ngate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_mac netlist element "X" CMACRO dfm_nmos_core

nilvtgatez1 = SIZE nilvtgate BY 0.005
nilvtgatez = nilvtgatez1 AND nthin1
DEVICE MN(nch_mlvt) nilvtgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_mlvt CMACRO dfm_nmos_core

n1ilvtgatez1 = SIZE n1ilvtgate BY 0.005
n1ilvtgatez = n1ilvtgatez1 AND nthin1
DEVICE MN(nch_mlvt_dnw) n1ilvtgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_mlvt CMACRO dfm_nmos_core

n1ilvtgate_macz1 = SIZE n1ilvtgate_mac BY 0.005
n1ilvtgate_macz = n1ilvtgate_macz1 AND nthin1
DEVICE MN(nch_mlvt_dnw) n1ilvtgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_mlvt_mac netlist element "X" CMACRO dfm_nmos_core

nilvtgate_macz1 = SIZE nilvtgate_mac BY 0.005
nilvtgate_macz = nilvtgate_macz1 AND nthin1
DEVICE MN(nch_mlvt) nilvtgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_mlvt_mac netlist element "X" CMACRO dfm_nmos_core

DEVICE MN(nch_na) nlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(nlgate, tndiff ) + perimeter_inside(nlgate, tndiff)) / 2
   L=area(nlgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na18) ngate_18na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_18na, tndiff ) + perimeter_inside(ngate_18na, tndiff)) / 2
   L=area(ngate_18na) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na18) ngate_18na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_18na_mac, tndiff ) + perimeter_inside(ngate_18na_mac, tndiff)) / 2
   L=area(ngate_18na_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na25) ngate_25na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25na, tndiff ) + perimeter_inside(ngate_25na, tndiff)) / 2
   L=area(ngate_25na) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na25) ngate_25na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25na_mac, tndiff ) + perimeter_inside(ngate_25na_mac, tndiff)) / 2
   L=area(ngate_25na_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na25od) ngate_25naod poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na25od33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25naod, tndiff ) + perimeter_inside(ngate_25naod, tndiff)) / 2
   L=area(ngate_25naod) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na25od) ngate_25naod_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na25od33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25naod_mac, tndiff ) + perimeter_inside(ngate_25naod_mac, tndiff)) / 2
   L=area(ngate_25naod_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na25ud) ngate_25naud poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25naud, tndiff ) + perimeter_inside(ngate_25naud, tndiff)) / 2
   L=area(ngate_25naud) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na25ud) ngate_25naud_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25naud_mac, tndiff ) + perimeter_inside(ngate_25naud_mac, tndiff)) / 2
   L=area(ngate_25naud_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na33) ngate_33na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_33na, tndiff ) + perimeter_inside(ngate_33na, tndiff)) / 2
   L=area(ngate_33na) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na33) ngate_33na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_33na_mac, tndiff ) + perimeter_inside(ngate_33na_mac, tndiff)) / 2
   L=area(ngate_33na_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na) nlgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> netlist model nch_na_mac netlist element "X" [
  property sa,sb,W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(nlgate_mac, tndiff ) + perimeter_inside(nlgate_mac, tndiff)) / 2
   L=area(nlgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nch_timer) ngate_st poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_timer [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_st, tndiff ) + perimeter_inside(ngate_st, tndiff)) / 2
   L=area(ngate_st) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

nuhvgatez1 = SIZE nuhvgate BY 0.005
nuhvgatez = nuhvgatez1 AND nthin1
DEVICE MN(nch_uhvt) nuhvgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_uhvt CMACRO dfm_nmos_core

n1uhvgatez1 = SIZE n1uhvgate BY 0.005
n1uhvgatez = n1uhvgatez1 AND nthin1
DEVICE MN(nch_uhvt_dnw) n1uhvgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_uhvt CMACRO dfm_nmos_core

n1uhvgate_macz1 = SIZE n1uhvgate_mac BY 0.005
n1uhvgate_macz = n1uhvgate_macz1 AND nthin1
DEVICE MN(nch_uhvt_dnw) n1uhvgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_uhvt_mac netlist element "X" CMACRO dfm_nmos_core

nuhvgate_macz1 = SIZE nuhvgate_mac BY 0.005
nuhvgate_macz = nuhvgate_macz1 AND nthin1
DEVICE MN(nch_uhvt) nuhvgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_uhvt_mac netlist element "X" CMACRO dfm_nmos_core

nuvgatez1 = SIZE nuvgate BY 0.005
nuvgatez = nuvgatez1 AND nthin1
DEVICE MN(nch_ulvt) nuvgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_ulvt CMACRO dfm_nmos_core

n1uvgatez1 = SIZE n1uvgate BY 0.005
n1uvgatez = n1uvgatez1 AND nthin1
DEVICE MN(nch_ulvt_dnw) n1uvgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_ulvt CMACRO dfm_nmos_core

n1uvgate_macz1 = SIZE n1uvgate_mac BY 0.005
n1uvgate_macz = n1uvgate_macz1 AND nthin1
DEVICE MN(nch_ulvt_dnw) n1uvgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_ulvt_mac netlist element "X" CMACRO dfm_nmos_core

nuvgate_macz1 = SIZE nuvgate_mac BY 0.005
nuvgate_macz = nuvgate_macz1 AND nthin1
DEVICE MN(nch_ulvt) nuvgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_ulvt_mac netlist element "X" CMACRO dfm_nmos_core

DEVICE MN(nch_w) ngate_w1t poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_w [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_w1t, tndiff ) + perimeter_inside(ngate_w1t, tndiff)) / 2
   L=area(ngate_w1t) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_w_lvt) ngate_w1t_lvt poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nch_w_lvt [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_w1t_lvt, tndiff ) + perimeter_inside(ngate_w1t_lvt, tndiff)) / 2
   L=area(ngate_w1t_lvt) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_dphcsr) ngate_spddphc poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_dphcsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spddphc, tndiff ) + perimeter_inside(ngate_spddphc, tndiff)) / 2
   L=area(ngate_spddphc) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_dpsr) ngate_spddp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_dpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spddp, tndiff ) + perimeter_inside(ngate_spddp, tndiff)) / 2
   L=area(ngate_spddp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_hvtdphcsr) ngate_hvspddphc poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_hvtdphcsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_hvspddphc, tndiff ) + perimeter_inside(ngate_hvspddphc, tndiff)) / 2
   L=area(ngate_hvspddphc) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_hvtdpsr) ngate_hvspddp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_hvtdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_hvspddp, tndiff ) + perimeter_inside(ngate_hvspddp, tndiff)) / 2
   L=area(ngate_hvspddp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_hvtsr) ngate_hvspd poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_hvtsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_hvspd, tndiff ) + perimeter_inside(ngate_hvspd, tndiff)) / 2
   L=area(ngate_hvspd) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_lpgdpsr) ngate_spdlpgdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_lpgdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spdlpgdp, tndiff ) + perimeter_inside(ngate_spdlpgdp, tndiff)) / 2
   L=area(ngate_spdlpgdp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_lpgsr) ngate_spdlpg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_lpgsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spdlpg, tndiff ) + perimeter_inside(ngate_spdlpg, tndiff)) / 2
   L=area(ngate_spdlpg) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_lpgtpsr) ngate_spdlpgtp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_lpgtpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spdlpgtp, tndiff ) + perimeter_inside(ngate_spdlpgtp, tndiff)) / 2
   L=area(ngate_spdlpgtp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_sr) ngate_spd poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_sr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spd, tndiff ) + perimeter_inside(ngate_spd, tndiff)) / 2
   L=area(ngate_spd) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_ulpdpsr) ngate_spdulpdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_ulpdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spdulpdp, tndiff ) + perimeter_inside(ngate_spdulpdp, tndiff)) / 2
   L=area(ngate_spdulpdp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_ulpsr) ngate_spdulp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_ulpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spdulp, tndiff ) + perimeter_inside(ngate_spdulp, tndiff)) / 2
   L=area(ngate_spdulp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_wisr) ngate_spdwi poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_wisr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spdwi, tndiff ) + perimeter_inside(ngate_spdwi, tndiff)) / 2
   L=area(ngate_spdwi) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_wosr) ngate_spdwo poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_wosr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spdwo, tndiff ) + perimeter_inside(ngate_spdwo, tndiff)) / 2
   L=area(ngate_spdwo) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_dphcsr) ngate_spgdphc poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_dphcsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spgdphc, tndiff ) + perimeter_inside(ngate_spgdphc, tndiff)) / 2
   L=area(ngate_spgdphc) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_dpsr) ngate_spgdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_dpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spgdp, tndiff ) + perimeter_inside(ngate_spgdp, tndiff)) / 2
   L=area(ngate_spgdp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_hvtdphcsr) ngate_hvspgdphc poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_hvtdphcsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_hvspgdphc, tndiff ) + perimeter_inside(ngate_hvspgdphc, tndiff)) / 2
   L=area(ngate_hvspgdphc) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_hvtdpsr) ngate_hvspgdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_hvtdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_hvspgdp, tndiff ) + perimeter_inside(ngate_hvspgdp, tndiff)) / 2
   L=area(ngate_hvspgdp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_hvtsr) ngate_hvspg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_hvtsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_hvspg, tndiff ) + perimeter_inside(ngate_hvspg, tndiff)) / 2
   L=area(ngate_hvspg) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_lpgdpsr) ngate_spglpgdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_lpgdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spglpgdp, tndiff ) + perimeter_inside(ngate_spglpgdp, tndiff)) / 2
   L=area(ngate_spglpgdp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_lpgsr) ngate_spglpg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_lpgsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spglpg, tndiff ) + perimeter_inside(ngate_spglpg, tndiff)) / 2
   L=area(ngate_spglpg) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_lpgtpsr) ngate_spglpgtp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_lpgtpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spglpgtp, tndiff ) + perimeter_inside(ngate_spglpgtp, tndiff)) / 2
   L=area(ngate_spglpgtp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_sr) ngate_spg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_sr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spg, tndiff ) + perimeter_inside(ngate_spg, tndiff)) / 2
   L=area(ngate_spg) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_ulpdpsr) ngate_spgulpdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_ulpdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spgulpdp, tndiff ) + perimeter_inside(ngate_spgulpdp, tndiff)) / 2
   L=area(ngate_spgulpdp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_ulpsr) ngate_spgulp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_ulpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spgulp, tndiff ) + perimeter_inside(ngate_spgulp, tndiff)) / 2
   L=area(ngate_spgulp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_wisr) ngate_spgwi poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_wisr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spgwi, tndiff ) + perimeter_inside(ngate_spgwi, tndiff)) / 2
   L=area(ngate_spgwi) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_wosr) ngate_spgwo poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_wosr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spgwo, tndiff ) + perimeter_inside(ngate_spgwo, tndiff)) / 2
   L=area(ngate_spgwo) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

pgatez1 = SIZE pgate BY 0.005
pgatez = pgatez1 AND pthin
DEVICE MP(pch) pgatez poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch CMACRO dfm_pmos

DEVICE MP(pch_18) pgate_18 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_18, tpdiff ) + perimeter_inside(pgate_18, tpdiff)) / 2
   L=area(pgate_18) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_18) pgate_18_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_18_mac, tpdiff ) + perimeter_inside(pgate_18_mac, tpdiff)) / 2
   L=area(pgate_18_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25) pgate_25 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_25, tpdiff ) + perimeter_inside(pgate_25, tpdiff)) / 2
   L=area(pgate_25) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25) pgate_25_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_25_mac, tpdiff ) + perimeter_inside(pgate_25_mac, tpdiff)) / 2
   L=area(pgate_25_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25od) pgate_25od poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_25od, tpdiff ) + perimeter_inside(pgate_25od, tpdiff)) / 2
   L=area(pgate_25od) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25od28) pgate_25od28 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_25od28 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_25od28, tpdiff ) + perimeter_inside(pgate_25od28, tpdiff)) / 2
   L=area(pgate_25od28) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25od28) pgate_25od28_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_25od28_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_25od28_mac, tpdiff ) + perimeter_inside(pgate_25od28_mac, tpdiff)) / 2
   L=area(pgate_25od28_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25od) pgate_25od_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_25od_mac, tpdiff ) + perimeter_inside(pgate_25od_mac, tpdiff)) / 2
   L=area(pgate_25od_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25ud) pgate_25ud poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_25ud, tpdiff ) + perimeter_inside(pgate_25ud, tpdiff)) / 2
   L=area(pgate_25ud) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25ud) pgate_25ud_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_25ud_mac, tpdiff ) + perimeter_inside(pgate_25ud_mac, tpdiff)) / 2
   L=area(pgate_25ud_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_33) pgate_33 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pIO_WPEPROP> netlist model pch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_33, tpdiff ) + perimeter_inside(pgate_33, tpdiff)) / 2
   L=area(pgate_33) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_33) pgate_33_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pIO_WPEPROP> netlist model pch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_33_mac, tpdiff ) + perimeter_inside(pgate_33_mac, tpdiff)) / 2
   L=area(pgate_33_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_edc) pgate_1tr poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_edc [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_1tr, tpdiff ) + perimeter_inside(pgate_1tr, tpdiff)) / 2
   L=area(pgate_1tr) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

phvgatez1 = SIZE phvgate BY 0.005
phvgatez = phvgatez1 AND pthin
DEVICE MP(pch_hvt) phvgatez poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_hvt CMACRO dfm_pmos

phvgate_macz1 = SIZE phvgate_mac BY 0.005
phvgate_macz = phvgate_macz1 AND pthin
DEVICE MP(pch_hvt) phvgate_macz poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_hvt_mac netlist element "X" CMACRO dfm_pmos

pgatelpgz1 = SIZE pgatelpg BY 0.005
pgatelpgz = pgatelpgz1 AND pthin
DEVICE MP(pch_lpg) pgatelpgz poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_lpg CMACRO dfm_pmos

phvgatelpgz1 = SIZE phvgatelpg BY 0.005
phvgatelpgz = phvgatelpgz1 AND pthin
DEVICE MP(pch_lpghvt) phvgatelpgz poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_lpghvt CMACRO dfm_pmos

plvgatez1 = SIZE plvgate BY 0.005
plvgatez = plvgatez1 AND pthin
DEVICE MP(pch_lvt) plvgatez poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_lvt CMACRO dfm_pmos

plvgate_macz1 = SIZE plvgate_mac BY 0.005
plvgate_macz = plvgate_macz1 AND pthin
DEVICE MP(pch_lvt) plvgate_macz poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_lvt_mac netlist element "X" CMACRO dfm_pmos

pgate_macz1 = SIZE pgate_mac BY 0.005
pgate_macz = pgate_macz1 AND pthin
DEVICE MP(pch) pgate_macz poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_mac netlist element "X" CMACRO dfm_pmos

pilvtgatez1 = SIZE pilvtgate BY 0.005
pilvtgatez = pilvtgatez1 AND pthin
DEVICE MP(pch_mlvt) pilvtgatez poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_mlvt CMACRO dfm_pmos

pilvtgate_macz1 = SIZE pilvtgate_mac BY 0.005
pilvtgate_macz = pilvtgate_macz1 AND pthin
DEVICE MP(pch_mlvt) pilvtgate_macz poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_mlvt_mac netlist element "X" CMACRO dfm_pmos

DEVICE MP(pch_timer) pgate_st poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_timer [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_st, tpdiff ) + perimeter_inside(pgate_st, tpdiff)) / 2
   L=area(pgate_st) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

puhvgatez1 = SIZE puhvgate BY 0.005
puhvgatez = puhvgatez1 AND pthin
DEVICE MP(pch_uhvt) puhvgatez poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_uhvt CMACRO dfm_pmos

puhvgate_macz1 = SIZE puhvgate_mac BY 0.005
puhvgate_macz = puhvgate_macz1 AND pthin
DEVICE MP(pch_uhvt) puhvgate_macz poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_uhvt_mac netlist element "X" CMACRO dfm_pmos

puvgatez1 = SIZE puvgate BY 0.005
puvgatez = puvgatez1 AND pthin
DEVICE MP(pch_ulvt) puvgatez poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_ulvt CMACRO dfm_pmos

puvgate_macz1 = SIZE puvgate_mac BY 0.005
puvgate_macz = puvgate_macz1 AND pthin
DEVICE MP(pch_ulvt) puvgate_macz poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_ulvt_mac netlist element "X" CMACRO dfm_pmos

DEVICE MP(pch_w) pgate_w1t poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_w [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_w1t, tpdiff ) + perimeter_inside(pgate_w1t, tpdiff)) / 2
   L=area(pgate_w1t) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_w_lvt) pgate_w1t_lvt poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pch_w_lvt [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_w1t_lvt, tpdiff ) + perimeter_inside(pgate_w1t_lvt, tpdiff)) / 2
   L=area(pgate_w1t_lvt) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_dphcsr) pgate_sdphc poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_dphcsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_sdphc, tpdiff ) + perimeter_inside(pgate_sdphc, tpdiff)) / 2
   L=area(pgate_sdphc) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_dpsr) pgate_sdp poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_dpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_sdp, tpdiff ) + perimeter_inside(pgate_sdp, tpdiff)) / 2
   L=area(pgate_sdp) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_hvtdphcsr) pgate_hvsdphc poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_hvtdphcsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_hvsdphc, tpdiff ) + perimeter_inside(pgate_hvsdphc, tpdiff)) / 2
   L=area(pgate_hvsdphc) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_hvtdpsr) pgate_hvsdp poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_hvtdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_hvsdp, tpdiff ) + perimeter_inside(pgate_hvsdp, tpdiff)) / 2
   L=area(pgate_hvsdp) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_hvtsr) pgate_hvs poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_hvtsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_hvs, tpdiff ) + perimeter_inside(pgate_hvs, tpdiff)) / 2
   L=area(pgate_hvs) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_lpgdpsr) pgate_sdplpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_lpgdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_sdplpg, tpdiff ) + perimeter_inside(pgate_sdplpg, tpdiff)) / 2
   L=area(pgate_sdplpg) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_lpgsr) pgate_slpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_lpgsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_slpg, tpdiff ) + perimeter_inside(pgate_slpg, tpdiff)) / 2
   L=area(pgate_slpg) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_lpgtpsr) pgate_stplpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_lpgtpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_stplpg, tpdiff ) + perimeter_inside(pgate_stplpg, tpdiff)) / 2
   L=area(pgate_stplpg) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_sr) pgate_s poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_sr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_s, tpdiff ) + perimeter_inside(pgate_s, tpdiff)) / 2
   L=area(pgate_s) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_ulpdpsr) pgate_sdpulp poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_ulpdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_sdpulp, tpdiff ) + perimeter_inside(pgate_sdpulp, tpdiff)) / 2
   L=area(pgate_sdpulp) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_ulpsr) pgate_sulp poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_ulpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_sulp, tpdiff ) + perimeter_inside(pgate_sulp, tpdiff)) / 2
   L=area(pgate_sulp) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_wisr) pgate_swi poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_wisr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_swi, tpdiff ) + perimeter_inside(pgate_swi, tpdiff)) / 2
   L=area(pgate_swi) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_wosr) pgate_swo poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_wosr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_swo, tpdiff ) + perimeter_inside(pgate_swo, tpdiff)) / 2
   L=area(pgate_swo) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]


#ELSE
DEVICE LDDP(pch_hv25_spw) pgate_25hvd d_pd25hvd(D) poly(G) s_pd25hvd(S) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_hv25_spw netlist element "M" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_25hvd, s_pd25hvd ) + perimeter_coincide(pgate_25hvd, d_pd25hvd)) / 2
   L = area(pgate_25hvd) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE LDDP(pch_hv25_spw) pgate_25hvd_mac d_pd25hvd(D) poly(G) s_pd25hvd(S) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_hv25_spw_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_25hvd_mac, s_pd25hvd ) + perimeter_coincide(pgate_25hvd_mac, d_pd25hvd)) / 2
   L = area(pgate_25hvd_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE LDDN(nch_hv25_snw) ngate_25hvdw d_nd25hvdw(D) poly(G) s_nd25hvdw(S) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_hv25_snw netlist element "M" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25hvdw, s_nd25hvdw ) + perimeter_coincide(ngate_25hvdw, d_nd25hvdw)) / 2
   L = area(ngate_25hvdw) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE LDDN(nch_hv25_snw) ngate_25hvdw_mac d_nd25hvdw(D) poly(G) s_nd25hvdw(S) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_hv25_snw_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25hvdw_mac, s_nd25hvdw ) + perimeter_coincide(ngate_25hvdw_mac, d_nd25hvdw)) / 2
   L = area(ngate_25hvdw_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch) ngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate, tndiff ) + perimeter_inside(ngate, tndiff)) / 2
   L = area(ngate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_18) ngate_18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_18, tndiff ) + perimeter_inside(ngate_18, tndiff)) / 2
   L = area(ngate_18) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_18_dnw) dngate_18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_18, tndiff ) + perimeter_inside(dngate_18, tndiff)) / 2
   L = area(dngate_18) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_18_dnw) dngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_18_mac, tndiff ) + perimeter_inside(dngate_18_mac, tndiff)) / 2
   L = area(dngate_18_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_18) ngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_18_mac, tndiff ) + perimeter_inside(ngate_18_mac, tndiff)) / 2
   L = area(ngate_18_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25) ngate_25 poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25, tndiff ) + perimeter_inside(ngate_25, tndiff)) / 2
   L = area(ngate_25) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25_dnw) dngate_25 poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_25, tndiff ) + perimeter_inside(dngate_25, tndiff)) / 2
   L = area(dngate_25) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25_dnw) dngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_25_mac, tndiff ) + perimeter_inside(dngate_25_mac, tndiff)) / 2
   L = area(dngate_25_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25_dnwod) dngate_25od poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_25od, tndiff ) + perimeter_inside(dngate_25od, tndiff)) / 2
   L = area(dngate_25od) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25_dnwod) dngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_25od_mac, tndiff ) + perimeter_inside(dngate_25od_mac, tndiff)) / 2
   L = area(dngate_25od_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25_dnwud) dngate_25ud poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_25ud, tndiff ) + perimeter_inside(dngate_25ud, tndiff)) / 2
   L = area(dngate_25ud) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25_dnwud) dngate_25ud_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_25ud_mac, tndiff ) + perimeter_inside(dngate_25ud_mac, tndiff)) / 2
   L = area(dngate_25ud_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25) ngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25_mac, tndiff ) + perimeter_inside(ngate_25_mac, tndiff)) / 2
   L = area(ngate_25_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25od) ngate_25od poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25od, tndiff ) + perimeter_inside(ngate_25od, tndiff)) / 2
   L = area(ngate_25od) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25od28) ngate_25od28 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25od28 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25od28, tndiff ) + perimeter_inside(ngate_25od28, tndiff)) / 2
   L = area(ngate_25od28) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25od28_dnw) dngate_25od28 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25od28 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_25od28, tndiff ) + perimeter_inside(dngate_25od28, tndiff)) / 2
   L = area(dngate_25od28) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25od28_dnw) dngate_25od28_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25od28_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_25od28_mac, tndiff ) + perimeter_inside(dngate_25od28_mac, tndiff)) / 2
   L = area(dngate_25od28_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25od28) ngate_25od28_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_25od28_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25od28_mac, tndiff ) + perimeter_inside(ngate_25od28_mac, tndiff)) / 2
   L = area(ngate_25od28_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25od) ngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25od_mac, tndiff ) + perimeter_inside(ngate_25od_mac, tndiff)) / 2
   L = area(ngate_25od_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25ud) ngate_25ud poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25ud, tndiff ) + perimeter_inside(ngate_25ud, tndiff)) / 2
   L = area(ngate_25ud) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_25ud) ngate_25ud_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25ud_mac, tndiff ) + perimeter_inside(ngate_25ud_mac, tndiff)) / 2
   L = area(ngate_25ud_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_33) ngate_33 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_33, tndiff ) + perimeter_inside(ngate_33, tndiff)) / 2
   L = area(ngate_33) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_33_dnw) dngate_33 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_33, tndiff ) + perimeter_inside(dngate_33, tndiff)) / 2
   L = area(dngate_33) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_33_dnw) dngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_33_mac, tndiff ) + perimeter_inside(dngate_33_mac, tndiff)) / 2
   L = area(dngate_33_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_33) ngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_33_mac, tndiff ) + perimeter_inside(ngate_33_mac, tndiff)) / 2
   L = area(ngate_33_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_dnw) nrgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nrgate, tndiff ) + perimeter_inside(nrgate, tndiff)) / 2
   L = area(nrgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_dnw_1tr) ngate_1tr poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nch_1tr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_1tr, tndiff ) + perimeter_inside(ngate_1tr, tndiff)) / 2
   L = area(ngate_1tr) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nch_dnw) nrgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nrgate_mac, tndiff ) + perimeter_inside(nrgate_mac, tndiff)) / 2
   L = area(nrgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_dnw_w) ngate_dnw_w poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_w [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_dnw_w, tndiff ) + perimeter_inside(ngate_dnw_w, tndiff)) / 2
   L = area(ngate_dnw_w) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_dnw_w_lvt) ngate_dnw_w_lvt poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nch_w_lvt [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_dnw_w_lvt, tndiff ) + perimeter_inside(ngate_dnw_w_lvt, tndiff)) / 2
   L = area(ngate_dnw_w_lvt) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nch_esd18) ngate_esd18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_esd18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_esd18, tndiff ) + perimeter_inside(ngate_esd18, tndiff)) / 2
   L = area(ngate_esd18) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_esd18_dnw) dngate_esd18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_esd18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_esd18, tndiff ) + perimeter_inside(dngate_esd18, tndiff)) / 2
   L = area(dngate_esd18) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_esd18_dnw) dngate_esd18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_esd18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_esd18_mac, tndiff ) + perimeter_inside(dngate_esd18_mac, tndiff)) / 2
   L = area(dngate_esd18_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_esd18) ngate_esd18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nIO_WPEPROP> netlist model nch_esd18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_esd18_mac, tndiff ) + perimeter_inside(ngate_esd18_mac, tndiff)) / 2
   L = area(ngate_esd18_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_hvt) nhvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_hvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nhvgate, tndiff ) + perimeter_inside(nhvgate, tndiff)) / 2
   L = area(nhvgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_hvt_dnw) n1hvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_hvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1hvgate, tndiff ) + perimeter_inside(n1hvgate, tndiff)) / 2
   L = area(n1hvgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_hvt_dnw) n1hvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_hvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1hvgate_mac, tndiff ) + perimeter_inside(n1hvgate_mac, tndiff)) / 2
   L = area(n1hvgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_hvt) nhvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_hvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nhvgate_mac, tndiff ) + perimeter_inside(nhvgate_mac, tndiff)) / 2
   L = area(nhvgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_lpg) ngatelpg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_lpg [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngatelpg, tndiff ) + perimeter_inside(ngatelpg, tndiff)) / 2
   L = area(ngatelpg) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_lpghvt) nhvgatelpg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_lpghvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nhvgatelpg, tndiff ) + perimeter_inside(nhvgatelpg, tndiff)) / 2
   L = area(nhvgatelpg) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_lpgna) nlgatelpg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_lpgna [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nlgatelpg, tndiff ) + perimeter_inside(nlgatelpg, tndiff)) / 2
   L = area(nlgatelpg) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_lvt) nlvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_lvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nlvgate, tndiff ) + perimeter_inside(nlvgate, tndiff)) / 2
   L = area(nlvgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_lvt_dnw) n1lvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_lvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1lvgate, tndiff ) + perimeter_inside(n1lvgate, tndiff)) / 2
   L = area(n1lvgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_lvt_dnw) n1lvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_lvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1lvgate_mac, tndiff ) + perimeter_inside(n1lvgate_mac, tndiff)) / 2
   L = area(n1lvgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_lvt) nlvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_lvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nlvgate_mac, tndiff ) + perimeter_inside(nlvgate_mac, tndiff)) / 2
   L = area(nlvgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch) ngate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_mac, tndiff ) + perimeter_inside(ngate_mac, tndiff)) / 2
   L = area(ngate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_mlvt) nilvtgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_mlvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nilvtgate, tndiff ) + perimeter_inside(nilvtgate, tndiff)) / 2
   L = area(nilvtgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_mlvt_dnw) n1ilvtgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_mlvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1ilvtgate, tndiff ) + perimeter_inside(n1ilvtgate, tndiff)) / 2
   L = area(n1ilvtgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_mlvt_dnw) n1ilvtgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_mlvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1ilvtgate_mac, tndiff ) + perimeter_inside(n1ilvtgate_mac, tndiff)) / 2
   L = area(n1ilvtgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_mlvt) nilvtgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_mlvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nilvtgate_mac, tndiff ) + perimeter_inside(nilvtgate_mac, tndiff)) / 2
   L = area(nilvtgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na) nlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nlgate, tndiff ) + perimeter_inside(nlgate, tndiff)) / 2
   L = area(nlgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na18) ngate_18na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_18na, tndiff ) + perimeter_inside(ngate_18na, tndiff)) / 2
   L = area(ngate_18na) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na18) ngate_18na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_18na_mac, tndiff ) + perimeter_inside(ngate_18na_mac, tndiff)) / 2
   L = area(ngate_18na_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na25) ngate_25na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25na, tndiff ) + perimeter_inside(ngate_25na, tndiff)) / 2
   L = area(ngate_25na) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na25) ngate_25na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25na_mac, tndiff ) + perimeter_inside(ngate_25na_mac, tndiff)) / 2
   L = area(ngate_25na_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na25od) ngate_25naod poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na25od33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25naod, tndiff ) + perimeter_inside(ngate_25naod, tndiff)) / 2
   L = area(ngate_25naod) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na25od) ngate_25naod_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na25od33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25naod_mac, tndiff ) + perimeter_inside(ngate_25naod_mac, tndiff)) / 2
   L = area(ngate_25naod_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na25ud) ngate_25naud poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25naud, tndiff ) + perimeter_inside(ngate_25naud, tndiff)) / 2
   L = area(ngate_25naud) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na25ud) ngate_25naud_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25naud_mac, tndiff ) + perimeter_inside(ngate_25naud_mac, tndiff)) / 2
   L = area(ngate_25naud_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na33) ngate_33na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_33na, tndiff ) + perimeter_inside(ngate_33na, tndiff)) / 2
   L = area(ngate_33na) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na33) ngate_33na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nt_n_WPEPROP> netlist model nch_na33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_33na_mac, tndiff ) + perimeter_inside(ngate_33na_mac, tndiff)) / 2
   L = area(ngate_33na_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nt_n_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_na) nlgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> netlist model nch_na_mac netlist element "X" [
  property sa,sb,W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(nlgate_mac, tndiff ) + perimeter_inside(nlgate_mac, tndiff)) / 2
   L = area(nlgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nch_timer) ngate_st poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_timer [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_st, tndiff ) + perimeter_inside(ngate_st, tndiff)) / 2
   L = area(ngate_st) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_uhvt) nuhvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_uhvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nuhvgate, tndiff ) + perimeter_inside(nuhvgate, tndiff)) / 2
   L = area(nuhvgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_uhvt_dnw) n1uhvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_uhvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1uhvgate, tndiff ) + perimeter_inside(n1uhvgate, tndiff)) / 2
   L = area(n1uhvgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_uhvt_dnw) n1uhvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_uhvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1uhvgate_mac, tndiff ) + perimeter_inside(n1uhvgate_mac, tndiff)) / 2
   L = area(n1uhvgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_uhvt) nuhvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_uhvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nuhvgate_mac, tndiff ) + perimeter_inside(nuhvgate_mac, tndiff)) / 2
   L = area(nuhvgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_ulvt) nuvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_ulvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nuvgate, tndiff ) + perimeter_inside(nuvgate, tndiff)) / 2
   L = area(nuvgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_ulvt_dnw) n1uvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_ulvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1uvgate, tndiff ) + perimeter_inside(n1uvgate, tndiff)) / 2
   L = area(n1uvgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_ulvt_dnw) n1uvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_ulvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1uvgate_mac, tndiff ) + perimeter_inside(n1uvgate_mac, tndiff)) / 2
   L = area(n1uvgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_ulvt) nuvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_ulvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nuvgate_mac, tndiff ) + perimeter_inside(nuvgate_mac, tndiff)) / 2
   L = area(nuvgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_w) ngate_w1t poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <lod_PROP> <nCore_WPEPROP> netlist model nch_w [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_w1t, tndiff ) + perimeter_inside(ngate_w1t, tndiff)) / 2
   L = area(ngate_w1t) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( nCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( nCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( nCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MN(nch_w_lvt) ngate_w1t_lvt poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nch_w_lvt [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_w1t_lvt, tndiff ) + perimeter_inside(ngate_w1t_lvt, tndiff)) / 2
   L = area(ngate_w1t_lvt) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_dphcsr) ngate_spddphc poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_dphcsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spddphc, tndiff ) + perimeter_inside(ngate_spddphc, tndiff)) / 2
   L = area(ngate_spddphc) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_dpsr) ngate_spddp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_dpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spddp, tndiff ) + perimeter_inside(ngate_spddp, tndiff)) / 2
   L = area(ngate_spddp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_hvtdphcsr) ngate_hvspddphc poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_hvtdphcsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_hvspddphc, tndiff ) + perimeter_inside(ngate_hvspddphc, tndiff)) / 2
   L = area(ngate_hvspddphc) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_hvtdpsr) ngate_hvspddp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_hvtdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_hvspddp, tndiff ) + perimeter_inside(ngate_hvspddp, tndiff)) / 2
   L = area(ngate_hvspddp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_hvtsr) ngate_hvspd poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_hvtsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_hvspd, tndiff ) + perimeter_inside(ngate_hvspd, tndiff)) / 2
   L = area(ngate_hvspd) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_lpgdpsr) ngate_spdlpgdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_lpgdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spdlpgdp, tndiff ) + perimeter_inside(ngate_spdlpgdp, tndiff)) / 2
   L = area(ngate_spdlpgdp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_lpgsr) ngate_spdlpg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_lpgsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spdlpg, tndiff ) + perimeter_inside(ngate_spdlpg, tndiff)) / 2
   L = area(ngate_spdlpg) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_lpgtpsr) ngate_spdlpgtp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_lpgtpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spdlpgtp, tndiff ) + perimeter_inside(ngate_spdlpgtp, tndiff)) / 2
   L = area(ngate_spdlpgtp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_sr) ngate_spd poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_sr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spd, tndiff ) + perimeter_inside(ngate_spd, tndiff)) / 2
   L = area(ngate_spd) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_ulpdpsr) ngate_spdulpdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_ulpdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spdulpdp, tndiff ) + perimeter_inside(ngate_spdulpdp, tndiff)) / 2
   L = area(ngate_spdulpdp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_ulpsr) ngate_spdulp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_ulpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spdulp, tndiff ) + perimeter_inside(ngate_spdulp, tndiff)) / 2
   L = area(ngate_spdulp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_wisr) ngate_spdwi poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_wisr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spdwi, tndiff ) + perimeter_inside(ngate_spdwi, tndiff)) / 2
   L = area(ngate_spdwi) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_wosr) ngate_spdwo poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_wosr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spdwo, tndiff ) + perimeter_inside(ngate_spdwo, tndiff)) / 2
   L = area(ngate_spdwo) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_dphcsr) ngate_spgdphc poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_dphcsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spgdphc, tndiff ) + perimeter_inside(ngate_spgdphc, tndiff)) / 2
   L = area(ngate_spgdphc) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_dpsr) ngate_spgdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_dpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spgdp, tndiff ) + perimeter_inside(ngate_spgdp, tndiff)) / 2
   L = area(ngate_spgdp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_hvtdphcsr) ngate_hvspgdphc poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_hvtdphcsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_hvspgdphc, tndiff ) + perimeter_inside(ngate_hvspgdphc, tndiff)) / 2
   L = area(ngate_hvspgdphc) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_hvtdpsr) ngate_hvspgdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_hvtdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_hvspgdp, tndiff ) + perimeter_inside(ngate_hvspgdp, tndiff)) / 2
   L = area(ngate_hvspgdp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_hvtsr) ngate_hvspg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_hvtsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_hvspg, tndiff ) + perimeter_inside(ngate_hvspg, tndiff)) / 2
   L = area(ngate_hvspg) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_lpgdpsr) ngate_spglpgdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_lpgdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spglpgdp, tndiff ) + perimeter_inside(ngate_spglpgdp, tndiff)) / 2
   L = area(ngate_spglpgdp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_lpgsr) ngate_spglpg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_lpgsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spglpg, tndiff ) + perimeter_inside(ngate_spglpg, tndiff)) / 2
   L = area(ngate_spglpg) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_lpgtpsr) ngate_spglpgtp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_lpgtpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spglpgtp, tndiff ) + perimeter_inside(ngate_spglpgtp, tndiff)) / 2
   L = area(ngate_spglpgtp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_sr) ngate_spg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_sr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spg, tndiff ) + perimeter_inside(ngate_spg, tndiff)) / 2
   L = area(ngate_spg) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_ulpdpsr) ngate_spgulpdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_ulpdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spgulpdp, tndiff ) + perimeter_inside(ngate_spgulpdp, tndiff)) / 2
   L = area(ngate_spgulpdp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_ulpsr) ngate_spgulp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_ulpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spgulp, tndiff ) + perimeter_inside(ngate_spgulp, tndiff)) / 2
   L = area(ngate_spgulp) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_wisr) ngate_spgwi poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_wisr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spgwi, tndiff ) + perimeter_inside(ngate_spgwi, tndiff)) / 2
   L = area(ngate_spgwi) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_wosr) ngate_spgwo poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_wosr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spgwo, tndiff ) + perimeter_inside(ngate_spgwo, tndiff)) / 2
   L = area(ngate_spgwo) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pch) pgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate, tpdiff ) + perimeter_inside(pgate, tpdiff)) / 2
   L = area(pgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_18) pgate_18 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_18, tpdiff ) + perimeter_inside(pgate_18, tpdiff)) / 2
   L = area(pgate_18) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_18) pgate_18_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_18_mac, tpdiff ) + perimeter_inside(pgate_18_mac, tpdiff)) / 2
   L = area(pgate_18_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25) pgate_25 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_25, tpdiff ) + perimeter_inside(pgate_25, tpdiff)) / 2
   L = area(pgate_25) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25) pgate_25_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_25_mac, tpdiff ) + perimeter_inside(pgate_25_mac, tpdiff)) / 2
   L = area(pgate_25_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25od) pgate_25od poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_25od, tpdiff ) + perimeter_inside(pgate_25od, tpdiff)) / 2
   L = area(pgate_25od) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25od28) pgate_25od28 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_25od28 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_25od28, tpdiff ) + perimeter_inside(pgate_25od28, tpdiff)) / 2
   L = area(pgate_25od28) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25od28) pgate_25od28_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_25od28_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_25od28_mac, tpdiff ) + perimeter_inside(pgate_25od28_mac, tpdiff)) / 2
   L = area(pgate_25od28_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25od) pgate_25od_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_25od_mac, tpdiff ) + perimeter_inside(pgate_25od_mac, tpdiff)) / 2
   L = area(pgate_25od_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25ud) pgate_25ud poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_25ud, tpdiff ) + perimeter_inside(pgate_25ud, tpdiff)) / 2
   L = area(pgate_25ud) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_25ud) pgate_25ud_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_25ud_mac, tpdiff ) + perimeter_inside(pgate_25ud_mac, tpdiff)) / 2
   L = area(pgate_25ud_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_33) pgate_33 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pIO_WPEPROP> netlist model pch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_33, tpdiff ) + perimeter_inside(pgate_33, tpdiff)) / 2
   L = area(pgate_33) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_33) pgate_33_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pIO_WPEPROP> netlist model pch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_33_mac, tpdiff ) + perimeter_inside(pgate_33_mac, tpdiff)) / 2
   L = area(pgate_33_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pIO_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pIO_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pIO_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pIO_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_edc) pgate_1tr poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_edc [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_1tr, tpdiff ) + perimeter_inside(pgate_1tr, tpdiff)) / 2
   L = area(pgate_1tr) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_hvt) phvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_hvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(phvgate, tpdiff ) + perimeter_inside(phvgate, tpdiff)) / 2
   L = area(phvgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_hvt) phvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_hvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(phvgate_mac, tpdiff ) + perimeter_inside(phvgate_mac, tpdiff)) / 2
   L = area(phvgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_lpg) pgatelpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_lpg [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgatelpg, tpdiff ) + perimeter_inside(pgatelpg, tpdiff)) / 2
   L = area(pgatelpg) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_lpghvt) phvgatelpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_lpghvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(phvgatelpg, tpdiff ) + perimeter_inside(phvgatelpg, tpdiff)) / 2
   L = area(phvgatelpg) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_lvt) plvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_lvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(plvgate, tpdiff ) + perimeter_inside(plvgate, tpdiff)) / 2
   L = area(plvgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_lvt) plvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_lvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(plvgate_mac, tpdiff ) + perimeter_inside(plvgate_mac, tpdiff)) / 2
   L = area(plvgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch) pgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_mac, tpdiff ) + perimeter_inside(pgate_mac, tpdiff)) / 2
   L = area(pgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_mlvt) pilvtgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_mlvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pilvtgate, tpdiff ) + perimeter_inside(pilvtgate, tpdiff)) / 2
   L = area(pilvtgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_mlvt) pilvtgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_mlvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pilvtgate_mac, tpdiff ) + perimeter_inside(pilvtgate_mac, tpdiff)) / 2
   L = area(pilvtgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_timer) pgate_st poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_timer [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_st, tpdiff ) + perimeter_inside(pgate_st, tpdiff)) / 2
   L = area(pgate_st) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_uhvt) puhvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_uhvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(puhvgate, tpdiff ) + perimeter_inside(puhvgate, tpdiff)) / 2
   L = area(puhvgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_uhvt) puhvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_uhvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(puhvgate_mac, tpdiff ) + perimeter_inside(puhvgate_mac, tpdiff)) / 2
   L = area(puhvgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_ulvt) puvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_ulvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(puvgate, tpdiff ) + perimeter_inside(puvgate, tpdiff)) / 2
   L = area(puvgate) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_ulvt) puvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_ulvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(puvgate_mac, tpdiff ) + perimeter_inside(puvgate_mac, tpdiff)) / 2
   L = area(puvgate_mac) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_w) pgate_w1t poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <lod_PROP> <pCore_WPEPROP> netlist model pch_w [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_w1t, tpdiff ) + perimeter_inside(pgate_w1t, tpdiff)) / 2
   L = area(pgate_w1t) / W
   LODX_1 = DFM_VEC_VAL( lod_PROP, "PER_1" )
   LODX_2 = DFM_VEC_VAL( lod_PROP, "PER_2" )
   sa = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_1, W, L, UNIT_LENGTH(), SCALE )
   sb = TVF_NUM_FUN( "calc_lod_sasb", "device_function", LODX_2, W, L, UNIT_LENGTH(), SCALE )
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   WPEX_1 = DFM_VEC_VAL( pCore_WPEPROP, "PER_1" )
   WPEX_2 = DFM_VEC_VAL( pCore_WPEPROP, "PER_2" )
   WPEY_1 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_1" )
   WPEY_2 = DFM_VEC_VAL( pCore_WPEPROP, "PAR_2" )
   sca = TVF_NUM_FUN( "calc_sca_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scb = TVF_NUM_FUN( "calc_scb_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
   scc = TVF_NUM_FUN( "calc_scc_dfm", "device_function", WPEX_1, WPEX_2, WPEY_1, WPEY_2, W, L, LR_EXT, TOP_EXT, BOT_EXT, UNIT_LENGTH(), SCALE, WPED )
]

DEVICE MP(pch_w_lvt) pgate_w1t_lvt poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pch_w_lvt [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_w1t_lvt, tpdiff ) + perimeter_inside(pgate_w1t_lvt, tpdiff)) / 2
   L = area(pgate_w1t_lvt) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_dphcsr) pgate_sdphc poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_dphcsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_sdphc, tpdiff ) + perimeter_inside(pgate_sdphc, tpdiff)) / 2
   L = area(pgate_sdphc) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_dpsr) pgate_sdp poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_dpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_sdp, tpdiff ) + perimeter_inside(pgate_sdp, tpdiff)) / 2
   L = area(pgate_sdp) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_hvtdphcsr) pgate_hvsdphc poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_hvtdphcsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_hvsdphc, tpdiff ) + perimeter_inside(pgate_hvsdphc, tpdiff)) / 2
   L = area(pgate_hvsdphc) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_hvtdpsr) pgate_hvsdp poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_hvtdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_hvsdp, tpdiff ) + perimeter_inside(pgate_hvsdp, tpdiff)) / 2
   L = area(pgate_hvsdp) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_hvtsr) pgate_hvs poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_hvtsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_hvs, tpdiff ) + perimeter_inside(pgate_hvs, tpdiff)) / 2
   L = area(pgate_hvs) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_lpgdpsr) pgate_sdplpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_lpgdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_sdplpg, tpdiff ) + perimeter_inside(pgate_sdplpg, tpdiff)) / 2
   L = area(pgate_sdplpg) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_lpgsr) pgate_slpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_lpgsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_slpg, tpdiff ) + perimeter_inside(pgate_slpg, tpdiff)) / 2
   L = area(pgate_slpg) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_lpgtpsr) pgate_stplpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_lpgtpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_stplpg, tpdiff ) + perimeter_inside(pgate_stplpg, tpdiff)) / 2
   L = area(pgate_stplpg) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_sr) pgate_s poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_sr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_s, tpdiff ) + perimeter_inside(pgate_s, tpdiff)) / 2
   L = area(pgate_s) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_ulpdpsr) pgate_sdpulp poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_ulpdpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_sdpulp, tpdiff ) + perimeter_inside(pgate_sdpulp, tpdiff)) / 2
   L = area(pgate_sdpulp) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_ulpsr) pgate_sulp poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_ulpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_sulp, tpdiff ) + perimeter_inside(pgate_sulp, tpdiff)) / 2
   L = area(pgate_sulp) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_wisr) pgate_swi poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_wisr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_swi, tpdiff ) + perimeter_inside(pgate_swi, tpdiff)) / 2
   L = area(pgate_swi) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_wosr) pgate_swo poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_wosr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_swo, tpdiff ) + perimeter_inside(pgate_swo, tpdiff)) / 2
   L = area(pgate_swo) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]


#ENDIF
#ELSE

#IFDEF extract_as_ad
DEVICE LDDP(pch_hv25_spw)  pgate_25hvd d_pd25hvd(D) poly(G) s_pd25hvd(S) nxwell(B) <pthin> [
  property W,L,AS,AD
  W  = (perimeter_coincide(pgate_25hvd, s_pd25hvd ) + perimeter_coincide(pgate_25hvd, d_pd25hvd)) / 2
  L  = area(pgate_25hvd) / W
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
]
DEVICE LDDP(pch_hv25_spw)  pgate_25hvd_mac d_pd25hvd(D) poly(G) s_pd25hvd(S) nxwell(B) <pthin> [
  property W,L,AS,AD
  W  = (perimeter_coincide(pgate_25hvd_mac, s_pd25hvd ) + perimeter_coincide(pgate_25hvd_mac, d_pd25hvd)) / 2
  L  = area(pgate_25hvd_mac) / W
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
]
DEVICE LDDN(nch_hv25_snw)  ngate_25hvdw d_nd25hvdw(D) poly(G) s_nd25hvdw(S) psub(B) <nthin1> [
  property W,L,AS,AD
  W  = (perimeter_coincide(ngate_25hvdw, s_nd25hvdw ) + perimeter_coincide(ngate_25hvdw, d_nd25hvdw)) / 2
  L  = area(ngate_25hvdw) / W
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
]
DEVICE LDDN(nch_hv25_snw)  ngate_25hvdw_mac d_nd25hvdw(D) poly(G) s_nd25hvdw(S) psub(B) <nthin1> [
  property W,L,AS,AD
  W  = (perimeter_coincide(ngate_25hvdw_mac, s_nd25hvdw ) + perimeter_coincide(ngate_25hvdw_mac, d_nd25hvdw)) / 2
  L  = area(ngate_25hvdw_mac) / W
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
]
DEVICE MN(nch) ngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate, tndiff ) + perimeter_inside(ngate, tndiff)) / 2
   L=area(ngate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_18) ngate_18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_18, tndiff ) + perimeter_inside(ngate_18, tndiff)) / 2
   L=area(ngate_18) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_18_dnw) dngate_18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_18, tndiff ) + perimeter_inside(dngate_18, tndiff)) / 2
   L=area(dngate_18) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_18_dnw) dngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_18_mac, tndiff ) + perimeter_inside(dngate_18_mac, tndiff)) / 2
   L=area(dngate_18_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_18) ngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_18_mac, tndiff ) + perimeter_inside(ngate_18_mac, tndiff)) / 2
   L=area(ngate_18_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25) ngate_25 poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25, tndiff ) + perimeter_inside(ngate_25, tndiff)) / 2
   L=area(ngate_25) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nch_25_dnw) dngate_25 poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_25, tndiff ) + perimeter_inside(dngate_25, tndiff)) / 2
   L=area(dngate_25) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nch_25_dnw) dngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_25_mac, tndiff ) + perimeter_inside(dngate_25_mac, tndiff)) / 2
   L=area(dngate_25_mac) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nch_25_dnwod) dngate_25od poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_25od, tndiff ) + perimeter_inside(dngate_25od, tndiff)) / 2
   L=area(dngate_25od) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25_dnwod) dngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_25od_mac, tndiff ) + perimeter_inside(dngate_25od_mac, tndiff)) / 2
   L=area(dngate_25od_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25_dnwud) dngate_25ud poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_25ud, tndiff ) + perimeter_inside(dngate_25ud, tndiff)) / 2
   L=area(dngate_25ud) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25_dnwud) dngate_25ud_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_25ud_mac, tndiff ) + perimeter_inside(dngate_25ud_mac, tndiff)) / 2
   L=area(dngate_25ud_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25) ngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25_mac, tndiff ) + perimeter_inside(ngate_25_mac, tndiff)) / 2
   L=area(ngate_25_mac) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nch_25od) ngate_25od poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25od, tndiff ) + perimeter_inside(ngate_25od, tndiff)) / 2
   L=area(ngate_25od) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25od28) ngate_25od28 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25od28, tndiff ) + perimeter_inside(ngate_25od28, tndiff)) / 2
   L=area(ngate_25od28) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25od28_dnw) dngate_25od28 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_25od28, tndiff ) + perimeter_inside(dngate_25od28, tndiff)) / 2
   L=area(dngate_25od28) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25od28_dnw) dngate_25od28_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_25od28_mac, tndiff ) + perimeter_inside(dngate_25od28_mac, tndiff)) / 2
   L=area(dngate_25od28_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25od28) ngate_25od28_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25od28_mac, tndiff ) + perimeter_inside(ngate_25od28_mac, tndiff)) / 2
   L=area(ngate_25od28_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25od) ngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25od_mac, tndiff ) + perimeter_inside(ngate_25od_mac, tndiff)) / 2
   L=area(ngate_25od_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25ud) ngate_25ud poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25ud, tndiff ) + perimeter_inside(ngate_25ud, tndiff)) / 2
   L=area(ngate_25ud) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25ud) ngate_25ud_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25ud_mac, tndiff ) + perimeter_inside(ngate_25ud_mac, tndiff)) / 2
   L=area(ngate_25ud_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_33) ngate_33 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_33, tndiff ) + perimeter_inside(ngate_33, tndiff)) / 2
   L=area(ngate_33) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_33_dnw) dngate_33 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_33, tndiff ) + perimeter_inside(dngate_33, tndiff)) / 2
   L=area(dngate_33) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_33_dnw) dngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_33_mac, tndiff ) + perimeter_inside(dngate_33_mac, tndiff)) / 2
   L=area(dngate_33_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_33) ngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_33_mac, tndiff ) + perimeter_inside(ngate_33_mac, tndiff)) / 2
   L=area(ngate_33_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_dnw) nrgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nrgate, tndiff ) + perimeter_inside(nrgate, tndiff)) / 2
   L=area(nrgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_dnw_1tr) ngate_1tr poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_1tr, tndiff ) + perimeter_inside(ngate_1tr, tndiff)) / 2
   L=area(ngate_1tr) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_dnw) nrgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nrgate_mac, tndiff ) + perimeter_inside(nrgate_mac, tndiff)) / 2
   L=area(nrgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_dnw_w) ngate_dnw_w poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_dnw_w, tndiff ) + perimeter_inside(ngate_dnw_w, tndiff)) / 2
   L=area(ngate_dnw_w) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_dnw_w_lvt) ngate_dnw_w_lvt poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_dnw_w_lvt, tndiff ) + perimeter_inside(ngate_dnw_w_lvt, tndiff)) / 2
   L=area(ngate_dnw_w_lvt) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_esd18) ngate_esd18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_esd18, tndiff ) + perimeter_inside(ngate_esd18, tndiff)) / 2
   L=area(ngate_esd18) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_esd18_dnw) dngate_esd18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_esd18, tndiff ) + perimeter_inside(dngate_esd18, tndiff)) / 2
   L=area(dngate_esd18) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_esd18_dnw) dngate_esd18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_esd18_mac, tndiff ) + perimeter_inside(dngate_esd18_mac, tndiff)) / 2
   L=area(dngate_esd18_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_esd18) ngate_esd18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_esd18_mac, tndiff ) + perimeter_inside(ngate_esd18_mac, tndiff)) / 2
   L=area(ngate_esd18_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_hvt) nhvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nhvgate, tndiff ) + perimeter_inside(nhvgate, tndiff)) / 2
   L=area(nhvgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_hvt_dnw) n1hvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1hvgate, tndiff ) + perimeter_inside(n1hvgate, tndiff)) / 2
   L=area(n1hvgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_hvt_dnw) n1hvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1hvgate_mac, tndiff ) + perimeter_inside(n1hvgate_mac, tndiff)) / 2
   L=area(n1hvgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_hvt) nhvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nhvgate_mac, tndiff ) + perimeter_inside(nhvgate_mac, tndiff)) / 2
   L=area(nhvgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_lpg) ngatelpg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngatelpg, tndiff ) + perimeter_inside(ngatelpg, tndiff)) / 2
   L=area(ngatelpg) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_lpghvt) nhvgatelpg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nhvgatelpg, tndiff ) + perimeter_inside(nhvgatelpg, tndiff)) / 2
   L=area(nhvgatelpg) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_lpgna) nlgatelpg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nlgatelpg, tndiff ) + perimeter_inside(nlgatelpg, tndiff)) / 2
   L=area(nlgatelpg) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_lvt) nlvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nlvgate, tndiff ) + perimeter_inside(nlvgate, tndiff)) / 2
   L=area(nlvgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_lvt_dnw) n1lvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1lvgate, tndiff ) + perimeter_inside(n1lvgate, tndiff)) / 2
   L=area(n1lvgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_lvt_dnw) n1lvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1lvgate_mac, tndiff ) + perimeter_inside(n1lvgate_mac, tndiff)) / 2
   L=area(n1lvgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_lvt) nlvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nlvgate_mac, tndiff ) + perimeter_inside(nlvgate_mac, tndiff)) / 2
   L=area(nlvgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch) ngate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_mac, tndiff ) + perimeter_inside(ngate_mac, tndiff)) / 2
   L=area(ngate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_mlvt) nilvtgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nilvtgate, tndiff ) + perimeter_inside(nilvtgate, tndiff)) / 2
   L=area(nilvtgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_mlvt_dnw) n1ilvtgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1ilvtgate, tndiff ) + perimeter_inside(n1ilvtgate, tndiff)) / 2
   L=area(n1ilvtgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_mlvt_dnw) n1ilvtgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1ilvtgate_mac, tndiff ) + perimeter_inside(n1ilvtgate_mac, tndiff)) / 2
   L=area(n1ilvtgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_mlvt) nilvtgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nilvtgate_mac, tndiff ) + perimeter_inside(nilvtgate_mac, tndiff)) / 2
   L=area(nilvtgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na) nlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nlgate, tndiff ) + perimeter_inside(nlgate, tndiff)) / 2
   L=area(nlgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na18) ngate_18na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_18na, tndiff ) + perimeter_inside(ngate_18na, tndiff)) / 2
   L=area(ngate_18na) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na18) ngate_18na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_18na_mac, tndiff ) + perimeter_inside(ngate_18na_mac, tndiff)) / 2
   L=area(ngate_18na_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na25) ngate_25na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25na, tndiff ) + perimeter_inside(ngate_25na, tndiff)) / 2
   L=area(ngate_25na) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na25) ngate_25na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25na_mac, tndiff ) + perimeter_inside(ngate_25na_mac, tndiff)) / 2
   L=area(ngate_25na_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na25od) ngate_25naod poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25naod, tndiff ) + perimeter_inside(ngate_25naod, tndiff)) / 2
   L=area(ngate_25naod) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na25od) ngate_25naod_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25naod_mac, tndiff ) + perimeter_inside(ngate_25naod_mac, tndiff)) / 2
   L=area(ngate_25naod_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na25ud) ngate_25naud poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25naud, tndiff ) + perimeter_inside(ngate_25naud, tndiff)) / 2
   L=area(ngate_25naud) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na25ud) ngate_25naud_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25naud_mac, tndiff ) + perimeter_inside(ngate_25naud_mac, tndiff)) / 2
   L=area(ngate_25naud_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na33) ngate_33na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_33na, tndiff ) + perimeter_inside(ngate_33na, tndiff)) / 2
   L=area(ngate_33na) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na33) ngate_33na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_33na_mac, tndiff ) + perimeter_inside(ngate_33na_mac, tndiff)) / 2
   L=area(ngate_33na_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na) nlgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nlgate_mac, tndiff ) + perimeter_inside(nlgate_mac, tndiff)) / 2
   L=area(nlgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_timer) ngate_st poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_st, tndiff ) + perimeter_inside(ngate_st, tndiff)) / 2
   L=area(ngate_st) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_uhvt) nuhvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nuhvgate, tndiff ) + perimeter_inside(nuhvgate, tndiff)) / 2
   L=area(nuhvgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_uhvt_dnw) n1uhvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1uhvgate, tndiff ) + perimeter_inside(n1uhvgate, tndiff)) / 2
   L=area(n1uhvgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_uhvt_dnw) n1uhvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1uhvgate_mac, tndiff ) + perimeter_inside(n1uhvgate_mac, tndiff)) / 2
   L=area(n1uhvgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_uhvt) nuhvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nuhvgate_mac, tndiff ) + perimeter_inside(nuhvgate_mac, tndiff)) / 2
   L=area(nuhvgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_ulvt) nuvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nuvgate, tndiff ) + perimeter_inside(nuvgate, tndiff)) / 2
   L=area(nuvgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_ulvt_dnw) n1uvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1uvgate, tndiff ) + perimeter_inside(n1uvgate, tndiff)) / 2
   L=area(n1uvgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_ulvt_dnw) n1uvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1uvgate_mac, tndiff ) + perimeter_inside(n1uvgate_mac, tndiff)) / 2
   L=area(n1uvgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_ulvt) nuvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nuvgate_mac, tndiff ) + perimeter_inside(nuvgate_mac, tndiff)) / 2
   L=area(nuvgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_w) ngate_w1t poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_w1t, tndiff ) + perimeter_inside(ngate_w1t, tndiff)) / 2
   L=area(ngate_w1t) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_w_lvt) ngate_w1t_lvt poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_w1t_lvt, tndiff ) + perimeter_inside(ngate_w1t_lvt, tndiff)) / 2
   L=area(ngate_w1t_lvt) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_dphcsr) ngate_spddphc poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spddphc, tndiff ) + perimeter_inside(ngate_spddphc, tndiff)) / 2
   L=area(ngate_spddphc) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_dpsr) ngate_spddp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spddp, tndiff ) + perimeter_inside(ngate_spddp, tndiff)) / 2
   L=area(ngate_spddp) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_hvtdphcsr) ngate_hvspddphc poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_hvspddphc, tndiff ) + perimeter_inside(ngate_hvspddphc, tndiff)) / 2
   L=area(ngate_hvspddphc) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_hvtdpsr) ngate_hvspddp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_hvspddp, tndiff ) + perimeter_inside(ngate_hvspddp, tndiff)) / 2
   L=area(ngate_hvspddp) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_hvtsr) ngate_hvspd poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_hvspd, tndiff ) + perimeter_inside(ngate_hvspd, tndiff)) / 2
   L=area(ngate_hvspd) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_lpgdpsr) ngate_spdlpgdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spdlpgdp, tndiff ) + perimeter_inside(ngate_spdlpgdp, tndiff)) / 2
   L=area(ngate_spdlpgdp) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_lpgsr) ngate_spdlpg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spdlpg, tndiff ) + perimeter_inside(ngate_spdlpg, tndiff)) / 2
   L=area(ngate_spdlpg) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_lpgtpsr) ngate_spdlpgtp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spdlpgtp, tndiff ) + perimeter_inside(ngate_spdlpgtp, tndiff)) / 2
   L=area(ngate_spdlpgtp) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_sr) ngate_spd poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spd, tndiff ) + perimeter_inside(ngate_spd, tndiff)) / 2
   L=area(ngate_spd) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_ulpdpsr) ngate_spdulpdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spdulpdp, tndiff ) + perimeter_inside(ngate_spdulpdp, tndiff)) / 2
   L=area(ngate_spdulpdp) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_ulpsr) ngate_spdulp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spdulp, tndiff ) + perimeter_inside(ngate_spdulp, tndiff)) / 2
   L=area(ngate_spdulp) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_wisr) ngate_spdwi poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spdwi, tndiff ) + perimeter_inside(ngate_spdwi, tndiff)) / 2
   L=area(ngate_spdwi) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_wosr) ngate_spdwo poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spdwo, tndiff ) + perimeter_inside(ngate_spdwo, tndiff)) / 2
   L=area(ngate_spdwo) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_dphcsr) ngate_spgdphc poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spgdphc, tndiff ) + perimeter_inside(ngate_spgdphc, tndiff)) / 2
   L=area(ngate_spgdphc) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_dpsr) ngate_spgdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spgdp, tndiff ) + perimeter_inside(ngate_spgdp, tndiff)) / 2
   L=area(ngate_spgdp) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_hvtdphcsr) ngate_hvspgdphc poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_hvspgdphc, tndiff ) + perimeter_inside(ngate_hvspgdphc, tndiff)) / 2
   L=area(ngate_hvspgdphc) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_hvtdpsr) ngate_hvspgdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_hvspgdp, tndiff ) + perimeter_inside(ngate_hvspgdp, tndiff)) / 2
   L=area(ngate_hvspgdp) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_hvtsr) ngate_hvspg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_hvspg, tndiff ) + perimeter_inside(ngate_hvspg, tndiff)) / 2
   L=area(ngate_hvspg) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_lpgdpsr) ngate_spglpgdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spglpgdp, tndiff ) + perimeter_inside(ngate_spglpgdp, tndiff)) / 2
   L=area(ngate_spglpgdp) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_lpgsr) ngate_spglpg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spglpg, tndiff ) + perimeter_inside(ngate_spglpg, tndiff)) / 2
   L=area(ngate_spglpg) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_lpgtpsr) ngate_spglpgtp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spglpgtp, tndiff ) + perimeter_inside(ngate_spglpgtp, tndiff)) / 2
   L=area(ngate_spglpgtp) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_sr) ngate_spg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spg, tndiff ) + perimeter_inside(ngate_spg, tndiff)) / 2
   L=area(ngate_spg) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_ulpdpsr) ngate_spgulpdp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spgulpdp, tndiff ) + perimeter_inside(ngate_spgulpdp, tndiff)) / 2
   L=area(ngate_spgulpdp) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_ulpsr) ngate_spgulp poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spgulp, tndiff ) + perimeter_inside(ngate_spgulp, tndiff)) / 2
   L=area(ngate_spgulp) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_wisr) ngate_spgwi poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spgwi, tndiff ) + perimeter_inside(ngate_spgwi, tndiff)) / 2
   L=area(ngate_spgwi) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_wosr) ngate_spgwo poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spgwo, tndiff ) + perimeter_inside(ngate_spgwo, tndiff)) / 2
   L=area(ngate_spgwo) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MP(pch) pgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate, tpdiff ) + perimeter_inside(pgate, tpdiff)) / 2 
   L=area(pgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_18) pgate_18 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_18, tpdiff ) + perimeter_inside(pgate_18, tpdiff)) / 2 
   L=area(pgate_18) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_18) pgate_18_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_18_mac, tpdiff ) + perimeter_inside(pgate_18_mac, tpdiff)) / 2 
   L=area(pgate_18_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_25) pgate_25 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_25, tpdiff ) + perimeter_inside(pgate_25, tpdiff)) / 2 
   L=area(pgate_25) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_25) pgate_25_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_25_mac, tpdiff ) + perimeter_inside(pgate_25_mac, tpdiff)) / 2 
   L=area(pgate_25_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_25od) pgate_25od poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_25od, tpdiff ) + perimeter_inside(pgate_25od, tpdiff)) / 2 
   L=area(pgate_25od) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_25od28) pgate_25od28 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_25od28, tpdiff ) + perimeter_inside(pgate_25od28, tpdiff)) / 2 
   L=area(pgate_25od28) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_25od28) pgate_25od28_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_25od28_mac, tpdiff ) + perimeter_inside(pgate_25od28_mac, tpdiff)) / 2 
   L=area(pgate_25od28_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_25od) pgate_25od_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_25od_mac, tpdiff ) + perimeter_inside(pgate_25od_mac, tpdiff)) / 2 
   L=area(pgate_25od_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_25ud) pgate_25ud poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_25ud, tpdiff ) + perimeter_inside(pgate_25ud, tpdiff)) / 2 
   L=area(pgate_25ud) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_25ud) pgate_25ud_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_25ud_mac, tpdiff ) + perimeter_inside(pgate_25ud_mac, tpdiff)) / 2 
   L=area(pgate_25ud_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_33) pgate_33 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_33, tpdiff ) + perimeter_inside(pgate_33, tpdiff)) / 2 
   L=area(pgate_33) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_33) pgate_33_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_33_mac, tpdiff ) + perimeter_inside(pgate_33_mac, tpdiff)) / 2 
   L=area(pgate_33_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_edc) pgate_1tr poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_1tr, tpdiff ) + perimeter_inside(pgate_1tr, tpdiff)) / 2 
   L=area(pgate_1tr) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_hvt) phvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(phvgate, tpdiff ) + perimeter_inside(phvgate, tpdiff)) / 2 
   L=area(phvgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_hvt) phvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(phvgate_mac, tpdiff ) + perimeter_inside(phvgate_mac, tpdiff)) / 2 
   L=area(phvgate_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_lpg) pgatelpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgatelpg, tpdiff ) + perimeter_inside(pgatelpg, tpdiff)) / 2 
   L=area(pgatelpg) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_lpghvt) phvgatelpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(phvgatelpg, tpdiff ) + perimeter_inside(phvgatelpg, tpdiff)) / 2 
   L=area(phvgatelpg) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_lvt) plvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(plvgate, tpdiff ) + perimeter_inside(plvgate, tpdiff)) / 2 
   L=area(plvgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_lvt) plvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(plvgate_mac, tpdiff ) + perimeter_inside(plvgate_mac, tpdiff)) / 2 
   L=area(plvgate_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch) pgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_mac, tpdiff ) + perimeter_inside(pgate_mac, tpdiff)) / 2 
   L=area(pgate_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_mlvt) pilvtgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pilvtgate, tpdiff ) + perimeter_inside(pilvtgate, tpdiff)) / 2 
   L=area(pilvtgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_mlvt) pilvtgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pilvtgate_mac, tpdiff ) + perimeter_inside(pilvtgate_mac, tpdiff)) / 2 
   L=area(pilvtgate_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_timer) pgate_st poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_st, tpdiff ) + perimeter_inside(pgate_st, tpdiff)) / 2 
   L=area(pgate_st) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_uhvt) puhvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(puhvgate, tpdiff ) + perimeter_inside(puhvgate, tpdiff)) / 2 
   L=area(puhvgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_uhvt) puhvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(puhvgate_mac, tpdiff ) + perimeter_inside(puhvgate_mac, tpdiff)) / 2 
   L=area(puhvgate_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_ulvt) puvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(puvgate, tpdiff ) + perimeter_inside(puvgate, tpdiff)) / 2 
   L=area(puvgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_ulvt) puvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(puvgate_mac, tpdiff ) + perimeter_inside(puvgate_mac, tpdiff)) / 2 
   L=area(puvgate_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_w) pgate_w1t poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_w1t, tpdiff ) + perimeter_inside(pgate_w1t, tpdiff)) / 2 
   L=area(pgate_w1t) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_w_lvt) pgate_w1t_lvt poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_w1t_lvt, tpdiff ) + perimeter_inside(pgate_w1t_lvt, tpdiff)) / 2 
   L=area(pgate_w1t_lvt) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_dphcsr) pgate_sdphc poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_sdphc, tpdiff ) + perimeter_inside(pgate_sdphc, tpdiff)) / 2 
   L=area(pgate_sdphc) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_dpsr) pgate_sdp poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_sdp, tpdiff ) + perimeter_inside(pgate_sdp, tpdiff)) / 2 
   L=area(pgate_sdp) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_hvtdphcsr) pgate_hvsdphc poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_hvsdphc, tpdiff ) + perimeter_inside(pgate_hvsdphc, tpdiff)) / 2 
   L=area(pgate_hvsdphc) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_hvtdpsr) pgate_hvsdp poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_hvsdp, tpdiff ) + perimeter_inside(pgate_hvsdp, tpdiff)) / 2 
   L=area(pgate_hvsdp) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_hvtsr) pgate_hvs poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_hvs, tpdiff ) + perimeter_inside(pgate_hvs, tpdiff)) / 2 
   L=area(pgate_hvs) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_lpgdpsr) pgate_sdplpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_sdplpg, tpdiff ) + perimeter_inside(pgate_sdplpg, tpdiff)) / 2 
   L=area(pgate_sdplpg) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_lpgsr) pgate_slpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_slpg, tpdiff ) + perimeter_inside(pgate_slpg, tpdiff)) / 2 
   L=area(pgate_slpg) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_lpgtpsr) pgate_stplpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_stplpg, tpdiff ) + perimeter_inside(pgate_stplpg, tpdiff)) / 2 
   L=area(pgate_stplpg) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_sr) pgate_s poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_s, tpdiff ) + perimeter_inside(pgate_s, tpdiff)) / 2 
   L=area(pgate_s) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_ulpdpsr) pgate_sdpulp poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_sdpulp, tpdiff ) + perimeter_inside(pgate_sdpulp, tpdiff)) / 2 
   L=area(pgate_sdpulp) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_ulpsr) pgate_sulp poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_sulp, tpdiff ) + perimeter_inside(pgate_sulp, tpdiff)) / 2 
   L=area(pgate_sulp) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_wisr) pgate_swi poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_swi, tpdiff ) + perimeter_inside(pgate_swi, tpdiff)) / 2 
   L=area(pgate_swi) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_wosr) pgate_swo poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_swo, tpdiff ) + perimeter_inside(pgate_swo, tpdiff)) / 2 
   L=area(pgate_swo) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]


#ELSE
DEVICE LDDP(pch_hv25_spw)  pgate_25hvd d_pd25hvd(D) poly(G) s_pd25hvd(S) nxwell(B) [
  property W,L
  W = (perimeter_coincide(pgate_25hvd, s_pd25hvd ) + perimeter_coincide(pgate_25hvd, d_pd25hvd)) / 2
  L = area(pgate_25hvd) / W
]
DEVICE LDDP(pch_hv25_spw)  pgate_25hvd_mac d_pd25hvd(D) poly(G) s_pd25hvd(S) nxwell(B) [
  property W,L
  W = (perimeter_coincide(pgate_25hvd_mac, s_pd25hvd ) + perimeter_coincide(pgate_25hvd_mac, d_pd25hvd)) / 2
  L = area(pgate_25hvd_mac) / W
]
DEVICE LDDN(nch_hv25_snw)  ngate_25hvdw d_nd25hvdw(D) poly(G) s_nd25hvdw(S) psub(B) [
  property W,L
  W = (perimeter_coincide(ngate_25hvdw, s_nd25hvdw ) + perimeter_coincide(ngate_25hvdw, d_nd25hvdw)) / 2
  L = area(ngate_25hvdw) / W
]
DEVICE LDDN(nch_hv25_snw)  ngate_25hvdw_mac d_nd25hvdw(D) poly(G) s_nd25hvdw(S) psub(B) [
  property W,L
  W = (perimeter_coincide(ngate_25hvdw_mac, s_nd25hvdw ) + perimeter_coincide(ngate_25hvdw_mac, d_nd25hvdw)) / 2
  L = area(ngate_25hvdw_mac) / W
]
DEVICE MN(nch) ngate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate, tndiff ) + perimeter_inside(ngate, tndiff)) / 2 
   L=area(ngate) / W
]
DEVICE MN(nch_18) ngate_18 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_18, tndiff ) + perimeter_inside(ngate_18, tndiff)) / 2 
   L=area(ngate_18) / W
]
DEVICE MN(nch_18_dnw) dngate_18 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_18, tndiff ) + perimeter_inside(dngate_18, tndiff)) / 2 
   L=area(dngate_18) / W
]
DEVICE MN(nch_18_dnw) dngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_18_mac, tndiff ) + perimeter_inside(dngate_18_mac, tndiff)) / 2 
   L=area(dngate_18_mac) / W
]
DEVICE MN(nch_18) ngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_18_mac, tndiff ) + perimeter_inside(ngate_18_mac, tndiff)) / 2 
   L=area(ngate_18_mac) / W
]
DEVICE MN(nch_25) ngate_25 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25, tndiff ) + perimeter_inside(ngate_25, tndiff)) / 2 
   L=area(ngate_25) / W
]
DEVICE MN(nch_25_dnw) dngate_25 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_25, tndiff ) + perimeter_inside(dngate_25, tndiff)) / 2 
   L=area(dngate_25) / W
]
DEVICE MN(nch_25_dnw) dngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_25_mac, tndiff ) + perimeter_inside(dngate_25_mac, tndiff)) / 2 
   L=area(dngate_25_mac) / W
]
DEVICE MN(nch_25_dnwod) dngate_25od poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_25od, tndiff ) + perimeter_inside(dngate_25od, tndiff)) / 2 
   L=area(dngate_25od) / W
]
DEVICE MN(nch_25_dnwod) dngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_25od_mac, tndiff ) + perimeter_inside(dngate_25od_mac, tndiff)) / 2 
   L=area(dngate_25od_mac) / W
]
DEVICE MN(nch_25_dnwud) dngate_25ud poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_25ud, tndiff ) + perimeter_inside(dngate_25ud, tndiff)) / 2 
   L=area(dngate_25ud) / W
]
DEVICE MN(nch_25_dnwud) dngate_25ud_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_25ud_mac, tndiff ) + perimeter_inside(dngate_25ud_mac, tndiff)) / 2 
   L=area(dngate_25ud_mac) / W
]
DEVICE MN(nch_25) ngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25_mac, tndiff ) + perimeter_inside(ngate_25_mac, tndiff)) / 2 
   L=area(ngate_25_mac) / W
]
DEVICE MN(nch_25od) ngate_25od poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25od, tndiff ) + perimeter_inside(ngate_25od, tndiff)) / 2 
   L=area(ngate_25od) / W
]
DEVICE MN(nch_25od28) ngate_25od28 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25od28, tndiff ) + perimeter_inside(ngate_25od28, tndiff)) / 2 
   L=area(ngate_25od28) / W
]
DEVICE MN(nch_25od28_dnw) dngate_25od28 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_25od28, tndiff ) + perimeter_inside(dngate_25od28, tndiff)) / 2 
   L=area(dngate_25od28) / W
]
DEVICE MN(nch_25od28_dnw) dngate_25od28_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_25od28_mac, tndiff ) + perimeter_inside(dngate_25od28_mac, tndiff)) / 2 
   L=area(dngate_25od28_mac) / W
]
DEVICE MN(nch_25od28) ngate_25od28_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25od28_mac, tndiff ) + perimeter_inside(ngate_25od28_mac, tndiff)) / 2 
   L=area(ngate_25od28_mac) / W
]
DEVICE MN(nch_25od) ngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25od_mac, tndiff ) + perimeter_inside(ngate_25od_mac, tndiff)) / 2 
   L=area(ngate_25od_mac) / W
]
DEVICE MN(nch_25ud) ngate_25ud poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25ud, tndiff ) + perimeter_inside(ngate_25ud, tndiff)) / 2 
   L=area(ngate_25ud) / W
]
DEVICE MN(nch_25ud) ngate_25ud_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25ud_mac, tndiff ) + perimeter_inside(ngate_25ud_mac, tndiff)) / 2 
   L=area(ngate_25ud_mac) / W
]
DEVICE MN(nch_33) ngate_33 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_33, tndiff ) + perimeter_inside(ngate_33, tndiff)) / 2 
   L=area(ngate_33) / W
]
DEVICE MN(nch_33_dnw) dngate_33 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_33, tndiff ) + perimeter_inside(dngate_33, tndiff)) / 2 
   L=area(dngate_33) / W
]
DEVICE MN(nch_33_dnw) dngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_33_mac, tndiff ) + perimeter_inside(dngate_33_mac, tndiff)) / 2 
   L=area(dngate_33_mac) / W
]
DEVICE MN(nch_33) ngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_33_mac, tndiff ) + perimeter_inside(ngate_33_mac, tndiff)) / 2 
   L=area(ngate_33_mac) / W
]
DEVICE MN(nch_dnw) nrgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nrgate, tndiff ) + perimeter_inside(nrgate, tndiff)) / 2 
   L=area(nrgate) / W
]
DEVICE MN(nch_dnw_1tr) ngate_1tr poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_1tr, tndiff ) + perimeter_inside(ngate_1tr, tndiff)) / 2 
   L=area(ngate_1tr) / W
]
DEVICE MN(nch_dnw) nrgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nrgate_mac, tndiff ) + perimeter_inside(nrgate_mac, tndiff)) / 2 
   L=area(nrgate_mac) / W
]
DEVICE MN(nch_dnw_w) ngate_dnw_w poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_dnw_w, tndiff ) + perimeter_inside(ngate_dnw_w, tndiff)) / 2 
   L=area(ngate_dnw_w) / W
]
DEVICE MN(nch_dnw_w_lvt) ngate_dnw_w_lvt poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_dnw_w_lvt, tndiff ) + perimeter_inside(ngate_dnw_w_lvt, tndiff)) / 2 
   L=area(ngate_dnw_w_lvt) / W
]
DEVICE MN(nch_esd18) ngate_esd18 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_esd18, tndiff ) + perimeter_inside(ngate_esd18, tndiff)) / 2 
   L=area(ngate_esd18) / W
]
DEVICE MN(nch_esd18_dnw) dngate_esd18 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_esd18, tndiff ) + perimeter_inside(dngate_esd18, tndiff)) / 2 
   L=area(dngate_esd18) / W
]
DEVICE MN(nch_esd18_dnw) dngate_esd18_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_esd18_mac, tndiff ) + perimeter_inside(dngate_esd18_mac, tndiff)) / 2 
   L=area(dngate_esd18_mac) / W
]
DEVICE MN(nch_esd18) ngate_esd18_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_esd18_mac, tndiff ) + perimeter_inside(ngate_esd18_mac, tndiff)) / 2 
   L=area(ngate_esd18_mac) / W
]
DEVICE MN(nch_hvt) nhvgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nhvgate, tndiff ) + perimeter_inside(nhvgate, tndiff)) / 2 
   L=area(nhvgate) / W
]
DEVICE MN(nch_hvt_dnw) n1hvgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1hvgate, tndiff ) + perimeter_inside(n1hvgate, tndiff)) / 2 
   L=area(n1hvgate) / W
]
DEVICE MN(nch_hvt_dnw) n1hvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1hvgate_mac, tndiff ) + perimeter_inside(n1hvgate_mac, tndiff)) / 2 
   L=area(n1hvgate_mac) / W
]
DEVICE MN(nch_hvt) nhvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nhvgate_mac, tndiff ) + perimeter_inside(nhvgate_mac, tndiff)) / 2 
   L=area(nhvgate_mac) / W
]
DEVICE MN(nch_lpg) ngatelpg poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngatelpg, tndiff ) + perimeter_inside(ngatelpg, tndiff)) / 2 
   L=area(ngatelpg) / W
]
DEVICE MN(nch_lpghvt) nhvgatelpg poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nhvgatelpg, tndiff ) + perimeter_inside(nhvgatelpg, tndiff)) / 2 
   L=area(nhvgatelpg) / W
]
DEVICE MN(nch_lpgna) nlgatelpg poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nlgatelpg, tndiff ) + perimeter_inside(nlgatelpg, tndiff)) / 2 
   L=area(nlgatelpg) / W
]
DEVICE MN(nch_lvt) nlvgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nlvgate, tndiff ) + perimeter_inside(nlvgate, tndiff)) / 2 
   L=area(nlvgate) / W
]
DEVICE MN(nch_lvt_dnw) n1lvgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1lvgate, tndiff ) + perimeter_inside(n1lvgate, tndiff)) / 2 
   L=area(n1lvgate) / W
]
DEVICE MN(nch_lvt_dnw) n1lvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1lvgate_mac, tndiff ) + perimeter_inside(n1lvgate_mac, tndiff)) / 2 
   L=area(n1lvgate_mac) / W
]
DEVICE MN(nch_lvt) nlvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nlvgate_mac, tndiff ) + perimeter_inside(nlvgate_mac, tndiff)) / 2 
   L=area(nlvgate_mac) / W
]
DEVICE MN(nch) ngate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_mac, tndiff ) + perimeter_inside(ngate_mac, tndiff)) / 2 
   L=area(ngate_mac) / W
]
DEVICE MN(nch_mlvt) nilvtgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nilvtgate, tndiff ) + perimeter_inside(nilvtgate, tndiff)) / 2 
   L=area(nilvtgate) / W
]
DEVICE MN(nch_mlvt_dnw) n1ilvtgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1ilvtgate, tndiff ) + perimeter_inside(n1ilvtgate, tndiff)) / 2 
   L=area(n1ilvtgate) / W
]
DEVICE MN(nch_mlvt_dnw) n1ilvtgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1ilvtgate_mac, tndiff ) + perimeter_inside(n1ilvtgate_mac, tndiff)) / 2 
   L=area(n1ilvtgate_mac) / W
]
DEVICE MN(nch_mlvt) nilvtgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nilvtgate_mac, tndiff ) + perimeter_inside(nilvtgate_mac, tndiff)) / 2 
   L=area(nilvtgate_mac) / W
]
DEVICE MN(nch_na) nlgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nlgate, tndiff ) + perimeter_inside(nlgate, tndiff)) / 2 
   L=area(nlgate) / W
]
DEVICE MN(nch_na18) ngate_18na poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_18na, tndiff ) + perimeter_inside(ngate_18na, tndiff)) / 2 
   L=area(ngate_18na) / W
]
DEVICE MN(nch_na18) ngate_18na_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_18na_mac, tndiff ) + perimeter_inside(ngate_18na_mac, tndiff)) / 2 
   L=area(ngate_18na_mac) / W
]
DEVICE MN(nch_na25) ngate_25na poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25na, tndiff ) + perimeter_inside(ngate_25na, tndiff)) / 2 
   L=area(ngate_25na) / W
]
DEVICE MN(nch_na25) ngate_25na_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25na_mac, tndiff ) + perimeter_inside(ngate_25na_mac, tndiff)) / 2 
   L=area(ngate_25na_mac) / W
]
DEVICE MN(nch_na25od) ngate_25naod poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25naod, tndiff ) + perimeter_inside(ngate_25naod, tndiff)) / 2 
   L=area(ngate_25naod) / W
]
DEVICE MN(nch_na25od) ngate_25naod_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25naod_mac, tndiff ) + perimeter_inside(ngate_25naod_mac, tndiff)) / 2 
   L=area(ngate_25naod_mac) / W
]
DEVICE MN(nch_na25ud) ngate_25naud poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25naud, tndiff ) + perimeter_inside(ngate_25naud, tndiff)) / 2 
   L=area(ngate_25naud) / W
]
DEVICE MN(nch_na25ud) ngate_25naud_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25naud_mac, tndiff ) + perimeter_inside(ngate_25naud_mac, tndiff)) / 2 
   L=area(ngate_25naud_mac) / W
]
DEVICE MN(nch_na33) ngate_33na poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_33na, tndiff ) + perimeter_inside(ngate_33na, tndiff)) / 2 
   L=area(ngate_33na) / W
]
DEVICE MN(nch_na33) ngate_33na_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_33na_mac, tndiff ) + perimeter_inside(ngate_33na_mac, tndiff)) / 2 
   L=area(ngate_33na_mac) / W
]
DEVICE MN(nch_na) nlgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nlgate_mac, tndiff ) + perimeter_inside(nlgate_mac, tndiff)) / 2 
   L=area(nlgate_mac) / W
]
DEVICE MN(nch_timer) ngate_st poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_st, tndiff ) + perimeter_inside(ngate_st, tndiff)) / 2 
   L=area(ngate_st) / W
]
DEVICE MN(nch_uhvt) nuhvgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nuhvgate, tndiff ) + perimeter_inside(nuhvgate, tndiff)) / 2 
   L=area(nuhvgate) / W
]
DEVICE MN(nch_uhvt_dnw) n1uhvgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1uhvgate, tndiff ) + perimeter_inside(n1uhvgate, tndiff)) / 2 
   L=area(n1uhvgate) / W
]
DEVICE MN(nch_uhvt_dnw) n1uhvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1uhvgate_mac, tndiff ) + perimeter_inside(n1uhvgate_mac, tndiff)) / 2 
   L=area(n1uhvgate_mac) / W
]
DEVICE MN(nch_uhvt) nuhvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nuhvgate_mac, tndiff ) + perimeter_inside(nuhvgate_mac, tndiff)) / 2 
   L=area(nuhvgate_mac) / W
]
DEVICE MN(nch_ulvt) nuvgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nuvgate, tndiff ) + perimeter_inside(nuvgate, tndiff)) / 2 
   L=area(nuvgate) / W
]
DEVICE MN(nch_ulvt_dnw) n1uvgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1uvgate, tndiff ) + perimeter_inside(n1uvgate, tndiff)) / 2 
   L=area(n1uvgate) / W
]
DEVICE MN(nch_ulvt_dnw) n1uvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1uvgate_mac, tndiff ) + perimeter_inside(n1uvgate_mac, tndiff)) / 2 
   L=area(n1uvgate_mac) / W
]
DEVICE MN(nch_ulvt) nuvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nuvgate_mac, tndiff ) + perimeter_inside(nuvgate_mac, tndiff)) / 2 
   L=area(nuvgate_mac) / W
]
DEVICE MN(nch_w) ngate_w1t poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_w1t, tndiff ) + perimeter_inside(ngate_w1t, tndiff)) / 2 
   L=area(ngate_w1t) / W
]
DEVICE MN(nch_w_lvt) ngate_w1t_lvt poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_w1t_lvt, tndiff ) + perimeter_inside(ngate_w1t_lvt, tndiff)) / 2 
   L=area(ngate_w1t_lvt) / W
]
DEVICE MN(nchpd_dphcsr) ngate_spddphc poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spddphc, tndiff ) + perimeter_inside(ngate_spddphc, tndiff)) / 2 
   L=area(ngate_spddphc) / W
]
DEVICE MN(nchpd_dpsr) ngate_spddp poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spddp, tndiff ) + perimeter_inside(ngate_spddp, tndiff)) / 2 
   L=area(ngate_spddp) / W
]
DEVICE MN(nchpd_hvtdphcsr) ngate_hvspddphc poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_hvspddphc, tndiff ) + perimeter_inside(ngate_hvspddphc, tndiff)) / 2 
   L=area(ngate_hvspddphc) / W
]
DEVICE MN(nchpd_hvtdpsr) ngate_hvspddp poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_hvspddp, tndiff ) + perimeter_inside(ngate_hvspddp, tndiff)) / 2 
   L=area(ngate_hvspddp) / W
]
DEVICE MN(nchpd_hvtsr) ngate_hvspd poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_hvspd, tndiff ) + perimeter_inside(ngate_hvspd, tndiff)) / 2 
   L=area(ngate_hvspd) / W
]
DEVICE MN(nchpd_lpgdpsr) ngate_spdlpgdp poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spdlpgdp, tndiff ) + perimeter_inside(ngate_spdlpgdp, tndiff)) / 2 
   L=area(ngate_spdlpgdp) / W
]
DEVICE MN(nchpd_lpgsr) ngate_spdlpg poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spdlpg, tndiff ) + perimeter_inside(ngate_spdlpg, tndiff)) / 2 
   L=area(ngate_spdlpg) / W
]
DEVICE MN(nchpd_lpgtpsr) ngate_spdlpgtp poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spdlpgtp, tndiff ) + perimeter_inside(ngate_spdlpgtp, tndiff)) / 2 
   L=area(ngate_spdlpgtp) / W
]
DEVICE MN(nchpd_sr) ngate_spd poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spd, tndiff ) + perimeter_inside(ngate_spd, tndiff)) / 2 
   L=area(ngate_spd) / W
]
DEVICE MN(nchpd_ulpdpsr) ngate_spdulpdp poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spdulpdp, tndiff ) + perimeter_inside(ngate_spdulpdp, tndiff)) / 2 
   L=area(ngate_spdulpdp) / W
]
DEVICE MN(nchpd_ulpsr) ngate_spdulp poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spdulp, tndiff ) + perimeter_inside(ngate_spdulp, tndiff)) / 2 
   L=area(ngate_spdulp) / W
]
DEVICE MN(nchpd_wisr) ngate_spdwi poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spdwi, tndiff ) + perimeter_inside(ngate_spdwi, tndiff)) / 2 
   L=area(ngate_spdwi) / W
]
DEVICE MN(nchpd_wosr) ngate_spdwo poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spdwo, tndiff ) + perimeter_inside(ngate_spdwo, tndiff)) / 2 
   L=area(ngate_spdwo) / W
]
DEVICE MN(nchpg_dphcsr) ngate_spgdphc poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spgdphc, tndiff ) + perimeter_inside(ngate_spgdphc, tndiff)) / 2 
   L=area(ngate_spgdphc) / W
]
DEVICE MN(nchpg_dpsr) ngate_spgdp poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spgdp, tndiff ) + perimeter_inside(ngate_spgdp, tndiff)) / 2 
   L=area(ngate_spgdp) / W
]
DEVICE MN(nchpg_hvtdphcsr) ngate_hvspgdphc poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_hvspgdphc, tndiff ) + perimeter_inside(ngate_hvspgdphc, tndiff)) / 2 
   L=area(ngate_hvspgdphc) / W
]
DEVICE MN(nchpg_hvtdpsr) ngate_hvspgdp poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_hvspgdp, tndiff ) + perimeter_inside(ngate_hvspgdp, tndiff)) / 2 
   L=area(ngate_hvspgdp) / W
]
DEVICE MN(nchpg_hvtsr) ngate_hvspg poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_hvspg, tndiff ) + perimeter_inside(ngate_hvspg, tndiff)) / 2 
   L=area(ngate_hvspg) / W
]
DEVICE MN(nchpg_lpgdpsr) ngate_spglpgdp poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spglpgdp, tndiff ) + perimeter_inside(ngate_spglpgdp, tndiff)) / 2 
   L=area(ngate_spglpgdp) / W
]
DEVICE MN(nchpg_lpgsr) ngate_spglpg poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spglpg, tndiff ) + perimeter_inside(ngate_spglpg, tndiff)) / 2 
   L=area(ngate_spglpg) / W
]
DEVICE MN(nchpg_lpgtpsr) ngate_spglpgtp poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spglpgtp, tndiff ) + perimeter_inside(ngate_spglpgtp, tndiff)) / 2 
   L=area(ngate_spglpgtp) / W
]
DEVICE MN(nchpg_sr) ngate_spg poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spg, tndiff ) + perimeter_inside(ngate_spg, tndiff)) / 2 
   L=area(ngate_spg) / W
]
DEVICE MN(nchpg_ulpdpsr) ngate_spgulpdp poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spgulpdp, tndiff ) + perimeter_inside(ngate_spgulpdp, tndiff)) / 2 
   L=area(ngate_spgulpdp) / W
]
DEVICE MN(nchpg_ulpsr) ngate_spgulp poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spgulp, tndiff ) + perimeter_inside(ngate_spgulp, tndiff)) / 2 
   L=area(ngate_spgulp) / W
]
DEVICE MN(nchpg_wisr) ngate_spgwi poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spgwi, tndiff ) + perimeter_inside(ngate_spgwi, tndiff)) / 2 
   L=area(ngate_spgwi) / W
]
DEVICE MN(nchpg_wosr) ngate_spgwo poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spgwo, tndiff ) + perimeter_inside(ngate_spgwo, tndiff)) / 2 
   L=area(ngate_spgwo) / W
]
DEVICE MP(pch) pgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate, tpdiff ) + perimeter_inside(pgate, tpdiff)) / 2 
   L=area(pgate) / W
]
DEVICE MP(pch_18) pgate_18 poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_18, tpdiff ) + perimeter_inside(pgate_18, tpdiff)) / 2 
   L=area(pgate_18) / W
]
DEVICE MP(pch_18) pgate_18_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_18_mac, tpdiff ) + perimeter_inside(pgate_18_mac, tpdiff)) / 2 
   L=area(pgate_18_mac) / W
]
DEVICE MP(pch_25) pgate_25 poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_25, tpdiff ) + perimeter_inside(pgate_25, tpdiff)) / 2 
   L=area(pgate_25) / W
]
DEVICE MP(pch_25) pgate_25_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_25_mac, tpdiff ) + perimeter_inside(pgate_25_mac, tpdiff)) / 2 
   L=area(pgate_25_mac) / W
]
DEVICE MP(pch_25od) pgate_25od poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_25od, tpdiff ) + perimeter_inside(pgate_25od, tpdiff)) / 2 
   L=area(pgate_25od) / W
]
DEVICE MP(pch_25od28) pgate_25od28 poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_25od28, tpdiff ) + perimeter_inside(pgate_25od28, tpdiff)) / 2 
   L=area(pgate_25od28) / W
]
DEVICE MP(pch_25od28) pgate_25od28_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_25od28_mac, tpdiff ) + perimeter_inside(pgate_25od28_mac, tpdiff)) / 2 
   L=area(pgate_25od28_mac) / W
]
DEVICE MP(pch_25od) pgate_25od_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_25od_mac, tpdiff ) + perimeter_inside(pgate_25od_mac, tpdiff)) / 2 
   L=area(pgate_25od_mac) / W
]
DEVICE MP(pch_25ud) pgate_25ud poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_25ud, tpdiff ) + perimeter_inside(pgate_25ud, tpdiff)) / 2 
   L=area(pgate_25ud) / W
]
DEVICE MP(pch_25ud) pgate_25ud_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_25ud_mac, tpdiff ) + perimeter_inside(pgate_25ud_mac, tpdiff)) / 2 
   L=area(pgate_25ud_mac) / W
]
DEVICE MP(pch_33) pgate_33 poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_33, tpdiff ) + perimeter_inside(pgate_33, tpdiff)) / 2 
   L=area(pgate_33) / W
]
DEVICE MP(pch_33) pgate_33_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_33_mac, tpdiff ) + perimeter_inside(pgate_33_mac, tpdiff)) / 2 
   L=area(pgate_33_mac) / W
]
DEVICE MP(pch_edc) pgate_1tr poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_1tr, tpdiff ) + perimeter_inside(pgate_1tr, tpdiff)) / 2 
   L=area(pgate_1tr) / W
]
DEVICE MP(pch_hvt) phvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(phvgate, tpdiff ) + perimeter_inside(phvgate, tpdiff)) / 2 
   L=area(phvgate) / W
]
DEVICE MP(pch_hvt) phvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(phvgate_mac, tpdiff ) + perimeter_inside(phvgate_mac, tpdiff)) / 2 
   L=area(phvgate_mac) / W
]
DEVICE MP(pch_lpg) pgatelpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgatelpg, tpdiff ) + perimeter_inside(pgatelpg, tpdiff)) / 2 
   L=area(pgatelpg) / W
]
DEVICE MP(pch_lpghvt) phvgatelpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(phvgatelpg, tpdiff ) + perimeter_inside(phvgatelpg, tpdiff)) / 2 
   L=area(phvgatelpg) / W
]
DEVICE MP(pch_lvt) plvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(plvgate, tpdiff ) + perimeter_inside(plvgate, tpdiff)) / 2 
   L=area(plvgate) / W
]
DEVICE MP(pch_lvt) plvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(plvgate_mac, tpdiff ) + perimeter_inside(plvgate_mac, tpdiff)) / 2 
   L=area(plvgate_mac) / W
]
DEVICE MP(pch) pgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_mac, tpdiff ) + perimeter_inside(pgate_mac, tpdiff)) / 2 
   L=area(pgate_mac) / W
]
DEVICE MP(pch_mlvt) pilvtgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pilvtgate, tpdiff ) + perimeter_inside(pilvtgate, tpdiff)) / 2 
   L=area(pilvtgate) / W
]
DEVICE MP(pch_mlvt) pilvtgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pilvtgate_mac, tpdiff ) + perimeter_inside(pilvtgate_mac, tpdiff)) / 2 
   L=area(pilvtgate_mac) / W
]
DEVICE MP(pch_timer) pgate_st poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_st, tpdiff ) + perimeter_inside(pgate_st, tpdiff)) / 2 
   L=area(pgate_st) / W
]
DEVICE MP(pch_uhvt) puhvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(puhvgate, tpdiff ) + perimeter_inside(puhvgate, tpdiff)) / 2 
   L=area(puhvgate) / W
]
DEVICE MP(pch_uhvt) puhvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(puhvgate_mac, tpdiff ) + perimeter_inside(puhvgate_mac, tpdiff)) / 2 
   L=area(puhvgate_mac) / W
]
DEVICE MP(pch_ulvt) puvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(puvgate, tpdiff ) + perimeter_inside(puvgate, tpdiff)) / 2 
   L=area(puvgate) / W
]
DEVICE MP(pch_ulvt) puvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(puvgate_mac, tpdiff ) + perimeter_inside(puvgate_mac, tpdiff)) / 2 
   L=area(puvgate_mac) / W
]
DEVICE MP(pch_w) pgate_w1t poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_w1t, tpdiff ) + perimeter_inside(pgate_w1t, tpdiff)) / 2 
   L=area(pgate_w1t) / W
]
DEVICE MP(pch_w_lvt) pgate_w1t_lvt poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_w1t_lvt, tpdiff ) + perimeter_inside(pgate_w1t_lvt, tpdiff)) / 2 
   L=area(pgate_w1t_lvt) / W
]
DEVICE MP(pchpu_dphcsr) pgate_sdphc poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_sdphc, tpdiff ) + perimeter_inside(pgate_sdphc, tpdiff)) / 2 
   L=area(pgate_sdphc) / W
]
DEVICE MP(pchpu_dpsr) pgate_sdp poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_sdp, tpdiff ) + perimeter_inside(pgate_sdp, tpdiff)) / 2 
   L=area(pgate_sdp) / W
]
DEVICE MP(pchpu_hvtdphcsr) pgate_hvsdphc poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_hvsdphc, tpdiff ) + perimeter_inside(pgate_hvsdphc, tpdiff)) / 2 
   L=area(pgate_hvsdphc) / W
]
DEVICE MP(pchpu_hvtdpsr) pgate_hvsdp poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_hvsdp, tpdiff ) + perimeter_inside(pgate_hvsdp, tpdiff)) / 2 
   L=area(pgate_hvsdp) / W
]
DEVICE MP(pchpu_hvtsr) pgate_hvs poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_hvs, tpdiff ) + perimeter_inside(pgate_hvs, tpdiff)) / 2 
   L=area(pgate_hvs) / W
]
DEVICE MP(pchpu_lpgdpsr) pgate_sdplpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_sdplpg, tpdiff ) + perimeter_inside(pgate_sdplpg, tpdiff)) / 2 
   L=area(pgate_sdplpg) / W
]
DEVICE MP(pchpu_lpgsr) pgate_slpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_slpg, tpdiff ) + perimeter_inside(pgate_slpg, tpdiff)) / 2 
   L=area(pgate_slpg) / W
]
DEVICE MP(pchpu_lpgtpsr) pgate_stplpg poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_stplpg, tpdiff ) + perimeter_inside(pgate_stplpg, tpdiff)) / 2 
   L=area(pgate_stplpg) / W
]
DEVICE MP(pchpu_sr) pgate_s poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_s, tpdiff ) + perimeter_inside(pgate_s, tpdiff)) / 2 
   L=area(pgate_s) / W
]
DEVICE MP(pchpu_ulpdpsr) pgate_sdpulp poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_sdpulp, tpdiff ) + perimeter_inside(pgate_sdpulp, tpdiff)) / 2 
   L=area(pgate_sdpulp) / W
]
DEVICE MP(pchpu_ulpsr) pgate_sulp poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_sulp, tpdiff ) + perimeter_inside(pgate_sulp, tpdiff)) / 2 
   L=area(pgate_sulp) / W
]
DEVICE MP(pchpu_wisr) pgate_swi poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_swi, tpdiff ) + perimeter_inside(pgate_swi, tpdiff)) / 2 
   L=area(pgate_swi) / W
]
DEVICE MP(pchpu_wosr) pgate_swo poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_swo, tpdiff ) + perimeter_inside(pgate_swo, tpdiff)) / 2 
   L=area(pgate_swo) / W
]


#ENDIF

#ENDIF


//#IFNDEF RC_DECK
TRACE PROPERTY LDDP(pch_hv25_spw) L L 0
TRACE PROPERTY LDDP(pch_hv25_spw) W W 0
TRACE PROPERTY LDDN(nch_hv25_snw) L L 0
TRACE PROPERTY LDDN(nch_hv25_snw) W W 0
TRACE PROPERTY MN(nch) L L 0
TRACE PROPERTY MN(nch) W W 0
TRACE PROPERTY MN(nch_18) L L 0
TRACE PROPERTY MN(nch_18) W W 0
TRACE PROPERTY MN(nch_18_dnw) L L 0
TRACE PROPERTY MN(nch_18_dnw) W W 0
TRACE PROPERTY MN(nch_25) L L 0
TRACE PROPERTY MN(nch_25) W W 0
TRACE PROPERTY MN(nch_25_dnw) L L 0
TRACE PROPERTY MN(nch_25_dnw) W W 0
TRACE PROPERTY MN(nch_25_dnwod) L L 0
TRACE PROPERTY MN(nch_25_dnwod) W W 0
TRACE PROPERTY MN(nch_25_dnwud) L L 0
TRACE PROPERTY MN(nch_25_dnwud) W W 0
TRACE PROPERTY MN(nch_25od) L L 0
TRACE PROPERTY MN(nch_25od) W W 0
TRACE PROPERTY MN(nch_25od28) L L 0
TRACE PROPERTY MN(nch_25od28) W W 0
TRACE PROPERTY MN(nch_25od28_dnw) L L 0
TRACE PROPERTY MN(nch_25od28_dnw) W W 0
TRACE PROPERTY MN(nch_25ud) L L 0
TRACE PROPERTY MN(nch_25ud) W W 0
TRACE PROPERTY MN(nch_33) L L 0
TRACE PROPERTY MN(nch_33) W W 0
TRACE PROPERTY MN(nch_33_dnw) L L 0
TRACE PROPERTY MN(nch_33_dnw) W W 0
TRACE PROPERTY MN(nch_dnw) L L 0
TRACE PROPERTY MN(nch_dnw) W W 0
TRACE PROPERTY MN(nch_dnw_1tr) L L 0
TRACE PROPERTY MN(nch_dnw_1tr) W W 0
TRACE PROPERTY MN(nch_dnw_w) L L 0
TRACE PROPERTY MN(nch_dnw_w) W W 0
TRACE PROPERTY MN(nch_dnw_w_lvt) L L 0
TRACE PROPERTY MN(nch_dnw_w_lvt) W W 0
TRACE PROPERTY MN(nch_esd18) L L 0
TRACE PROPERTY MN(nch_esd18) W W 0
TRACE PROPERTY MN(nch_esd18_dnw) L L 0
TRACE PROPERTY MN(nch_esd18_dnw) W W 0
TRACE PROPERTY MN(nch_hvt) L L 0
TRACE PROPERTY MN(nch_hvt) W W 0
TRACE PROPERTY MN(nch_hvt_dnw) L L 0
TRACE PROPERTY MN(nch_hvt_dnw) W W 0
TRACE PROPERTY MN(nch_lpg) L L 0
TRACE PROPERTY MN(nch_lpg) W W 0
TRACE PROPERTY MN(nch_lpghvt) L L 0
TRACE PROPERTY MN(nch_lpghvt) W W 0
TRACE PROPERTY MN(nch_lpgna) L L 0
TRACE PROPERTY MN(nch_lpgna) W W 0
TRACE PROPERTY MN(nch_lvt) L L 0
TRACE PROPERTY MN(nch_lvt) W W 0
TRACE PROPERTY MN(nch_lvt_dnw) L L 0
TRACE PROPERTY MN(nch_lvt_dnw) W W 0
TRACE PROPERTY MN(nch_mlvt) L L 0
TRACE PROPERTY MN(nch_mlvt) W W 0
TRACE PROPERTY MN(nch_mlvt_dnw) L L 0
TRACE PROPERTY MN(nch_mlvt_dnw) W W 0
TRACE PROPERTY MN(nch_na) L L 0
TRACE PROPERTY MN(nch_na) W W 0
TRACE PROPERTY MN(nch_na18) L L 0
TRACE PROPERTY MN(nch_na18) W W 0
TRACE PROPERTY MN(nch_na25) L L 0
TRACE PROPERTY MN(nch_na25) W W 0
TRACE PROPERTY MN(nch_na25od) L L 0
TRACE PROPERTY MN(nch_na25od) W W 0
TRACE PROPERTY MN(nch_na25ud) L L 0
TRACE PROPERTY MN(nch_na25ud) W W 0
TRACE PROPERTY MN(nch_na33) L L 0
TRACE PROPERTY MN(nch_na33) W W 0
TRACE PROPERTY MN(nch_timer) L L 0
TRACE PROPERTY MN(nch_timer) W W 0
TRACE PROPERTY MN(nch_uhvt) L L 0
TRACE PROPERTY MN(nch_uhvt) W W 0
TRACE PROPERTY MN(nch_uhvt_dnw) L L 0
TRACE PROPERTY MN(nch_uhvt_dnw) W W 0
TRACE PROPERTY MN(nch_ulvt) L L 0
TRACE PROPERTY MN(nch_ulvt) W W 0
TRACE PROPERTY MN(nch_ulvt_dnw) L L 0
TRACE PROPERTY MN(nch_ulvt_dnw) W W 0
TRACE PROPERTY MN(nch_w) L L 0
TRACE PROPERTY MN(nch_w) W W 0
TRACE PROPERTY MN(nch_w_lvt) L L 0
TRACE PROPERTY MN(nch_w_lvt) W W 0
TRACE PROPERTY MN(nchpd_dphcsr) L L 0
TRACE PROPERTY MN(nchpd_dphcsr) W W 0
TRACE PROPERTY MN(nchpd_dpsr) L L 0
TRACE PROPERTY MN(nchpd_dpsr) W W 0
TRACE PROPERTY MN(nchpd_hvtdphcsr) L L 0
TRACE PROPERTY MN(nchpd_hvtdphcsr) W W 0
TRACE PROPERTY MN(nchpd_hvtdpsr) L L 0
TRACE PROPERTY MN(nchpd_hvtdpsr) W W 0
TRACE PROPERTY MN(nchpd_hvtsr) L L 0
TRACE PROPERTY MN(nchpd_hvtsr) W W 0
TRACE PROPERTY MN(nchpd_lpgdpsr) L L 0
TRACE PROPERTY MN(nchpd_lpgdpsr) W W 0
TRACE PROPERTY MN(nchpd_lpgsr) L L 0
TRACE PROPERTY MN(nchpd_lpgsr) W W 0
TRACE PROPERTY MN(nchpd_lpgtpsr) L L 0
TRACE PROPERTY MN(nchpd_lpgtpsr) W W 0
TRACE PROPERTY MN(nchpd_sr) L L 0
TRACE PROPERTY MN(nchpd_sr) W W 0
TRACE PROPERTY MN(nchpd_ulpdpsr) L L 0
TRACE PROPERTY MN(nchpd_ulpdpsr) W W 0
TRACE PROPERTY MN(nchpd_ulpsr) L L 0
TRACE PROPERTY MN(nchpd_ulpsr) W W 0
TRACE PROPERTY MN(nchpd_wisr) L L 0
TRACE PROPERTY MN(nchpd_wisr) W W 0
TRACE PROPERTY MN(nchpd_wosr) L L 0
TRACE PROPERTY MN(nchpd_wosr) W W 0
TRACE PROPERTY MN(nchpg_dphcsr) L L 0
TRACE PROPERTY MN(nchpg_dphcsr) W W 0
TRACE PROPERTY MN(nchpg_dpsr) L L 0
TRACE PROPERTY MN(nchpg_dpsr) W W 0
TRACE PROPERTY MN(nchpg_hvtdphcsr) L L 0
TRACE PROPERTY MN(nchpg_hvtdphcsr) W W 0
TRACE PROPERTY MN(nchpg_hvtdpsr) L L 0
TRACE PROPERTY MN(nchpg_hvtdpsr) W W 0
TRACE PROPERTY MN(nchpg_hvtsr) L L 0
TRACE PROPERTY MN(nchpg_hvtsr) W W 0
TRACE PROPERTY MN(nchpg_lpgdpsr) L L 0
TRACE PROPERTY MN(nchpg_lpgdpsr) W W 0
TRACE PROPERTY MN(nchpg_lpgsr) L L 0
TRACE PROPERTY MN(nchpg_lpgsr) W W 0
TRACE PROPERTY MN(nchpg_lpgtpsr) L L 0
TRACE PROPERTY MN(nchpg_lpgtpsr) W W 0
TRACE PROPERTY MN(nchpg_sr) L L 0
TRACE PROPERTY MN(nchpg_sr) W W 0
TRACE PROPERTY MN(nchpg_ulpdpsr) L L 0
TRACE PROPERTY MN(nchpg_ulpdpsr) W W 0
TRACE PROPERTY MN(nchpg_ulpsr) L L 0
TRACE PROPERTY MN(nchpg_ulpsr) W W 0
TRACE PROPERTY MN(nchpg_wisr) L L 0
TRACE PROPERTY MN(nchpg_wisr) W W 0
TRACE PROPERTY MN(nchpg_wosr) L L 0
TRACE PROPERTY MN(nchpg_wosr) W W 0
TRACE PROPERTY MP(pch) L L 0
TRACE PROPERTY MP(pch) W W 0
TRACE PROPERTY MP(pch_18) L L 0
TRACE PROPERTY MP(pch_18) W W 0
TRACE PROPERTY MP(pch_25) L L 0
TRACE PROPERTY MP(pch_25) W W 0
TRACE PROPERTY MP(pch_25od) L L 0
TRACE PROPERTY MP(pch_25od) W W 0
TRACE PROPERTY MP(pch_25od28) L L 0
TRACE PROPERTY MP(pch_25od28) W W 0
TRACE PROPERTY MP(pch_25ud) L L 0
TRACE PROPERTY MP(pch_25ud) W W 0
TRACE PROPERTY MP(pch_33) L L 0
TRACE PROPERTY MP(pch_33) W W 0
TRACE PROPERTY MP(pch_edc) L L 0
TRACE PROPERTY MP(pch_edc) W W 0
TRACE PROPERTY MP(pch_hvt) L L 0
TRACE PROPERTY MP(pch_hvt) W W 0
TRACE PROPERTY MP(pch_lpg) L L 0
TRACE PROPERTY MP(pch_lpg) W W 0
TRACE PROPERTY MP(pch_lpghvt) L L 0
TRACE PROPERTY MP(pch_lpghvt) W W 0
TRACE PROPERTY MP(pch_lvt) L L 0
TRACE PROPERTY MP(pch_lvt) W W 0
TRACE PROPERTY MP(pch_mlvt) L L 0
TRACE PROPERTY MP(pch_mlvt) W W 0
TRACE PROPERTY MP(pch_timer) L L 0
TRACE PROPERTY MP(pch_timer) W W 0
TRACE PROPERTY MP(pch_uhvt) L L 0
TRACE PROPERTY MP(pch_uhvt) W W 0
TRACE PROPERTY MP(pch_ulvt) L L 0
TRACE PROPERTY MP(pch_ulvt) W W 0
TRACE PROPERTY MP(pch_w) L L 0
TRACE PROPERTY MP(pch_w) W W 0
TRACE PROPERTY MP(pch_w_lvt) L L 0
TRACE PROPERTY MP(pch_w_lvt) W W 0
TRACE PROPERTY MP(pchpu_dphcsr) L L 0
TRACE PROPERTY MP(pchpu_dphcsr) W W 0
TRACE PROPERTY MP(pchpu_dpsr) L L 0
TRACE PROPERTY MP(pchpu_dpsr) W W 0
TRACE PROPERTY MP(pchpu_hvtdphcsr) L L 0
TRACE PROPERTY MP(pchpu_hvtdphcsr) W W 0
TRACE PROPERTY MP(pchpu_hvtdpsr) L L 0
TRACE PROPERTY MP(pchpu_hvtdpsr) W W 0
TRACE PROPERTY MP(pchpu_hvtsr) L L 0
TRACE PROPERTY MP(pchpu_hvtsr) W W 0
TRACE PROPERTY MP(pchpu_lpgdpsr) L L 0
TRACE PROPERTY MP(pchpu_lpgdpsr) W W 0
TRACE PROPERTY MP(pchpu_lpgsr) L L 0
TRACE PROPERTY MP(pchpu_lpgsr) W W 0
TRACE PROPERTY MP(pchpu_lpgtpsr) L L 0
TRACE PROPERTY MP(pchpu_lpgtpsr) W W 0
TRACE PROPERTY MP(pchpu_sr) L L 0
TRACE PROPERTY MP(pchpu_sr) W W 0
TRACE PROPERTY MP(pchpu_ulpdpsr) L L 0
TRACE PROPERTY MP(pchpu_ulpdpsr) W W 0
TRACE PROPERTY MP(pchpu_ulpsr) L L 0
TRACE PROPERTY MP(pchpu_ulpsr) W W 0
TRACE PROPERTY MP(pchpu_wisr) L L 0
TRACE PROPERTY MP(pchpu_wisr) W W 0
TRACE PROPERTY MP(pchpu_wosr) L L 0
TRACE PROPERTY MP(pchpu_wosr) W W 0
//#ENDIF

#IFDEF RC_DECK
DEVICE Q(npn10) cnemit10 ncoll1 cpbase1 cnemit1 netlist model npn10
#ELSE
  DEVICE Q(npn10) cnemit10 ncoll1 cpbase1 cnemit1 [
		property A
		A = area(cnemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(npn10) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(npn10) cnemit10_mac ncoll1 cpbase1 cnemit1 netlist element "X" netlist model npn10_mis
#ELSE
  DEVICE Q(npn10) cnemit10_mac ncoll1 cpbase1 cnemit1 [
		property A
		A = area(cnemit1)
  ]
#ENDIF
#IFDEF RC_DECK
DEVICE Q(npn10_s) cnemit10s ncoll1 cpbase1 cnemit1 netlist model npn10_s
#ELSE
  DEVICE Q(npn10_s) cnemit10s ncoll1 cpbase1 cnemit1 [
		property A
		A = area(cnemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(npn10_s) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(npn10_s) cnemit10s_mac ncoll1 cpbase1 cnemit1 netlist element "X" netlist model npn10_s_mis
#ELSE
  DEVICE Q(npn10_s) cnemit10s_mac ncoll1 cpbase1 cnemit1 [
		property A
		A = area(cnemit1)
  ]
#ENDIF
#IFDEF RC_DECK
DEVICE Q(npn2) cnemit2 ncoll1 cpbase1 cnemit1 netlist model npn2
#ELSE
  DEVICE Q(npn2) cnemit2 ncoll1 cpbase1 cnemit1 [
		property A
		A = area(cnemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(npn2) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(npn2) cnemit2_mac ncoll1 cpbase1 cnemit1 netlist element "X" netlist model npn2_mis
#ELSE
  DEVICE Q(npn2) cnemit2_mac ncoll1 cpbase1 cnemit1 [
		property A
		A = area(cnemit1)
  ]
#ENDIF
#IFDEF RC_DECK
DEVICE Q(npn2_s) cnemit2s ncoll1 cpbase1 cnemit1 netlist model npn2_s
#ELSE
  DEVICE Q(npn2_s) cnemit2s ncoll1 cpbase1 cnemit1 [
		property A
		A = area(cnemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(npn2_s) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(npn2_s) cnemit2s_mac ncoll1 cpbase1 cnemit1 netlist element "X" netlist model npn2_s_mis
#ELSE
  DEVICE Q(npn2_s) cnemit2s_mac ncoll1 cpbase1 cnemit1 [
		property A
		A = area(cnemit1)
  ]
#ENDIF
#IFDEF RC_DECK
DEVICE Q(npn5) cnemit5 ncoll1 cpbase1 cnemit1 netlist model npn5
#ELSE
  DEVICE Q(npn5) cnemit5 ncoll1 cpbase1 cnemit1 [
		property A
		A = area(cnemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(npn5) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(npn5) cnemit5_mac ncoll1 cpbase1 cnemit1 netlist element "X" netlist model npn5_mis
#ELSE
  DEVICE Q(npn5) cnemit5_mac ncoll1 cpbase1 cnemit1 [
		property A
		A = area(cnemit1)
  ]
#ENDIF
#IFDEF RC_DECK
DEVICE Q(npn5_s) cnemit5s ncoll1 cpbase1 cnemit1 netlist model npn5_s
#ELSE
  DEVICE Q(npn5_s) cnemit5s ncoll1 cpbase1 cnemit1 [
		property A
		A = area(cnemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(npn5_s) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(npn5_s) cnemit5s_mac ncoll1 cpbase1 cnemit1 netlist element "X" netlist model npn5_s_mis
#ELSE
  DEVICE Q(npn5_s) cnemit5s_mac ncoll1 cpbase1 cnemit1 [
		property A
		A = area(cnemit1)
  ]
#ENDIF
#IFDEF RC_DECK
DEVICE Q(pnp10) cemit10 coll1 cnbase1 cemit1 netlist model pnp10
#ELSE
  DEVICE Q(pnp10) cemit10 coll1 cnbase1 cemit1 [
		property A
		A = area(cemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp10) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp10) cemit10_mac coll1 cnbase1 cemit1 netlist element "X" netlist model pnp10_mis
#ELSE
  DEVICE Q(pnp10) cemit10_mac coll1 cnbase1 cemit1 [
		property A
		A = area(cemit1)
  ]
#ENDIF
#IFDEF RC_DECK
DEVICE Q(pnp10_s) cemit10s coll1 cnbase1 cemit1 netlist model pnp10_s
#ELSE
  DEVICE Q(pnp10_s) cemit10s coll1 cnbase1 cemit1 [
		property A
		A = area(cemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp10_s) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp10_s) cemit10s_mac coll1 cnbase1 cemit1 netlist element "X" netlist model pnp10_s_mis
#ELSE
  DEVICE Q(pnp10_s) cemit10s_mac coll1 cnbase1 cemit1 [
		property A
		A = area(cemit1)
  ]
#ENDIF
#IFDEF RC_DECK
DEVICE Q(pnp2) cemit2 coll1 cnbase1 cemit1 netlist model pnp2
#ELSE
  DEVICE Q(pnp2) cemit2 coll1 cnbase1 cemit1 [
		property A
		A = area(cemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp2) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp2) cemit2_mac coll1 cnbase1 cemit1 netlist element "X" netlist model pnp2_mis
#ELSE
  DEVICE Q(pnp2) cemit2_mac coll1 cnbase1 cemit1 [
		property A
		A = area(cemit1)
  ]
#ENDIF
#IFDEF RC_DECK
DEVICE Q(pnp2_s) cemit2s coll1 cnbase1 cemit1 netlist model pnp2_s
#ELSE
  DEVICE Q(pnp2_s) cemit2s coll1 cnbase1 cemit1 [
		property A
		A = area(cemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp2_s) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp2_s) cemit2s_mac coll1 cnbase1 cemit1 netlist element "X" netlist model pnp2_s_mis
#ELSE
  DEVICE Q(pnp2_s) cemit2s_mac coll1 cnbase1 cemit1 [
		property A
		A = area(cemit1)
  ]
#ENDIF
#IFDEF RC_DECK
DEVICE Q(pnp5) cemit5 coll1 cnbase1 cemit1 netlist model pnp5
#ELSE
  DEVICE Q(pnp5) cemit5 coll1 cnbase1 cemit1 [
		property A
		A = area(cemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp5) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp5) cemit5_mac coll1 cnbase1 cemit1 netlist element "X" netlist model pnp5_mis
#ELSE
  DEVICE Q(pnp5) cemit5_mac coll1 cnbase1 cemit1 [
		property A
		A = area(cemit1)
  ]
#ENDIF
#IFDEF RC_DECK
DEVICE Q(pnp5_s) cemit5s coll1 cnbase1 cemit1 netlist model pnp5_s
#ELSE
  DEVICE Q(pnp5_s) cemit5s coll1 cnbase1 cemit1 [
		property A
		A = area(cemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp5_s) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp5_s) cemit5s_mac coll1 cnbase1 cemit1 netlist element "X" netlist model pnp5_s_mis
#ELSE
  DEVICE Q(pnp5_s) cemit5s_mac coll1 cnbase1 cemit1 [
		property A
		A = area(cemit1)
  ]
#ENDIF
DEVICE D(ndio) cndio psub tndiff netlist model ndio
  TRACE PROPERTY D(ndio) A A 0
DEVICE D(ndio_18) indio_18 psub tndiff netlist model ndio_18
  TRACE PROPERTY D(ndio_18) A A 0
DEVICE D(ndio_25) indio_25 psub tndiff netlist model ndio_25
  TRACE PROPERTY D(ndio_25) A A 0
DEVICE D(ndio_25od) indio_25od psub tndiff netlist model ndio_33
  TRACE PROPERTY D(ndio_25od) A A 0
DEVICE D(ndio_25od28) indio_25od28 psub tndiff netlist model ndio_25od28
  TRACE PROPERTY D(ndio_25od28) A A 0
DEVICE D(ndio_25ud) indio_25ud psub tndiff netlist model ndio_18
  TRACE PROPERTY D(ndio_25ud) A A 0
DEVICE D(ndio_33) indio_33 psub tndiff netlist model ndio_33
  TRACE PROPERTY D(ndio_33) A A 0
DEVICE D(ndio_esd) ydio psub tndiff netlist model ndio_esd
  TRACE PROPERTY D(ndio_esd) A A 0
DEVICE D(ndio_hvt) ndioh psub tndiff netlist model ndio_hvt
  TRACE PROPERTY D(ndio_hvt) A A 0
DEVICE D(ndio_lpg) cndiolpg psub tndiff netlist model ndio_lpg
  TRACE PROPERTY D(ndio_lpg) A A 0
DEVICE D(ndio_lpghvt) ndiohlpg psub tndiff netlist model ndio_lpghvt
  TRACE PROPERTY D(ndio_lpghvt) A A 0
DEVICE D(ndio_lpgna) cndionlpg psub tndiff netlist model ndio_lpgna
  TRACE PROPERTY D(ndio_lpgna) A A 0
DEVICE D(ndio_lvt) ndiol psub tndiff netlist model ndio_lvt
  TRACE PROPERTY D(ndio_lvt) A A 0
DEVICE D(ndio_mlvt) cndioilvt psub tndiff netlist model ndio_mlvt
  TRACE PROPERTY D(ndio_mlvt) A A 0
DEVICE D(ndio_na) cndion psub tndiff netlist model ndio_na
  TRACE PROPERTY D(ndio_na) A A 0
DEVICE D(ndio_na18) ndio_18na psub tndiff netlist model ndio_na18
  TRACE PROPERTY D(ndio_na18) A A 0
DEVICE D(ndio_na25) ndio_25na psub tndiff netlist model ndio_na25
  TRACE PROPERTY D(ndio_na25) A A 0
DEVICE D(ndio_na25od) ndio_25naod psub tndiff netlist model ndio_na25od33
  TRACE PROPERTY D(ndio_na25od) A A 0
DEVICE D(ndio_na25ud) ndio_25naud psub tndiff netlist model ndio_na18
  TRACE PROPERTY D(ndio_na25ud) A A 0
DEVICE D(ndio_na33) ndio_33na psub tndiff netlist model ndio_na33
  TRACE PROPERTY D(ndio_na33) A A 0
DEVICE D(ndio_uhvt) ndiouh psub tndiff netlist model ndio_uhvt
  TRACE PROPERTY D(ndio_uhvt) A A 0
DEVICE D(ndio_w) endio psub tndiff netlist model ndio_w
  TRACE PROPERTY D(ndio_w) A A 0
DEVICE D(nwdio) cnwdio psub nxwell netlist model nwdio
  TRACE PROPERTY D(nwdio) A A 0
DEVICE D(nwdio_18) inwdio_18 psub nxwell netlist model nwdio_18
  TRACE PROPERTY D(nwdio_18) A A 0
DEVICE D(nwdio_25) inwdio_25 psub nxwell netlist model nwdio_25
  TRACE PROPERTY D(nwdio_25) A A 0
DEVICE D(nwdio_33) inwdio_33 psub nxwell netlist model nwdio_33
  TRACE PROPERTY D(nwdio_33) A A 0
DEVICE D(pdio) cpdio tpdiff nxwell netlist model pdio
  TRACE PROPERTY D(pdio) A A 0
DEVICE D(pdio_18) ipdio_18 tpdiff nxwell netlist model pdio_18
  TRACE PROPERTY D(pdio_18) A A 0
DEVICE D(pdio_25) ipdio_25 tpdiff nxwell netlist model pdio_25
  TRACE PROPERTY D(pdio_25) A A 0
DEVICE D(pdio_25od) ipdio_25od tpdiff nxwell netlist model pdio_33
  TRACE PROPERTY D(pdio_25od) A A 0
DEVICE D(pdio_25od28) ipdio_25od28 tpdiff nxwell netlist model pdio_25od28
  TRACE PROPERTY D(pdio_25od28) A A 0
DEVICE D(pdio_25ud) ipdio_25ud tpdiff nxwell netlist model pdio_18
  TRACE PROPERTY D(pdio_25ud) A A 0
DEVICE D(pdio_33) ipdio_33 tpdiff nxwell netlist model pdio_33
  TRACE PROPERTY D(pdio_33) A A 0
DEVICE D(pdio_hvt) pdioh tpdiff nxwell netlist model pdio_hvt
  TRACE PROPERTY D(pdio_hvt) A A 0
DEVICE D(pdio_lpg) cpdiolpg tpdiff nxwell netlist model pdio_lpg
  TRACE PROPERTY D(pdio_lpg) A A 0
DEVICE D(pdio_lpghvt) pdiohlpg tpdiff nxwell netlist model pdio_lpghvt
  TRACE PROPERTY D(pdio_lpghvt) A A 0
DEVICE D(pdio_lvt) pdiol tpdiff nxwell netlist model pdio_lvt
  TRACE PROPERTY D(pdio_lvt) A A 0
DEVICE D(pdio_mlvt) pdioilvt tpdiff nxwell netlist model pdio_mlvt
  TRACE PROPERTY D(pdio_mlvt) A A 0
DEVICE D(pdio_uhvt) pdiouh tpdiff nxwell netlist model pdio_uhvt
  TRACE PROPERTY D(pdio_uhvt) A A 0
DEVICE D(pdio_w) epdio tpdiff nxwell netlist model pdio_w
  TRACE PROPERTY D(pdio_w) A A 0
DEVICE C(CM) mim_r p3 crown
DEVICE C(CM_decap) mim_r_decap p3 crown

// User define devices 



F_reg1a = EXT MOM_field1 < 0.29 OPPOSITE REGION 
F_reg1  = ( F_reg1a AND MOMDMY1 ) NOT M1
F_reg2a = EXT MOM_field2 < 0.29 OPPOSITE REGION 
F_reg2  = ( F_reg2a AND MOMDMY2 ) NOT M2
F_reg3a = EXT MOM_field3 < 0.29 OPPOSITE REGION 
F_reg3  = ( F_reg3a AND MOMDMY3 ) NOT M3
F_reg4a = EXT MOM_field4 < 0.29 OPPOSITE REGION 
F_reg4  = ( F_reg4a AND MOMDMY4 ) NOT M4
F_reg5a = EXT MOM_field5 < 0.29 OPPOSITE REGION 
F_reg5  = ( F_reg5a AND MOMDMY5 ) NOT M5






mom13_1 = MOMDMY3 INTERACT MOM_field1

mom13_2 = mom13_1 INTERACT MOM_field2

mom13_3 = mom13_2 INTERACT MOM_field3


mom13_Left4 = mom13_3 NOT INTERACT MOM_field4
mom13_Left5 = mom13_Left4 NOT INTERACT MOM_field5
mom13_Left6 = mom13_Left5 NOT INTERACT MOM_field6
mom13_Left7 = mom13_Left6 NOT INTERACT MOM_field7


mom13_reg1 = mom13_Left7 NOT INTERACT RFDMY
mom13_reg2 = mom13_reg1 NOT MOMDMY22
mom13_reg3 = mom13_reg2 NOT MAC
mom13_reg4 = mom13_reg3 NOT INTERACT MOMDMY_2T
mom13_reg  = mom13_reg4 INTERACT poly			// RTMOM_3T
mom13_reg_2t = mom13_reg3 INTERACT MOMDMY_2T		// RTMOM_2T
mom13_reg_rf1 = mom13_Left7 INTERACT RFDMY
mom13_reg_rf2 = mom13_reg_rf1 NOT MOMDMY22 
mom13_reg_rf3 = mom13_reg_rf2 NOT MAC
mom13_reg_rf  = mom13_reg_rf3 NOT RDKDMY
mom13_reg_rf_rdk  = mom13_reg_rf3 AND RDKDMY

mom13_mx_reg1 = MOMDMY22 INTERACT mom13_Left7
mom13_mx_reg2 = mom13_mx_reg1 NOT MAC
mom13_mx_reg3 = mom13_mx_reg2 NOT INTERACT MOMDMY_2T
mom13_mx_reg  = mom13_mx_reg3 INTERACT poly		// RTMOM_MX 5T
mom13_mx_reg_4t = mom13_mx_reg2 INTERACT MOMDMY_2T	// RTMOM_MX 4T
mom13_mx_aux1 = mom13_Left7 AND MOMDMY22
mom13_mx_aux  = mom13_mx_aux1 NOT MAC
mom13_freg  = mom13_reg2 AND MAC
mom13_mx_freg  = mom13_mx_reg1 AND MAC
mom13_mx_faux  = mom13_mx_aux1 AND MAC



DEVICE crtmom mom13_reg metal3(PLUS) metal3(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom13_reg)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 3
]
DEVICE crtmom_2t mom13_reg_2t metal3(PLUS) metal3(MINUS) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom13_reg_2t)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 3
]
DEVICE crtmom_rf mom13_reg_rf metal3(PLUS) metal3(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom13_reg_rf)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 3
]

DEVICE crtmom_rf_rdk mom13_reg_rf_rdk metal3(PLUS) metal3(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom13_reg_rf_rdk)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 3
]

DEVICE crtmom_mx mom13_mx_reg mom3p1(PLUS1) mom3m1(MINUS1) mom3p2(PLUS2) mom3m2(MINUS2) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom13_mx_aux> <metal3> [
    property w,s,nv,nh,stm,spm,mf
    mf1 = count(metal3)-2
    mf = mf1/2
    nv = count(MOM_field1)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom13_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nv-1))
    stm = 1
    spm = 3
]
DEVICE fmom mom13_freg metal3(PLUS) metal3(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field1)
    w =  perimeter_coincide(MOM_field2,mom13_freg)/ nr 
    lr = (area(MOM_field1)/nr)/w
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nr-1)
    stm = 1
    spm = 3
]

DEVICE fmom_mx mom13_mx_freg mom3p1(PLUS1) mom3m1(MINUS1) mom3p2(PLUS2) mom3m2(MINUS2) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom13_mx_faux> <metal3> [
    property w,s,nr,lr,stm,spm,mf
    mf1 = count(metal3)-2
    mf = mf1/2
    nr = count(MOM_field1)/mf1
    w = perimeter_coincide(MOM_field2,mom13_mx_faux)/(nr*mf1)
    lr = (area(MOM_field1)/(nr*mf1))/w
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nr-1))
    stm = 1
    spm = 3  
]






mom14_1 = MOMDMY4 INTERACT MOM_field1

mom14_2 = mom14_1 INTERACT MOM_field2

mom14_3 = mom14_2 INTERACT MOM_field3

mom14_4 = mom14_3 INTERACT MOM_field4


mom14_Left5 = mom14_4 NOT INTERACT MOM_field5
mom14_Left6 = mom14_Left5 NOT INTERACT MOM_field6
mom14_Left7 = mom14_Left6 NOT INTERACT MOM_field7


mom14_reg1 = mom14_Left7 NOT INTERACT RFDMY
mom14_reg2 = mom14_reg1 NOT MOMDMY22
mom14_reg3 = mom14_reg2 NOT MAC
mom14_reg4 = mom14_reg3 NOT INTERACT MOMDMY_2T
mom14_reg  = mom14_reg4 INTERACT poly			// RTMOM_3T
mom14_reg_2t = mom14_reg3 INTERACT MOMDMY_2T		// RTMOM_2T
mom14_reg_rf1 = mom14_Left7 INTERACT RFDMY
mom14_reg_rf2 = mom14_reg_rf1 NOT MOMDMY22 
mom14_reg_rf3 = mom14_reg_rf2 NOT MAC
mom14_reg_rf  = mom14_reg_rf3 NOT RDKDMY
mom14_reg_rf_rdk  = mom14_reg_rf3 AND RDKDMY

mom14_mx_reg1 = MOMDMY22 INTERACT mom14_Left7
mom14_mx_reg2 = mom14_mx_reg1 NOT MAC
mom14_mx_reg3 = mom14_mx_reg2 NOT INTERACT MOMDMY_2T
mom14_mx_reg  = mom14_mx_reg3 INTERACT poly		// RTMOM_MX 5T
mom14_mx_reg_4t = mom14_mx_reg2 INTERACT MOMDMY_2T	// RTMOM_MX 4T
mom14_mx_aux1 = mom14_Left7 AND MOMDMY22
mom14_mx_aux  = mom14_mx_aux1 NOT MAC
mom14_freg  = mom14_reg2 AND MAC
mom14_mx_freg  = mom14_mx_reg1 AND MAC
mom14_mx_faux  = mom14_mx_aux1 AND MAC



DEVICE crtmom mom14_reg metal4(PLUS) metal4(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom14_reg)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 4
]
DEVICE crtmom_2t mom14_reg_2t metal4(PLUS) metal4(MINUS) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom14_reg_2t)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 4
]
DEVICE crtmom_rf mom14_reg_rf metal4(PLUS) metal4(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom14_reg_rf)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 4
]

DEVICE crtmom_rf_rdk mom14_reg_rf_rdk metal4(PLUS) metal4(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom14_reg_rf_rdk)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 4
]

DEVICE crtmom_mx mom14_mx_reg mom4p1(PLUS1) mom4m1(MINUS1) mom4p2(PLUS2) mom4m2(MINUS2) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom14_mx_aux> <metal4> [
    property w,s,nv,nh,stm,spm,mf
    mf1 = count(metal4)-2
    mf = mf1/2
    nv = count(MOM_field1)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom14_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nv-1))
    stm = 1
    spm = 4
]
DEVICE fmom mom14_freg metal4(PLUS) metal4(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field1)
    w =  perimeter_coincide(MOM_field2,mom14_freg)/ nr 
    lr = (area(MOM_field1)/nr)/w
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nr-1)
    stm = 1
    spm = 4
]

DEVICE fmom_mx mom14_mx_freg mom4p1(PLUS1) mom4m1(MINUS1) mom4p2(PLUS2) mom4m2(MINUS2) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom14_mx_faux> <metal4> [
    property w,s,nr,lr,stm,spm,mf
    mf1 = count(metal4)-2
    mf = mf1/2
    nr = count(MOM_field1)/mf1
    w = perimeter_coincide(MOM_field2,mom14_mx_faux)/(nr*mf1)
    lr = (area(MOM_field1)/(nr*mf1))/w
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nr-1))
    stm = 1
    spm = 4  
]






mom15_1 = MOMDMY5 INTERACT MOM_field1

mom15_2 = mom15_1 INTERACT MOM_field2

mom15_3 = mom15_2 INTERACT MOM_field3

mom15_4 = mom15_3 INTERACT MOM_field4

mom15_5 = mom15_4 INTERACT MOM_field5


mom15_Left6 = mom15_5 NOT INTERACT MOM_field6
mom15_Left7 = mom15_Left6 NOT INTERACT MOM_field7


mom15_reg1 = mom15_Left7 NOT INTERACT RFDMY
mom15_reg2 = mom15_reg1 NOT MOMDMY22
mom15_reg3 = mom15_reg2 NOT MAC
mom15_reg4 = mom15_reg3 NOT INTERACT MOMDMY_2T
mom15_reg  = mom15_reg4 INTERACT poly			// RTMOM_3T
mom15_reg_2t = mom15_reg3 INTERACT MOMDMY_2T		// RTMOM_2T
mom15_reg_rf1 = mom15_Left7 INTERACT RFDMY
mom15_reg_rf2 = mom15_reg_rf1 NOT MOMDMY22 
mom15_reg_rf3 = mom15_reg_rf2 NOT MAC
mom15_reg_rf  = mom15_reg_rf3 NOT RDKDMY
mom15_reg_rf_rdk  = mom15_reg_rf3 AND RDKDMY

mom15_mx_reg1 = MOMDMY22 INTERACT mom15_Left7
mom15_mx_reg2 = mom15_mx_reg1 NOT MAC
mom15_mx_reg3 = mom15_mx_reg2 NOT INTERACT MOMDMY_2T
mom15_mx_reg  = mom15_mx_reg3 INTERACT poly		// RTMOM_MX 5T
mom15_mx_reg_4t = mom15_mx_reg2 INTERACT MOMDMY_2T	// RTMOM_MX 4T
mom15_mx_aux1 = mom15_Left7 AND MOMDMY22
mom15_mx_aux  = mom15_mx_aux1 NOT MAC
mom15_freg  = mom15_reg2 AND MAC
mom15_mx_freg  = mom15_mx_reg1 AND MAC
mom15_mx_faux  = mom15_mx_aux1 AND MAC



DEVICE crtmom mom15_reg metal5(PLUS) metal5(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom15_reg)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 5
]
DEVICE crtmom_2t mom15_reg_2t metal5(PLUS) metal5(MINUS) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom15_reg_2t)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 5
]
DEVICE crtmom_rf mom15_reg_rf metal5(PLUS) metal5(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom15_reg_rf)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 5
]

DEVICE crtmom_rf_rdk mom15_reg_rf_rdk metal5(PLUS) metal5(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom15_reg_rf_rdk)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 5
]

DEVICE crtmom_mx mom15_mx_reg mom5p1(PLUS1) mom5m1(MINUS1) mom5p2(PLUS2) mom5m2(MINUS2) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom15_mx_aux> <metal5> [
    property w,s,nv,nh,stm,spm,mf
    mf1 = count(metal5)-2
    mf = mf1/2
    nv = count(MOM_field1)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom15_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nv-1))
    stm = 1
    spm = 5
]
DEVICE fmom mom15_freg metal5(PLUS) metal5(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field1)
    w =  perimeter_coincide(MOM_field2,mom15_freg)/ nr 
    lr = (area(MOM_field1)/nr)/w
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nr-1)
    stm = 1
    spm = 5
]

DEVICE fmom_mx mom15_mx_freg mom5p1(PLUS1) mom5m1(MINUS1) mom5p2(PLUS2) mom5m2(MINUS2) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom15_mx_faux> <metal5> [
    property w,s,nr,lr,stm,spm,mf
    mf1 = count(metal5)-2
    mf = mf1/2
    nr = count(MOM_field1)/mf1
    w = perimeter_coincide(MOM_field2,mom15_mx_faux)/(nr*mf1)
    lr = (area(MOM_field1)/(nr*mf1))/w
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nr-1))
    stm = 1
    spm = 5  
]






mom16_1 = MOMDMY6 INTERACT MOM_field1

mom16_2 = mom16_1 INTERACT MOM_field2

mom16_3 = mom16_2 INTERACT MOM_field3

mom16_4 = mom16_3 INTERACT MOM_field4

mom16_5 = mom16_4 INTERACT MOM_field5

mom16_6 = mom16_5 INTERACT MOM_field6


mom16_Left7 = mom16_6 NOT INTERACT MOM_field7


mom16_reg1 = mom16_Left7 NOT INTERACT RFDMY
mom16_reg2 = mom16_reg1 NOT MOMDMY22
mom16_reg3 = mom16_reg2 NOT MAC
mom16_reg4 = mom16_reg3 NOT INTERACT MOMDMY_2T
mom16_reg  = mom16_reg4 INTERACT poly			// RTMOM_3T
mom16_reg_2t = mom16_reg3 INTERACT MOMDMY_2T		// RTMOM_2T
mom16_reg_rf1 = mom16_Left7 INTERACT RFDMY
mom16_reg_rf2 = mom16_reg_rf1 NOT MOMDMY22 
mom16_reg_rf3 = mom16_reg_rf2 NOT MAC
mom16_reg_rf  = mom16_reg_rf3 NOT RDKDMY
mom16_reg_rf_rdk  = mom16_reg_rf3 AND RDKDMY

mom16_mx_reg1 = MOMDMY22 INTERACT mom16_Left7
mom16_mx_reg2 = mom16_mx_reg1 NOT MAC
mom16_mx_reg3 = mom16_mx_reg2 NOT INTERACT MOMDMY_2T
mom16_mx_reg  = mom16_mx_reg3 INTERACT poly		// RTMOM_MX 5T
mom16_mx_reg_4t = mom16_mx_reg2 INTERACT MOMDMY_2T	// RTMOM_MX 4T
mom16_mx_aux1 = mom16_Left7 AND MOMDMY22
mom16_mx_aux  = mom16_mx_aux1 NOT MAC
mom16_freg  = mom16_reg2 AND MAC
mom16_mx_freg  = mom16_mx_reg1 AND MAC
mom16_mx_faux  = mom16_mx_aux1 AND MAC



DEVICE crtmom mom16_reg metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom16_reg)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 6
]
DEVICE crtmom_2t mom16_reg_2t metal6(PLUS) metal6(MINUS) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom16_reg_2t)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 6
]
DEVICE crtmom_rf mom16_reg_rf metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom16_reg_rf)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 6
]

DEVICE crtmom_rf_rdk mom16_reg_rf_rdk metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom16_reg_rf_rdk)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 6
]

DEVICE crtmom_mx mom16_mx_reg mom6p1(PLUS1) mom6m1(MINUS1) mom6p2(PLUS2) mom6m2(MINUS2) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom16_mx_aux> <metal6> [
    property w,s,nv,nh,stm,spm,mf
    mf1 = count(metal6)-2
    mf = mf1/2
    nv = count(MOM_field1)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom16_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nv-1))
    stm = 1
    spm = 6
]
DEVICE fmom mom16_freg metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field1)
    w =  perimeter_coincide(MOM_field2,mom16_freg)/ nr 
    lr = (area(MOM_field1)/nr)/w
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nr-1)
    stm = 1
    spm = 6
]

DEVICE fmom_mx mom16_mx_freg mom6p1(PLUS1) mom6m1(MINUS1) mom6p2(PLUS2) mom6m2(MINUS2) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom16_mx_faux> <metal6> [
    property w,s,nr,lr,stm,spm,mf
    mf1 = count(metal6)-2
    mf = mf1/2
    nr = count(MOM_field1)/mf1
    w = perimeter_coincide(MOM_field2,mom16_mx_faux)/(nr*mf1)
    lr = (area(MOM_field1)/(nr*mf1))/w
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nr-1))
    stm = 1
    spm = 6  
]






mom17_1 = MOMDMY7 INTERACT MOM_field1

mom17_2 = mom17_1 INTERACT MOM_field2

mom17_3 = mom17_2 INTERACT MOM_field3

mom17_4 = mom17_3 INTERACT MOM_field4

mom17_5 = mom17_4 INTERACT MOM_field5

mom17_6 = mom17_5 INTERACT MOM_field6

mom17_7 = mom17_6 INTERACT MOM_field7




mom17_reg1 = mom17_7 NOT INTERACT RFDMY
mom17_reg2 = mom17_reg1 NOT MOMDMY22
mom17_reg3 = mom17_reg2 NOT MAC
mom17_reg4 = mom17_reg3 NOT INTERACT MOMDMY_2T
mom17_reg  = mom17_reg4 INTERACT poly			// RTMOM_3T
mom17_reg_2t = mom17_reg3 INTERACT MOMDMY_2T		// RTMOM_2T
mom17_reg_rf1 = mom17_7 INTERACT RFDMY
mom17_reg_rf2 = mom17_reg_rf1 NOT MOMDMY22 
mom17_reg_rf3 = mom17_reg_rf2 NOT MAC
mom17_reg_rf  = mom17_reg_rf3 NOT RDKDMY
mom17_reg_rf_rdk  = mom17_reg_rf3 AND RDKDMY

mom17_mx_reg1 = MOMDMY22 INTERACT mom17_7
mom17_mx_reg2 = mom17_mx_reg1 NOT MAC
mom17_mx_reg3 = mom17_mx_reg2 NOT INTERACT MOMDMY_2T
mom17_mx_reg  = mom17_mx_reg3 INTERACT poly		// RTMOM_MX 5T
mom17_mx_reg_4t = mom17_mx_reg2 INTERACT MOMDMY_2T	// RTMOM_MX 4T
mom17_mx_aux1 = mom17_7 AND MOMDMY22
mom17_mx_aux  = mom17_mx_aux1 NOT MAC
mom17_freg  = mom17_reg2 AND MAC
mom17_mx_freg  = mom17_mx_reg1 AND MAC
mom17_mx_faux  = mom17_mx_aux1 AND MAC



DEVICE crtmom mom17_reg metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom17_reg)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 7
]
DEVICE crtmom_2t mom17_reg_2t metal7(PLUS) metal7(MINUS) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom17_reg_2t)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 7
]
DEVICE crtmom_rf mom17_reg_rf metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom17_reg_rf)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 7
]

DEVICE crtmom_rf_rdk mom17_reg_rf_rdk metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom17_reg_rf_rdk)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 7
]

DEVICE crtmom_mx mom17_mx_reg mom7p1(PLUS1) mom7m1(MINUS1) mom7p2(PLUS2) mom7m2(MINUS2) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom17_mx_aux> <metal7> [
    property w,s,nv,nh,stm,spm,mf
    mf1 = count(metal7)-2
    mf = mf1/2
    nv = count(MOM_field1)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom17_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nv-1))
    stm = 1
    spm = 7
]
DEVICE fmom mom17_freg metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field1)
    w =  perimeter_coincide(MOM_field2,mom17_freg)/ nr 
    lr = (area(MOM_field1)/nr)/w
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nr-1)
    stm = 1
    spm = 7
]

DEVICE fmom_mx mom17_mx_freg mom7p1(PLUS1) mom7m1(MINUS1) mom7p2(PLUS2) mom7m2(MINUS2) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom17_mx_faux> <metal7> [
    property w,s,nr,lr,stm,spm,mf
    mf1 = count(metal7)-2
    mf = mf1/2
    nr = count(MOM_field1)/mf1
    w = perimeter_coincide(MOM_field2,mom17_mx_faux)/(nr*mf1)
    lr = (area(MOM_field1)/(nr*mf1))/w
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nr-1))
    stm = 1
    spm = 7  
]






mom24_1 = MOMDMY4 NOT INTERACT MOM_field1


mom24_2 = mom24_1 INTERACT MOM_field2

mom24_3 = mom24_2 INTERACT MOM_field3

mom24_4 = mom24_3 INTERACT MOM_field4


mom24_Left5 = mom24_4 NOT INTERACT MOM_field5
mom24_Left6 = mom24_Left5 NOT INTERACT MOM_field6
mom24_Left7 = mom24_Left6 NOT INTERACT MOM_field7


mom24_reg1 = mom24_Left7 NOT INTERACT RFDMY
mom24_reg2 = mom24_reg1 NOT MOMDMY22
mom24_reg3 = mom24_reg2 NOT MAC
mom24_reg4 = mom24_reg3 NOT INTERACT MOMDMY_2T
mom24_reg  = mom24_reg4 INTERACT poly			// RTMOM_3T
mom24_reg_2t = mom24_reg3 INTERACT MOMDMY_2T		// RTMOM_2T
mom24_reg_rf1 = mom24_Left7 INTERACT RFDMY
mom24_reg_rf2 = mom24_reg_rf1 NOT MOMDMY22 
mom24_reg_rf3 = mom24_reg_rf2 NOT MAC
mom24_reg_rf  = mom24_reg_rf3 NOT RDKDMY
mom24_reg_rf_rdk  = mom24_reg_rf3 AND RDKDMY

mom24_mx_reg1 = MOMDMY22 INTERACT mom24_Left7
mom24_mx_reg2 = mom24_mx_reg1 NOT MAC
mom24_mx_reg3 = mom24_mx_reg2 NOT INTERACT MOMDMY_2T
mom24_mx_reg  = mom24_mx_reg3 INTERACT poly		// RTMOM_MX 5T
mom24_mx_reg_4t = mom24_mx_reg2 INTERACT MOMDMY_2T	// RTMOM_MX 4T
mom24_mx_aux1 = mom24_Left7 AND MOMDMY22
mom24_mx_aux  = mom24_mx_aux1 NOT MAC
mom24_freg  = mom24_reg2 AND MAC
mom24_mx_freg  = mom24_mx_reg1 AND MAC
mom24_mx_faux  = mom24_mx_aux1 AND MAC



DEVICE crtmom mom24_reg metal4(PLUS) metal4(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom24_reg)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 4
]
DEVICE crtmom_2t mom24_reg_2t metal4(PLUS) metal4(MINUS) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom24_reg_2t)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 4
]
DEVICE crtmom_rf mom24_reg_rf metal4(PLUS) metal4(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom24_reg_rf)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 4
]

DEVICE crtmom_rf_rdk mom24_reg_rf_rdk metal4(PLUS) metal4(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom24_reg_rf_rdk)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 4
]

DEVICE crtmom_mx mom24_mx_reg mom4p1(PLUS1) mom4m1(MINUS1) mom4p2(PLUS2) mom4m2(MINUS2) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> <mom24_mx_aux> <metal4> [
    property w,s,nv,nh,stm,spm,mf
    mf1 = count(metal4)-2
    mf = mf1/2
    nv = count(MOM_field3)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom24_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(mf1*(nh-1))
    stm = 2
    spm = 4
]
DEVICE fmom mom24_freg metal4(PLUS) metal4(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field3)
    w =  perimeter_coincide(MOM_field2,mom24_freg)/ nr 
    lr = (area(MOM_field3)/nr)/w
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field3))/2)/(nr-1)
    stm = 2
    spm = 4
]

DEVICE fmom_mx mom24_mx_freg mom4p1(PLUS1) mom4m1(MINUS1) mom4p2(PLUS2) mom4m2(MINUS2) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> <mom24_mx_faux> <metal4> [
    property w,s,nr,lr,stm,spm,mf
    mf1 = count(metal4)-2
    mf = mf1/2
    nr = count(MOM_field3)/mf1
    w = perimeter_coincide(MOM_field2,mom24_mx_faux)/(nr*mf1)
    lr = (area(MOM_field3)/(nr*mf1))/w
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field3))/2)/(mf1*(nr-1))
    stm = 2
    spm = 4  
]





mom25_1 = MOMDMY5 NOT INTERACT MOM_field1


mom25_2 = mom25_1 INTERACT MOM_field2

mom25_3 = mom25_2 INTERACT MOM_field3

mom25_4 = mom25_3 INTERACT MOM_field4

mom25_5 = mom25_4 INTERACT MOM_field5


mom25_Left6 = mom25_5 NOT INTERACT MOM_field6
mom25_Left7 = mom25_Left6 NOT INTERACT MOM_field7


mom25_reg1 = mom25_Left7 NOT INTERACT RFDMY
mom25_reg2 = mom25_reg1 NOT MOMDMY22
mom25_reg3 = mom25_reg2 NOT MAC
mom25_reg4 = mom25_reg3 NOT INTERACT MOMDMY_2T
mom25_reg  = mom25_reg4 INTERACT poly			// RTMOM_3T
mom25_reg_2t = mom25_reg3 INTERACT MOMDMY_2T		// RTMOM_2T
mom25_reg_rf1 = mom25_Left7 INTERACT RFDMY
mom25_reg_rf2 = mom25_reg_rf1 NOT MOMDMY22 
mom25_reg_rf3 = mom25_reg_rf2 NOT MAC
mom25_reg_rf  = mom25_reg_rf3 NOT RDKDMY
mom25_reg_rf_rdk  = mom25_reg_rf3 AND RDKDMY

mom25_mx_reg1 = MOMDMY22 INTERACT mom25_Left7
mom25_mx_reg2 = mom25_mx_reg1 NOT MAC
mom25_mx_reg3 = mom25_mx_reg2 NOT INTERACT MOMDMY_2T
mom25_mx_reg  = mom25_mx_reg3 INTERACT poly		// RTMOM_MX 5T
mom25_mx_reg_4t = mom25_mx_reg2 INTERACT MOMDMY_2T	// RTMOM_MX 4T
mom25_mx_aux1 = mom25_Left7 AND MOMDMY22
mom25_mx_aux  = mom25_mx_aux1 NOT MAC
mom25_freg  = mom25_reg2 AND MAC
mom25_mx_freg  = mom25_mx_reg1 AND MAC
mom25_mx_faux  = mom25_mx_aux1 AND MAC



DEVICE crtmom mom25_reg metal5(PLUS) metal5(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom25_reg)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 5
]
DEVICE crtmom_2t mom25_reg_2t metal5(PLUS) metal5(MINUS) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom25_reg_2t)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 5
]
DEVICE crtmom_rf mom25_reg_rf metal5(PLUS) metal5(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom25_reg_rf)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 5
]

DEVICE crtmom_rf_rdk mom25_reg_rf_rdk metal5(PLUS) metal5(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom25_reg_rf_rdk)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 5
]

DEVICE crtmom_mx mom25_mx_reg mom5p1(PLUS1) mom5m1(MINUS1) mom5p2(PLUS2) mom5m2(MINUS2) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> <mom25_mx_aux> <metal5> [
    property w,s,nv,nh,stm,spm,mf
    mf1 = count(metal5)-2
    mf = mf1/2
    nv = count(MOM_field3)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom25_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(mf1*(nh-1))
    stm = 2
    spm = 5
]
DEVICE fmom mom25_freg metal5(PLUS) metal5(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field3)
    w =  perimeter_coincide(MOM_field2,mom25_freg)/ nr 
    lr = (area(MOM_field3)/nr)/w
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field3))/2)/(nr-1)
    stm = 2
    spm = 5
]

DEVICE fmom_mx mom25_mx_freg mom5p1(PLUS1) mom5m1(MINUS1) mom5p2(PLUS2) mom5m2(MINUS2) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> <mom25_mx_faux> <metal5> [
    property w,s,nr,lr,stm,spm,mf
    mf1 = count(metal5)-2
    mf = mf1/2
    nr = count(MOM_field3)/mf1
    w = perimeter_coincide(MOM_field2,mom25_mx_faux)/(nr*mf1)
    lr = (area(MOM_field3)/(nr*mf1))/w
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field3))/2)/(mf1*(nr-1))
    stm = 2
    spm = 5  
]





mom26_1 = MOMDMY6 NOT INTERACT MOM_field1


mom26_2 = mom26_1 INTERACT MOM_field2

mom26_3 = mom26_2 INTERACT MOM_field3

mom26_4 = mom26_3 INTERACT MOM_field4

mom26_5 = mom26_4 INTERACT MOM_field5

mom26_6 = mom26_5 INTERACT MOM_field6


mom26_Left7 = mom26_6 NOT INTERACT MOM_field7


mom26_reg1 = mom26_Left7 NOT INTERACT RFDMY
mom26_reg2 = mom26_reg1 NOT MOMDMY22
mom26_reg3 = mom26_reg2 NOT MAC
mom26_reg4 = mom26_reg3 NOT INTERACT MOMDMY_2T
mom26_reg  = mom26_reg4 INTERACT poly			// RTMOM_3T
mom26_reg_2t = mom26_reg3 INTERACT MOMDMY_2T		// RTMOM_2T
mom26_reg_rf1 = mom26_Left7 INTERACT RFDMY
mom26_reg_rf2 = mom26_reg_rf1 NOT MOMDMY22 
mom26_reg_rf3 = mom26_reg_rf2 NOT MAC
mom26_reg_rf  = mom26_reg_rf3 NOT RDKDMY
mom26_reg_rf_rdk  = mom26_reg_rf3 AND RDKDMY

mom26_mx_reg1 = MOMDMY22 INTERACT mom26_Left7
mom26_mx_reg2 = mom26_mx_reg1 NOT MAC
mom26_mx_reg3 = mom26_mx_reg2 NOT INTERACT MOMDMY_2T
mom26_mx_reg  = mom26_mx_reg3 INTERACT poly		// RTMOM_MX 5T
mom26_mx_reg_4t = mom26_mx_reg2 INTERACT MOMDMY_2T	// RTMOM_MX 4T
mom26_mx_aux1 = mom26_Left7 AND MOMDMY22
mom26_mx_aux  = mom26_mx_aux1 NOT MAC
mom26_freg  = mom26_reg2 AND MAC
mom26_mx_freg  = mom26_mx_reg1 AND MAC
mom26_mx_faux  = mom26_mx_aux1 AND MAC



DEVICE crtmom mom26_reg metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom26_reg)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 6
]
DEVICE crtmom_2t mom26_reg_2t metal6(PLUS) metal6(MINUS) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom26_reg_2t)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 6
]
DEVICE crtmom_rf mom26_reg_rf metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom26_reg_rf)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 6
]

DEVICE crtmom_rf_rdk mom26_reg_rf_rdk metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom26_reg_rf_rdk)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 6
]

DEVICE crtmom_mx mom26_mx_reg mom6p1(PLUS1) mom6m1(MINUS1) mom6p2(PLUS2) mom6m2(MINUS2) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> <mom26_mx_aux> <metal6> [
    property w,s,nv,nh,stm,spm,mf
    mf1 = count(metal6)-2
    mf = mf1/2
    nv = count(MOM_field3)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom26_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(mf1*(nh-1))
    stm = 2
    spm = 6
]
DEVICE fmom mom26_freg metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field3)
    w =  perimeter_coincide(MOM_field2,mom26_freg)/ nr 
    lr = (area(MOM_field3)/nr)/w
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field3))/2)/(nr-1)
    stm = 2
    spm = 6
]

DEVICE fmom_mx mom26_mx_freg mom6p1(PLUS1) mom6m1(MINUS1) mom6p2(PLUS2) mom6m2(MINUS2) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> <mom26_mx_faux> <metal6> [
    property w,s,nr,lr,stm,spm,mf
    mf1 = count(metal6)-2
    mf = mf1/2
    nr = count(MOM_field3)/mf1
    w = perimeter_coincide(MOM_field2,mom26_mx_faux)/(nr*mf1)
    lr = (area(MOM_field3)/(nr*mf1))/w
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field3))/2)/(mf1*(nr-1))
    stm = 2
    spm = 6  
]





mom27_1 = MOMDMY7 NOT INTERACT MOM_field1


mom27_2 = mom27_1 INTERACT MOM_field2

mom27_3 = mom27_2 INTERACT MOM_field3

mom27_4 = mom27_3 INTERACT MOM_field4

mom27_5 = mom27_4 INTERACT MOM_field5

mom27_6 = mom27_5 INTERACT MOM_field6

mom27_7 = mom27_6 INTERACT MOM_field7




mom27_reg1 = mom27_7 NOT INTERACT RFDMY
mom27_reg2 = mom27_reg1 NOT MOMDMY22
mom27_reg3 = mom27_reg2 NOT MAC
mom27_reg4 = mom27_reg3 NOT INTERACT MOMDMY_2T
mom27_reg  = mom27_reg4 INTERACT poly			// RTMOM_3T
mom27_reg_2t = mom27_reg3 INTERACT MOMDMY_2T		// RTMOM_2T
mom27_reg_rf1 = mom27_7 INTERACT RFDMY
mom27_reg_rf2 = mom27_reg_rf1 NOT MOMDMY22 
mom27_reg_rf3 = mom27_reg_rf2 NOT MAC
mom27_reg_rf  = mom27_reg_rf3 NOT RDKDMY
mom27_reg_rf_rdk  = mom27_reg_rf3 AND RDKDMY

mom27_mx_reg1 = MOMDMY22 INTERACT mom27_7
mom27_mx_reg2 = mom27_mx_reg1 NOT MAC
mom27_mx_reg3 = mom27_mx_reg2 NOT INTERACT MOMDMY_2T
mom27_mx_reg  = mom27_mx_reg3 INTERACT poly		// RTMOM_MX 5T
mom27_mx_reg_4t = mom27_mx_reg2 INTERACT MOMDMY_2T	// RTMOM_MX 4T
mom27_mx_aux1 = mom27_7 AND MOMDMY22
mom27_mx_aux  = mom27_mx_aux1 NOT MAC
mom27_freg  = mom27_reg2 AND MAC
mom27_mx_freg  = mom27_mx_reg1 AND MAC
mom27_mx_faux  = mom27_mx_aux1 AND MAC



DEVICE crtmom mom27_reg metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom27_reg)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 7
]
DEVICE crtmom_2t mom27_reg_2t metal7(PLUS) metal7(MINUS) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom27_reg_2t)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 7
]
DEVICE crtmom_rf mom27_reg_rf metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom27_reg_rf)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 7
]

DEVICE crtmom_rf_rdk mom27_reg_rf_rdk metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom27_reg_rf_rdk)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 7
]

DEVICE crtmom_mx mom27_mx_reg mom7p1(PLUS1) mom7m1(MINUS1) mom7p2(PLUS2) mom7m2(MINUS2) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> <mom27_mx_aux> <metal7> [
    property w,s,nv,nh,stm,spm,mf
    mf1 = count(metal7)-2
    mf = mf1/2
    nv = count(MOM_field3)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom27_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(mf1*(nh-1))
    stm = 2
    spm = 7
]
DEVICE fmom mom27_freg metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field3)
    w =  perimeter_coincide(MOM_field2,mom27_freg)/ nr 
    lr = (area(MOM_field3)/nr)/w
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field3))/2)/(nr-1)
    stm = 2
    spm = 7
]

DEVICE fmom_mx mom27_mx_freg mom7p1(PLUS1) mom7m1(MINUS1) mom7p2(PLUS2) mom7m2(MINUS2) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> <mom27_mx_faux> <metal7> [
    property w,s,nr,lr,stm,spm,mf
    mf1 = count(metal7)-2
    mf = mf1/2
    nr = count(MOM_field3)/mf1
    w = perimeter_coincide(MOM_field2,mom27_mx_faux)/(nr*mf1)
    lr = (area(MOM_field3)/(nr*mf1))/w
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field3))/2)/(mf1*(nr-1))
    stm = 2
    spm = 7  
]






mom35_1 = MOMDMY5 NOT INTERACT MOM_field1
mom35_2 = mom35_1 NOT INTERACT MOM_field2


mom35_3 = mom35_2 INTERACT MOM_field3

mom35_4 = mom35_3 INTERACT MOM_field4

mom35_5 = mom35_4 INTERACT MOM_field5


mom35_Left6 = mom35_5 NOT INTERACT MOM_field6
mom35_Left7 = mom35_Left6 NOT INTERACT MOM_field7


mom35_reg1 = mom35_Left7 NOT INTERACT RFDMY
mom35_reg2 = mom35_reg1 NOT MOMDMY22
mom35_reg3 = mom35_reg2 NOT MAC
mom35_reg4 = mom35_reg3 NOT INTERACT MOMDMY_2T
mom35_reg  = mom35_reg4 INTERACT poly			// RTMOM_3T
mom35_reg_2t = mom35_reg3 INTERACT MOMDMY_2T		// RTMOM_2T
mom35_reg_rf1 = mom35_Left7 INTERACT RFDMY
mom35_reg_rf2 = mom35_reg_rf1 NOT MOMDMY22 
mom35_reg_rf3 = mom35_reg_rf2 NOT MAC
mom35_reg_rf  = mom35_reg_rf3 NOT RDKDMY
mom35_reg_rf_rdk  = mom35_reg_rf3 AND RDKDMY

mom35_mx_reg1 = MOMDMY22 INTERACT mom35_Left7
mom35_mx_reg2 = mom35_mx_reg1 NOT MAC
mom35_mx_reg3 = mom35_mx_reg2 NOT INTERACT MOMDMY_2T
mom35_mx_reg  = mom35_mx_reg3 INTERACT poly		// RTMOM_MX 5T
mom35_mx_reg_4t = mom35_mx_reg2 INTERACT MOMDMY_2T	// RTMOM_MX 4T
mom35_mx_aux1 = mom35_Left7 AND MOMDMY22
mom35_mx_aux  = mom35_mx_aux1 NOT MAC
mom35_freg  = mom35_reg2 AND MAC
mom35_mx_freg  = mom35_mx_reg1 AND MAC
mom35_mx_faux  = mom35_mx_aux1 AND MAC



DEVICE crtmom mom35_reg metal5(PLUS) metal5(MINUS) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom35_reg)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 5
]
DEVICE crtmom_2t mom35_reg_2t metal5(PLUS) metal5(MINUS) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom35_reg_2t)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 5
]
DEVICE crtmom_rf mom35_reg_rf metal5(PLUS) metal5(MINUS) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom35_reg_rf)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 5
]

DEVICE crtmom_rf_rdk mom35_reg_rf_rdk metal5(PLUS) metal5(MINUS) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom35_reg_rf_rdk)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 5
]

DEVICE crtmom_mx mom35_mx_reg mom5p1(PLUS1) mom5m1(MINUS1) mom5p2(PLUS2) mom5m2(MINUS2) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> <mom35_mx_aux> <metal5> [
    property w,s,nv,nh,stm,spm,mf
    mf1 = count(metal5)-2
    mf = mf1/2
    nv = count(MOM_field3)/mf1
    nh = count(MOM_field4)/mf1
    w =  perimeter_coincide(MOM_field4,mom35_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(mf1*(nv-1))
    stm = 3
    spm = 5
]
DEVICE fmom mom35_freg metal5(PLUS) metal5(MINUS) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field3)
    w =  perimeter_coincide(MOM_field4,mom35_freg)/ nr 
    lr = (area(MOM_field3)/nr)/w
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nr-1)
    stm = 3
    spm = 5
]

DEVICE fmom_mx mom35_mx_freg mom5p1(PLUS1) mom5m1(MINUS1) mom5p2(PLUS2) mom5m2(MINUS2) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> <mom35_mx_faux> <metal5> [
    property w,s,nr,lr,stm,spm,mf
    mf1 = count(metal5)-2
    mf = mf1/2
    nr = count(MOM_field3)/mf1
    w = perimeter_coincide(MOM_field4,mom35_mx_faux)/(nr*mf1)
    lr = (area(MOM_field3)/(nr*mf1))/w
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(mf1*(nr-1))
    stm = 3
    spm = 5  
]





mom36_1 = MOMDMY6 NOT INTERACT MOM_field1
mom36_2 = mom36_1 NOT INTERACT MOM_field2


mom36_3 = mom36_2 INTERACT MOM_field3

mom36_4 = mom36_3 INTERACT MOM_field4

mom36_5 = mom36_4 INTERACT MOM_field5

mom36_6 = mom36_5 INTERACT MOM_field6


mom36_Left7 = mom36_6 NOT INTERACT MOM_field7


mom36_reg1 = mom36_Left7 NOT INTERACT RFDMY
mom36_reg2 = mom36_reg1 NOT MOMDMY22
mom36_reg3 = mom36_reg2 NOT MAC
mom36_reg4 = mom36_reg3 NOT INTERACT MOMDMY_2T
mom36_reg  = mom36_reg4 INTERACT poly			// RTMOM_3T
mom36_reg_2t = mom36_reg3 INTERACT MOMDMY_2T		// RTMOM_2T
mom36_reg_rf1 = mom36_Left7 INTERACT RFDMY
mom36_reg_rf2 = mom36_reg_rf1 NOT MOMDMY22 
mom36_reg_rf3 = mom36_reg_rf2 NOT MAC
mom36_reg_rf  = mom36_reg_rf3 NOT RDKDMY
mom36_reg_rf_rdk  = mom36_reg_rf3 AND RDKDMY

mom36_mx_reg1 = MOMDMY22 INTERACT mom36_Left7
mom36_mx_reg2 = mom36_mx_reg1 NOT MAC
mom36_mx_reg3 = mom36_mx_reg2 NOT INTERACT MOMDMY_2T
mom36_mx_reg  = mom36_mx_reg3 INTERACT poly		// RTMOM_MX 5T
mom36_mx_reg_4t = mom36_mx_reg2 INTERACT MOMDMY_2T	// RTMOM_MX 4T
mom36_mx_aux1 = mom36_Left7 AND MOMDMY22
mom36_mx_aux  = mom36_mx_aux1 NOT MAC
mom36_freg  = mom36_reg2 AND MAC
mom36_mx_freg  = mom36_mx_reg1 AND MAC
mom36_mx_faux  = mom36_mx_aux1 AND MAC



DEVICE crtmom mom36_reg metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom36_reg)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 6
]
DEVICE crtmom_2t mom36_reg_2t metal6(PLUS) metal6(MINUS) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom36_reg_2t)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 6
]
DEVICE crtmom_rf mom36_reg_rf metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom36_reg_rf)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 6
]

DEVICE crtmom_rf_rdk mom36_reg_rf_rdk metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom36_reg_rf_rdk)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 6
]

DEVICE crtmom_mx mom36_mx_reg mom6p1(PLUS1) mom6m1(MINUS1) mom6p2(PLUS2) mom6m2(MINUS2) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> <mom36_mx_aux> <metal6> [
    property w,s,nv,nh,stm,spm,mf
    mf1 = count(metal6)-2
    mf = mf1/2
    nv = count(MOM_field3)/mf1
    nh = count(MOM_field4)/mf1
    w =  perimeter_coincide(MOM_field4,mom36_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(mf1*(nv-1))
    stm = 3
    spm = 6
]
DEVICE fmom mom36_freg metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field3)
    w =  perimeter_coincide(MOM_field4,mom36_freg)/ nr 
    lr = (area(MOM_field3)/nr)/w
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nr-1)
    stm = 3
    spm = 6
]

DEVICE fmom_mx mom36_mx_freg mom6p1(PLUS1) mom6m1(MINUS1) mom6p2(PLUS2) mom6m2(MINUS2) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> <mom36_mx_faux> <metal6> [
    property w,s,nr,lr,stm,spm,mf
    mf1 = count(metal6)-2
    mf = mf1/2
    nr = count(MOM_field3)/mf1
    w = perimeter_coincide(MOM_field4,mom36_mx_faux)/(nr*mf1)
    lr = (area(MOM_field3)/(nr*mf1))/w
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(mf1*(nr-1))
    stm = 3
    spm = 6  
]





mom37_1 = MOMDMY7 NOT INTERACT MOM_field1
mom37_2 = mom37_1 NOT INTERACT MOM_field2


mom37_3 = mom37_2 INTERACT MOM_field3

mom37_4 = mom37_3 INTERACT MOM_field4

mom37_5 = mom37_4 INTERACT MOM_field5

mom37_6 = mom37_5 INTERACT MOM_field6

mom37_7 = mom37_6 INTERACT MOM_field7




mom37_reg1 = mom37_7 NOT INTERACT RFDMY
mom37_reg2 = mom37_reg1 NOT MOMDMY22
mom37_reg3 = mom37_reg2 NOT MAC
mom37_reg4 = mom37_reg3 NOT INTERACT MOMDMY_2T
mom37_reg  = mom37_reg4 INTERACT poly			// RTMOM_3T
mom37_reg_2t = mom37_reg3 INTERACT MOMDMY_2T		// RTMOM_2T
mom37_reg_rf1 = mom37_7 INTERACT RFDMY
mom37_reg_rf2 = mom37_reg_rf1 NOT MOMDMY22 
mom37_reg_rf3 = mom37_reg_rf2 NOT MAC
mom37_reg_rf  = mom37_reg_rf3 NOT RDKDMY
mom37_reg_rf_rdk  = mom37_reg_rf3 AND RDKDMY

mom37_mx_reg1 = MOMDMY22 INTERACT mom37_7
mom37_mx_reg2 = mom37_mx_reg1 NOT MAC
mom37_mx_reg3 = mom37_mx_reg2 NOT INTERACT MOMDMY_2T
mom37_mx_reg  = mom37_mx_reg3 INTERACT poly		// RTMOM_MX 5T
mom37_mx_reg_4t = mom37_mx_reg2 INTERACT MOMDMY_2T	// RTMOM_MX 4T
mom37_mx_aux1 = mom37_7 AND MOMDMY22
mom37_mx_aux  = mom37_mx_aux1 NOT MAC
mom37_freg  = mom37_reg2 AND MAC
mom37_mx_freg  = mom37_mx_reg1 AND MAC
mom37_mx_faux  = mom37_mx_aux1 AND MAC



DEVICE crtmom mom37_reg metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom37_reg)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 7
]
DEVICE crtmom_2t mom37_reg_2t metal7(PLUS) metal7(MINUS) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom37_reg_2t)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 7
]
DEVICE crtmom_rf mom37_reg_rf metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom37_reg_rf)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 7
]

DEVICE crtmom_rf_rdk mom37_reg_rf_rdk metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom37_reg_rf_rdk)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 7
]

DEVICE crtmom_mx mom37_mx_reg mom7p1(PLUS1) mom7m1(MINUS1) mom7p2(PLUS2) mom7m2(MINUS2) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> <mom37_mx_aux> <metal7> [
    property w,s,nv,nh,stm,spm,mf
    mf1 = count(metal7)-2
    mf = mf1/2
    nv = count(MOM_field3)/mf1
    nh = count(MOM_field4)/mf1
    w =  perimeter_coincide(MOM_field4,mom37_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(mf1*(nv-1))
    stm = 3
    spm = 7
]
DEVICE fmom mom37_freg metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field3)
    w =  perimeter_coincide(MOM_field4,mom37_freg)/ nr 
    lr = (area(MOM_field3)/nr)/w
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nr-1)
    stm = 3
    spm = 7
]

DEVICE fmom_mx mom37_mx_freg mom7p1(PLUS1) mom7m1(MINUS1) mom7p2(PLUS2) mom7m2(MINUS2) poly(BULK) <MOM_field3> <MOM_field4> <F_reg3> <mom37_mx_faux> <metal7> [
    property w,s,nr,lr,stm,spm,mf
    mf1 = count(metal7)-2
    mf = mf1/2
    nr = count(MOM_field3)/mf1
    w = perimeter_coincide(MOM_field4,mom37_mx_faux)/(nr*mf1)
    lr = (area(MOM_field3)/(nr*mf1))/w
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(mf1*(nr-1))
    stm = 3
    spm = 7  
]






mom46_1 = MOMDMY6 NOT INTERACT MOM_field1
mom46_2 = mom46_1 NOT INTERACT MOM_field2
mom46_3 = mom46_2 NOT INTERACT MOM_field3


mom46_4 = mom46_3 INTERACT MOM_field4

mom46_5 = mom46_4 INTERACT MOM_field5

mom46_6 = mom46_5 INTERACT MOM_field6


mom46_Left7 = mom46_6 NOT INTERACT MOM_field7


mom46_reg1 = mom46_Left7 NOT INTERACT RFDMY
mom46_reg2 = mom46_reg1 NOT MOMDMY22
mom46_reg3 = mom46_reg2 NOT MAC
mom46_reg4 = mom46_reg3 NOT INTERACT MOMDMY_2T
mom46_reg  = mom46_reg4 INTERACT poly			// RTMOM_3T
mom46_reg_2t = mom46_reg3 INTERACT MOMDMY_2T		// RTMOM_2T
mom46_reg_rf1 = mom46_Left7 INTERACT RFDMY
mom46_reg_rf2 = mom46_reg_rf1 NOT MOMDMY22 
mom46_reg_rf3 = mom46_reg_rf2 NOT MAC
mom46_reg_rf  = mom46_reg_rf3 NOT RDKDMY
mom46_reg_rf_rdk  = mom46_reg_rf3 AND RDKDMY

mom46_mx_reg1 = MOMDMY22 INTERACT mom46_Left7
mom46_mx_reg2 = mom46_mx_reg1 NOT MAC
mom46_mx_reg3 = mom46_mx_reg2 NOT INTERACT MOMDMY_2T
mom46_mx_reg  = mom46_mx_reg3 INTERACT poly		// RTMOM_MX 5T
mom46_mx_reg_4t = mom46_mx_reg2 INTERACT MOMDMY_2T	// RTMOM_MX 4T
mom46_mx_aux1 = mom46_Left7 AND MOMDMY22
mom46_mx_aux  = mom46_mx_aux1 NOT MAC
mom46_freg  = mom46_reg2 AND MAC
mom46_mx_freg  = mom46_mx_reg1 AND MAC
mom46_mx_faux  = mom46_mx_aux1 AND MAC



DEVICE crtmom mom46_reg metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field5> <MOM_field4> <F_reg4> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field5)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom46_reg)/ nh
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(nh-1)
    stm = 4
    spm = 6
]
DEVICE crtmom_2t mom46_reg_2t metal6(PLUS) metal6(MINUS) <MOM_field5> <MOM_field4> <F_reg4> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field5)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom46_reg_2t)/ nh
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(nh-1)
    stm = 4
    spm = 6
]
DEVICE crtmom_rf mom46_reg_rf metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field5> <MOM_field4> <F_reg4> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field5)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom46_reg_rf)/ nh
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(nh-1)
    stm = 4
    spm = 6
]

DEVICE crtmom_rf_rdk mom46_reg_rf_rdk metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field5> <MOM_field4> <F_reg4> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field5)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom46_reg_rf_rdk)/ nh
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(nh-1)
    stm = 4
    spm = 6
]

DEVICE crtmom_mx mom46_mx_reg mom6p1(PLUS1) mom6m1(MINUS1) mom6p2(PLUS2) mom6m2(MINUS2) poly(BULK) <MOM_field5> <MOM_field4> <F_reg4> <mom46_mx_aux> <metal6> [
    property w,s,nv,nh,stm,spm,mf
    mf1 = count(metal6)-2
    mf = mf1/2
    nv = count(MOM_field5)/mf1
    nh = count(MOM_field4)/mf1
    w =  perimeter_coincide(MOM_field4,mom46_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(mf1*(nh-1))
    stm = 4
    spm = 6
]
DEVICE fmom mom46_freg metal6(PLUS) metal6(MINUS) poly(BULK) <MOM_field5> <MOM_field4> <F_reg4> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field5)
    w =  perimeter_coincide(MOM_field4,mom46_freg)/ nr 
    lr = (area(MOM_field5)/nr)/w
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field5))/2)/(nr-1)
    stm = 4
    spm = 6
]

DEVICE fmom_mx mom46_mx_freg mom6p1(PLUS1) mom6m1(MINUS1) mom6p2(PLUS2) mom6m2(MINUS2) poly(BULK) <MOM_field5> <MOM_field4> <F_reg4> <mom46_mx_faux> <metal6> [
    property w,s,nr,lr,stm,spm,mf
    mf1 = count(metal6)-2
    mf = mf1/2
    nr = count(MOM_field5)/mf1
    w = perimeter_coincide(MOM_field4,mom46_mx_faux)/(nr*mf1)
    lr = (area(MOM_field5)/(nr*mf1))/w
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field5))/2)/(mf1*(nr-1))
    stm = 4
    spm = 6  
]





mom47_1 = MOMDMY7 NOT INTERACT MOM_field1
mom47_2 = mom47_1 NOT INTERACT MOM_field2
mom47_3 = mom47_2 NOT INTERACT MOM_field3


mom47_4 = mom47_3 INTERACT MOM_field4

mom47_5 = mom47_4 INTERACT MOM_field5

mom47_6 = mom47_5 INTERACT MOM_field6

mom47_7 = mom47_6 INTERACT MOM_field7




mom47_reg1 = mom47_7 NOT INTERACT RFDMY
mom47_reg2 = mom47_reg1 NOT MOMDMY22
mom47_reg3 = mom47_reg2 NOT MAC
mom47_reg4 = mom47_reg3 NOT INTERACT MOMDMY_2T
mom47_reg  = mom47_reg4 INTERACT poly			// RTMOM_3T
mom47_reg_2t = mom47_reg3 INTERACT MOMDMY_2T		// RTMOM_2T
mom47_reg_rf1 = mom47_7 INTERACT RFDMY
mom47_reg_rf2 = mom47_reg_rf1 NOT MOMDMY22 
mom47_reg_rf3 = mom47_reg_rf2 NOT MAC
mom47_reg_rf  = mom47_reg_rf3 NOT RDKDMY
mom47_reg_rf_rdk  = mom47_reg_rf3 AND RDKDMY

mom47_mx_reg1 = MOMDMY22 INTERACT mom47_7
mom47_mx_reg2 = mom47_mx_reg1 NOT MAC
mom47_mx_reg3 = mom47_mx_reg2 NOT INTERACT MOMDMY_2T
mom47_mx_reg  = mom47_mx_reg3 INTERACT poly		// RTMOM_MX 5T
mom47_mx_reg_4t = mom47_mx_reg2 INTERACT MOMDMY_2T	// RTMOM_MX 4T
mom47_mx_aux1 = mom47_7 AND MOMDMY22
mom47_mx_aux  = mom47_mx_aux1 NOT MAC
mom47_freg  = mom47_reg2 AND MAC
mom47_mx_freg  = mom47_mx_reg1 AND MAC
mom47_mx_faux  = mom47_mx_aux1 AND MAC



DEVICE crtmom mom47_reg metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field5> <MOM_field4> <F_reg4> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field5)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom47_reg)/ nh
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(nh-1)
    stm = 4
    spm = 7
]
DEVICE crtmom_2t mom47_reg_2t metal7(PLUS) metal7(MINUS) <MOM_field5> <MOM_field4> <F_reg4> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field5)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom47_reg_2t)/ nh
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(nh-1)
    stm = 4
    spm = 7
]
DEVICE crtmom_rf mom47_reg_rf metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field5> <MOM_field4> <F_reg4> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field5)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom47_reg_rf)/ nh
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(nh-1)
    stm = 4
    spm = 7
]

DEVICE crtmom_rf_rdk mom47_reg_rf_rdk metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field5> <MOM_field4> <F_reg4> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field5)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom47_reg_rf_rdk)/ nh
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(nh-1)
    stm = 4
    spm = 7
]

DEVICE crtmom_mx mom47_mx_reg mom7p1(PLUS1) mom7m1(MINUS1) mom7p2(PLUS2) mom7m2(MINUS2) poly(BULK) <MOM_field5> <MOM_field4> <F_reg4> <mom47_mx_aux> <metal7> [
    property w,s,nv,nh,stm,spm,mf
    mf1 = count(metal7)-2
    mf = mf1/2
    nv = count(MOM_field5)/mf1
    nh = count(MOM_field4)/mf1
    w =  perimeter_coincide(MOM_field4,mom47_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(mf1*(nh-1))
    stm = 4
    spm = 7
]
DEVICE fmom mom47_freg metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field5> <MOM_field4> <F_reg4> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field5)
    w =  perimeter_coincide(MOM_field4,mom47_freg)/ nr 
    lr = (area(MOM_field5)/nr)/w
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field5))/2)/(nr-1)
    stm = 4
    spm = 7
]

DEVICE fmom_mx mom47_mx_freg mom7p1(PLUS1) mom7m1(MINUS1) mom7p2(PLUS2) mom7m2(MINUS2) poly(BULK) <MOM_field5> <MOM_field4> <F_reg4> <mom47_mx_faux> <metal7> [
    property w,s,nr,lr,stm,spm,mf
    mf1 = count(metal7)-2
    mf = mf1/2
    nr = count(MOM_field5)/mf1
    w = perimeter_coincide(MOM_field4,mom47_mx_faux)/(nr*mf1)
    lr = (area(MOM_field5)/(nr*mf1))/w
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field5))/2)/(mf1*(nr-1))
    stm = 4
    spm = 7  
]






mom57_1 = MOMDMY7 NOT INTERACT MOM_field1
mom57_2 = mom57_1 NOT INTERACT MOM_field2
mom57_3 = mom57_2 NOT INTERACT MOM_field3
mom57_4 = mom57_3 NOT INTERACT MOM_field4


mom57_5 = mom57_4 INTERACT MOM_field5

mom57_6 = mom57_5 INTERACT MOM_field6

mom57_7 = mom57_6 INTERACT MOM_field7




mom57_reg1 = mom57_7 NOT INTERACT RFDMY
mom57_reg2 = mom57_reg1 NOT MOMDMY22
mom57_reg3 = mom57_reg2 NOT MAC
mom57_reg4 = mom57_reg3 NOT INTERACT MOMDMY_2T
mom57_reg  = mom57_reg4 INTERACT poly			// RTMOM_3T
mom57_reg_2t = mom57_reg3 INTERACT MOMDMY_2T		// RTMOM_2T
mom57_reg_rf1 = mom57_7 INTERACT RFDMY
mom57_reg_rf2 = mom57_reg_rf1 NOT MOMDMY22 
mom57_reg_rf3 = mom57_reg_rf2 NOT MAC
mom57_reg_rf  = mom57_reg_rf3 NOT RDKDMY
mom57_reg_rf_rdk  = mom57_reg_rf3 AND RDKDMY

mom57_mx_reg1 = MOMDMY22 INTERACT mom57_7
mom57_mx_reg2 = mom57_mx_reg1 NOT MAC
mom57_mx_reg3 = mom57_mx_reg2 NOT INTERACT MOMDMY_2T
mom57_mx_reg  = mom57_mx_reg3 INTERACT poly		// RTMOM_MX 5T
mom57_mx_reg_4t = mom57_mx_reg2 INTERACT MOMDMY_2T	// RTMOM_MX 4T
mom57_mx_aux1 = mom57_7 AND MOMDMY22
mom57_mx_aux  = mom57_mx_aux1 NOT MAC
mom57_freg  = mom57_reg2 AND MAC
mom57_mx_freg  = mom57_mx_reg1 AND MAC
mom57_mx_faux  = mom57_mx_aux1 AND MAC



DEVICE crtmom mom57_reg metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field5> <MOM_field6> <F_reg5> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field5)
    nh = count(MOM_field6)
    w =  perimeter_coincide(MOM_field6,mom57_reg)/ nh
    s =  ((perimeter(F_reg5)-perimeter_coincide(F_reg5,MOM_field5))/2)/(nv-1)
    stm = 5
    spm = 7
]
DEVICE crtmom_2t mom57_reg_2t metal7(PLUS) metal7(MINUS) <MOM_field5> <MOM_field6> <F_reg5> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field5)
    nh = count(MOM_field6)
    w =  perimeter_coincide(MOM_field6,mom57_reg_2t)/ nh
    s =  ((perimeter(F_reg5)-perimeter_coincide(F_reg5,MOM_field5))/2)/(nv-1)
    stm = 5
    spm = 7
]
DEVICE crtmom_rf mom57_reg_rf metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field5> <MOM_field6> <F_reg5> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field5)
    nh = count(MOM_field6)
    w =  perimeter_coincide(MOM_field6,mom57_reg_rf)/ nh
    s =  ((perimeter(F_reg5)-perimeter_coincide(F_reg5,MOM_field5))/2)/(nv-1)
    stm = 5
    spm = 7
]

DEVICE crtmom_rf_rdk mom57_reg_rf_rdk metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field5> <MOM_field6> <F_reg5> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field5)
    nh = count(MOM_field6)
    w =  perimeter_coincide(MOM_field6,mom57_reg_rf_rdk)/ nh
    s =  ((perimeter(F_reg5)-perimeter_coincide(F_reg5,MOM_field5))/2)/(nv-1)
    stm = 5
    spm = 7
]

DEVICE crtmom_mx mom57_mx_reg mom7p1(PLUS1) mom7m1(MINUS1) mom7p2(PLUS2) mom7m2(MINUS2) poly(BULK) <MOM_field5> <MOM_field6> <F_reg5> <mom57_mx_aux> <metal7> [
    property w,s,nv,nh,stm,spm,mf
    mf1 = count(metal7)-2
    mf = mf1/2
    nv = count(MOM_field5)/mf1
    nh = count(MOM_field6)/mf1
    w =  perimeter_coincide(MOM_field6,mom57_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg5)-perimeter_coincide(F_reg5,MOM_field5))/2)/(mf1*(nv-1))
    stm = 5
    spm = 7
]
DEVICE fmom mom57_freg metal7(PLUS) metal7(MINUS) poly(BULK) <MOM_field5> <MOM_field6> <F_reg5> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field5)
    w =  perimeter_coincide(MOM_field6,mom57_freg)/ nr 
    lr = (area(MOM_field5)/nr)/w
    s =  ((perimeter(F_reg5)-perimeter_coincide(F_reg5,MOM_field5))/2)/(nr-1)
    stm = 5
    spm = 7
]

DEVICE fmom_mx mom57_mx_freg mom7p1(PLUS1) mom7m1(MINUS1) mom7p2(PLUS2) mom7m2(MINUS2) poly(BULK) <MOM_field5> <MOM_field6> <F_reg5> <mom57_mx_faux> <metal7> [
    property w,s,nr,lr,stm,spm,mf
    mf1 = count(metal7)-2
    mf = mf1/2
    nr = count(MOM_field5)/mf1
    w = perimeter_coincide(MOM_field6,mom57_mx_faux)/(nr*mf1)
    lr = (area(MOM_field5)/(nr*mf1))/w
    s =  ((perimeter(F_reg5)-perimeter_coincide(F_reg5,MOM_field5))/2)/(mf1*(nr-1))
    stm = 5
    spm = 7  
]





TRACE PROPERTY crtmom_rf nv nv 0 
TRACE PROPERTY crtmom_rf nh nh 0 
TRACE PROPERTY crtmom_rf s  s 0 
TRACE PROPERTY crtmom_rf w  w 0
TRACE PROPERTY crtmom_rf stm stm 0
TRACE PROPERTY crtmom_rf spm spm 0
TRACE PROPERTY crtmom_rf_rdk nv nv 0 
TRACE PROPERTY crtmom_rf_rdk nh nh 0 
TRACE PROPERTY crtmom_rf_rdk s  s 0 
TRACE PROPERTY crtmom_rf_rdk w  w 0
TRACE PROPERTY crtmom_rf_rdk stm stm 0
TRACE PROPERTY crtmom_rf_rdk spm spm 0


TRACE PROPERTY crtmom nv nv 0 
TRACE PROPERTY crtmom nh nh 0 
TRACE PROPERTY crtmom s  s 0 
TRACE PROPERTY crtmom w  w 0
TRACE PROPERTY crtmom stm stm 0
TRACE PROPERTY crtmom spm spm 0

TRACE PROPERTY crtmom_2t nv nv 0 
TRACE PROPERTY crtmom_2t nh nh 0 
TRACE PROPERTY crtmom_2t s  s 0 
TRACE PROPERTY crtmom_2t w  w 0
TRACE PROPERTY crtmom_2t stm stm 0
TRACE PROPERTY crtmom_2t spm spm 0

TRACE PROPERTY crtmom_mx nv nv 0 
TRACE PROPERTY crtmom_mx nh nh 0 
TRACE PROPERTY crtmom_mx s  s 0 
TRACE PROPERTY crtmom_mx w  w 0
TRACE PROPERTY crtmom_mx stm stm 0
TRACE PROPERTY crtmom_mx spm spm 0
TRACE PROPERTY crtmom_mx mf mf 0


TRACE PROPERTY fmom nr nr 0 
TRACE PROPERTY fmom lr lr 0 
TRACE PROPERTY fmom s  s 0 
TRACE PROPERTY fmom w  w 0
TRACE PROPERTY fmom stm stm 0
TRACE PROPERTY fmom spm spm 0

TRACE PROPERTY fmom_mx nr nr 0 
TRACE PROPERTY fmom_mx lr lr 0 
TRACE PROPERTY fmom_mx s  s 0 
TRACE PROPERTY fmom_mx w  w 0
TRACE PROPERTY fmom_mx stm stm 0
TRACE PROPERTY fmom_mx spm spm 0
TRACE PROPERTY fmom_mx mf mf 0



//

//

//

//

#IFDEF extract_dnwdio
DEVICE D(pwdnw) rwdio psub DNW
TRACE PROPERTY D(pwdnw) a a 0
DEVICE D(dnwpsub) dnwdio psub_term DNW [
   property a,pj
   a = area(dnw)
   pj = perimeter(dnw)
]
TRACE PROPERTY D(dnwpsub) a a 0
#ENDIF

//

//

DEVICE lincap lin_nw poly(PLUS) tndiff(MINUS) <lingt> <nthin> [
  property lr,wr,mr,gr
  gr = count(nthin)
  mr = count(lingt)/gr
  wr = (perimeter_coincide(lingt,tndiff)/2)/(mr*gr)
  lr = (area(lingt)/wr)/(mr*gr)
]
TRACE PROPERTY lincap lr lr 0
TRACE PROPERTY lincap wr wr 0
TRACE PROPERTY lincap mr mr 0

DEVICE lincap_25 lin_nw_25 poly(PLUS) tndiff(MINUS) <lingt_25> <nthin> [
  property lr,wr,mr,gr
  gr = count(nthin)
  mr = count(lingt_25)/gr
  wr = (perimeter_coincide(lingt_25,tndiff)/2)/(mr*gr)
  lr = (area(lingt_25)/wr)/(mr*gr)
]
TRACE PROPERTY lincap_25 lr lr 0
TRACE PROPERTY lincap_25 wr wr 0
TRACE PROPERTY lincap_25 mr mr 0

DEVICE lincap_rf lin_nw_rf poly(PLUS) tndiff(MINUS) psub(BULK) <lingt_rf> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(lingt_rf)/gr
  wr = (perimeter_coincide(lingt_rf,tndiff)/2)/(br*gr)
  lr = (area(lingt_rf)/wr)/(br*gr)
]
TRACE PROPERTY lincap_rf lr lr 0
TRACE PROPERTY lincap_rf wr wr 0
TRACE PROPERTY lincap_rf br br 0
TRACE PROPERTY lincap_rf gr gr 0

DEVICE lincap_rf_25 lin_nw_rf_25 poly(PLUS) tndiff(MINUS) psub(BULK) <lingt_rf_25> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(lingt_rf_25)/gr
  wr = (perimeter_coincide(lingt_rf_25,tndiff)/2)/(br*gr)
  lr = (area(lingt_rf_25)/wr)/(br*gr)
]
TRACE PROPERTY lincap_rf_25 lr lr 0
TRACE PROPERTY lincap_rf_25 wr wr 0
TRACE PROPERTY lincap_rf_25 br br 0
TRACE PROPERTY lincap_rf_25 gr gr 0

DEVICE lowcpad_d15 rfpad_15 metal10(APAD) poly(AVSS) <ext_rfpad> <bot_dmy> netlist model lowcpad_d15 [
  property lt,wt,lay
  A_PAD = area(ext_rfpad)
  P_PAD = perimeter(ext_rfpad)
  P_2_PAD = P_PAD * P_PAD
  AC4 = A_PAD * 16
  KKK = P_2_PAD-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_PAD+SQ)/4
  wt = (P_PAD-SQ)/4
  lay = 9
]
TRACE PROPERTY lowcpad_d15 lt lt 0
TRACE PROPERTY lowcpad_d15 wt wt 0
TRACE PROPERTY lowcpad_d15 lay lay 0

DEVICE lowcpad_d23 rfpad_23 metal10(APAD) poly(AVSS) <ext_rfpad> <bot_dmy> netlist model lowcpad_d23 [
  property lt,wt,lay
  A_PAD = area(ext_rfpad)
  P_PAD = perimeter(ext_rfpad)
  P_2_PAD = P_PAD * P_PAD
  AC4 = A_PAD * 16
  KKK = P_2_PAD-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_PAD+SQ)/4
  wt = (P_PAD-SQ)/4
  lay = 9
]
TRACE PROPERTY lowcpad_d23 lt lt 0
TRACE PROPERTY lowcpad_d23 wt wt 0
TRACE PROPERTY lowcpad_d23 lay lay 0

// Define RFPAD



ext_rfpad = EXTENTS rfpad    // For calculate lt/wt

D_15a = rfpad NOT INTERACT RFPADDMY1
D_15b = D_15a AND RFPADDMY2
rfpad_15  = D_15b NOT INTERACT RFPADDMY3

D_23a = rfpad NOT INTERACT RFPADDMY1
D_23b = D_23a NOT INTERACT RFPADDMY2
rfpad_23  = D_23b AND RFPADDMY3

CONNECT rfpad_15 metal9
CONNECT rfpad_23 metal9

mim_block = COPY mim_top
RFDMYall = RFDMY OR RFDMYUD
shield1 = metal6 OR metal5
shield2 = shield1 AND ctm
shield3 = shield2 AND RFDMY
shield  = shield3 NOT INTERACT CTMDMYUD
shieldud  = shield2 AND RFDMYUD
RCTM = mim_block INTERACT VIA7i
RCBM = cbm INTERACT RCTM
OCBM = RCBM NOT RCTM
ctm_via = RCTM AND VIA7i
cbm_via = OCBM AND VIA7i
tvia1   = VIA7i NOT ctm_via
VIA7  = tvia1 NOT cbm_via
VIA8   = COPY VIA8i 
L_EG1    = ctm INSIDE EDGE metal8
L_EG_RG1 = EXPAND EDGE L_EG1 OUTSIDE BY 0.005
L_EG     = ctm TOUCH EDGE L_EG_RG1
L_EG_RG = EXPAND EDGE L_EG OUTSIDE BY 0.005
//CONNECT STATEMENT
CONNECT  metal8  ctm BY ctm_via
CONNECT  metal8  cbm BY cbm_via
CONNECT  mim_block ctm
CONNECT  metal8 metal7 BY VIA7
CONNECT  metal9  metal8  BY VIA8
CONNECT  shield  metal6
CONNECT  shieldud  metal6
SCONNECT psub MIM_TERM BY mim_psub_via
SCONNECT nxwell MIM_TERM BY mim_nw_via
SCONNECT psub RF_MIM_TERM BY rfmim_psub_via
SCONNECT nxwell RF_MIM_TERM BY rfmim_nw_via


RCTM_RF1 = RCTM AND RFDMY
RCTM_RF2 = RCTM_RF1 INTERACT shield
RCTM_RF  = RCTM_RF2 NOT RFDMYUD
RCTM_RF1P5 = RCTM_RF AND CAP1P5                // cap unit 1.5f RF wium
RCTM_RF2P0 = RCTM_RF AND CAP2P0                // cap unit 2.0f RF wium
RCTM_RF1P0 = RCTM_RF AND CAP1P0                // cap unit 1.0f RF wium
RCTM_RF_woum1 = RCTM_RF1 NOT INTERACT shield
RCTM_RF_woum  = RCTM_RF_woum1 NOT INTERACT CTMDMYUD
RCTM_RF1P5_woum = RCTM_RF_woum AND CAP1P5      // cap unit 1.5f RF woum
RCTM_RF2P0_woum = RCTM_RF_woum AND CAP2P0      // cap unit 2.0f RF woum
RCTM_RF1P0_woum = RCTM_RF_woum AND CAP1P0      // cap unit 1.0f RF woum
RCTM_RFUD1 = RCTM AND RFDMYUD
RCTM_RFUD = RCTM_RFUD1 INTERACT shieldud
RCTM_RF1P5UD = RCTM_RFUD AND CAP1P5            // cap unit 1.5f RF wium UD
RCTM_RF2P0UD = RCTM_RFUD AND CAP2P0            // cap unit 2.0f RF wium UD
RCTM_RF1P0UD = RCTM_RFUD AND CAP1P0            // cap unit 1.0f RF wium UD

RCTM_R1  = RCTM NOT RFDMYall
RCTM_R   = RCTM_R1 NOT CTMDMYUD
RCTM_RUD1 = RCTM NOT RFDMYUD
RCTM_RUD  = RCTM_RUD1 AND CTMDMYUD
RCTM_R_3T = RCTM_R1 AND MIM_3TDMY
RCTM_R_2T = RCTM_R NOT MIM_3TDMY
RCTM_R_2TUD = RCTM_RUD NOT MIM_3TDMY

RCTM_R1P5 = RCTM_R_2T AND CAP1P5                // cap unit 1.5f 2T
RCTM_R2P0 = RCTM_R_2T AND CAP2P0                // cap unit 2.0f 2T
RCTM_R1P0 = RCTM_R_2T AND CAP1P0                // cap unit 1.0f 2T
RCTM_R1P5UD = RCTM_R_2TUD AND CAP1P5            // cap unit 1.5f 2T UD
RCTM_R2P0UD = RCTM_R_2TUD AND CAP2P0            // cap unit 2.0f 2T UD
RCTM_R1P0UD = RCTM_R_2TUD AND CAP1P0            // cap unit 1.0f 2T UD

RCTM_R1P5_3T = RCTM_R_3T AND CAP1P5             // cap unit 1.5f 3T
RCTM_R2P0_3T = RCTM_R_3T AND CAP2P0             // cap unit 2.0f 3T
RCTM_R1P0_3T = RCTM_R_3T AND CAP1P0             // cap unit 1.0f 3T

RF_MIM_TERM1 = SIZE RCTM_RF_woum BY 0.005
RF_MIM_TERM = RF_MIM_TERM1 NOT RCTM_RF_woum
rfmim_psub_via = RF_MIM_TERM AND psub
rfmim_nw_via = RF_MIM_TERM AND nxwell

MIM_TERM = SIZE RCTM_R_3T BY 0.005
mim_psub_via = MIM_TERM AND psub
mim_nw_via   = MIM_TERM AND nxwell

DEVICE mimcap_sin RCTM_R1P0 ctm(PLUS) cbm(MINUS) [
  property lt,wt,mimflag
  A_CAP = area(RCTM_R1P0)
  P_CAP = perimeter(RCTM_R1P0)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
  mimflag = 1
]
DEVICE mimcap_sin RCTM_R1P5 ctm(PLUS) cbm(MINUS) [
  property lt,wt,mimflag
  A_CAP = area(RCTM_R1P5)
  P_CAP = perimeter(RCTM_R1P5)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
  mimflag = 2
]
DEVICE mimcap_sin RCTM_R2P0 ctm(PLUS) cbm(MINUS) [
  property lt,wt,mimflag
  A_CAP = area(RCTM_R2P0)
  P_CAP = perimeter(RCTM_R2P0)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
  mimflag = 3
]
DEVICE mimcap_sin RCTM_R1P0UD ctm(PLUS) cbm(MINUS) [
  property lt,wt,mimflag
  A_CAP = area(RCTM_R1P0UD)
  P_CAP = perimeter(RCTM_R1P0UD)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
  mimflag = 1
]
DEVICE mimcap_sin RCTM_R1P5UD ctm(PLUS) cbm(MINUS) [
  property lt,wt,mimflag
  A_CAP = area(RCTM_R1P5UD)
  P_CAP = perimeter(RCTM_R1P5UD)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
  mimflag = 2
]
DEVICE mimcap_sin RCTM_R2P0UD ctm(PLUS) cbm(MINUS) [
  property lt,wt,mimflag
  A_CAP = area(RCTM_R2P0UD)
  P_CAP = perimeter(RCTM_R2P0UD)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
  mimflag = 3
]
TRACE PROPERTY mimcap_sin lt lt 0
TRACE PROPERTY mimcap_sin wt wt 0
TRACE PROPERTY mimcap_sin mimflag mimflag 0

DEVICE mimcap_sin_3t RCTM_R1P0_3T ctm(PLUS) cbm(MINUS) MIM_TERM(BULK) [
  property lt,wt,lay,mimflag
  A_CAP = area(RCTM_R1P0_3T)
  P_CAP = perimeter(RCTM_R1P0_3T)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
  mimflag = 1
  lay = 7

]
DEVICE mimcap_sin_3t RCTM_R1P5_3T ctm(PLUS) cbm(MINUS) MIM_TERM(BULK) [
  property lt,wt,lay,mimflag
  A_CAP = area(RCTM_R1P5_3T)
  P_CAP = perimeter(RCTM_R1P5_3T)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
  mimflag = 2
  lay = 7

]
DEVICE mimcap_sin_3t RCTM_R2P0_3T ctm(PLUS) cbm(MINUS) MIM_TERM(BULK) [
  property lt,wt,lay,mimflag
  A_CAP = area(RCTM_R2P0_3T)
  P_CAP = perimeter(RCTM_R2P0_3T)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
  mimflag = 3
  lay = 7

]
TRACE PROPERTY mimcap_sin_3t lt lt 0
TRACE PROPERTY mimcap_sin_3t wt wt 0
TRACE PROPERTY mimcap_sin_3t lay lay 0
TRACE PROPERTY mimcap_sin_3t mimflag mimflag 0

DEVICE mimcap_um_sin_rf RCTM_RF1P0 ctm(PLUS) cbm(MINUS) shield(BULK) <L_EG_RG> [
  property lt,wt,mimflag
  lt = perimeter_coincide(RCTM_RF1P0,L_EG_RG)/2
  wt = area(RCTM_RF1P0)/lt
  mimflag = 1
]
DEVICE mimcap_um_sin_rf RCTM_RF1P5 ctm(PLUS) cbm(MINUS) shield(BULK) <L_EG_RG> [
  property lt,wt,mimflag
  lt = perimeter_coincide(RCTM_RF1P5,L_EG_RG)/2
  wt = area(RCTM_RF1P5)/lt
  mimflag = 2
]
DEVICE mimcap_um_sin_rf RCTM_RF2P0 ctm(PLUS) cbm(MINUS) shield(BULK) <L_EG_RG> [
  property lt,wt,mimflag
  lt = perimeter_coincide(RCTM_RF2P0,L_EG_RG)/2
  wt = area(RCTM_RF2P0)/lt
  mimflag = 3
]
DEVICE mimcap_um_sin_rf RCTM_RF1P0UD ctm(PLUS) cbm(MINUS) shieldud(BULK) <L_EG_RG> [
  property lt,wt,mimflag
  lt = perimeter_coincide(RCTM_RF1P0UD,L_EG_RG)/2
  wt = area(RCTM_RF1P0UD)/lt
  mimflag = 1
]
DEVICE mimcap_um_sin_rf RCTM_RF1P5UD ctm(PLUS) cbm(MINUS) shieldud(BULK) <L_EG_RG> [
  property lt,wt,mimflag
  lt = perimeter_coincide(RCTM_RF1P5UD,L_EG_RG)/2
  wt = area(RCTM_RF1P5UD)/lt
  mimflag = 2
]
DEVICE mimcap_um_sin_rf RCTM_RF2P0UD ctm(PLUS) cbm(MINUS) shieldud(BULK) <L_EG_RG> [
  property lt,wt,mimflag
  lt = perimeter_coincide(RCTM_RF2P0UD,L_EG_RG)/2
  wt = area(RCTM_RF2P0UD)/lt
  mimflag = 3
]
TRACE PROPERTY mimcap_um_sin_rf lt lt 0
TRACE PROPERTY mimcap_um_sin_rf wt wt 0
TRACE PROPERTY mimcap_um_sin_rf mimflag mimflag 0

DEVICE mimcap_woum_sin_rf RCTM_RF1P0_woum ctm(PLUS) cbm(MINUS) RF_MIM_TERM(BULK) <L_EG_RG> [
  property lt,wt,lay,mimflag
  lt = perimeter_coincide(RCTM_RF1P0_woum,L_EG_RG)/2
  wt = area(RCTM_RF1P0_woum)/lt
  mimflag = 1
  lay = 7

]
DEVICE mimcap_woum_sin_rf RCTM_RF1P5_woum ctm(PLUS) cbm(MINUS) RF_MIM_TERM(BULK) <L_EG_RG> [
  property lt,wt,lay,mimflag
  lt = perimeter_coincide(RCTM_RF1P5_woum,L_EG_RG)/2
  wt = area(RCTM_RF1P5_woum)/lt
  mimflag = 2
  lay = 7

]
DEVICE mimcap_woum_sin_rf RCTM_RF2P0_woum ctm(PLUS) cbm(MINUS) RF_MIM_TERM(BULK) <L_EG_RG> [
  property lt,wt,lay,mimflag
  lt = perimeter_coincide(RCTM_RF2P0_woum,L_EG_RG)/2
  wt = area(RCTM_RF2P0_woum)/lt
  mimflag = 3
  lay = 7

]
TRACE PROPERTY mimcap_woum_sin_rf lt lt 0
TRACE PROPERTY mimcap_woum_sin_rf wt wt 0
TRACE PROPERTY mimcap_woum_sin_rf lay lay 0
TRACE PROPERTY mimcap_woum_sin_rf mimflag mimflag 0

DEVICE moscap_rf var_nw3_rf poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(vargt_rf)/gr
  wr = (perimeter_coincide(vargt_rf,tndiff)/2)/(br*gr)
  lr = (area(vargt_rf)/wr)/(br*gr)
]
TRACE PROPERTY moscap_rf lr lr 0
TRACE PROPERTY moscap_rf wr wr 0
TRACE PROPERTY moscap_rf br br 0
TRACE PROPERTY moscap_rf gr gr 0

DEVICE moscap_rf18 var_nw_rf18 poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf18> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(vargt_rf18)/gr
  wr = (perimeter_coincide(vargt_rf18,tndiff)/2)/(br*gr)
  lr = (area(vargt_rf18)/wr)/(br*gr)
]
TRACE PROPERTY moscap_rf18 lr lr 0
TRACE PROPERTY moscap_rf18 wr wr 0
TRACE PROPERTY moscap_rf18 br br 0
TRACE PROPERTY moscap_rf18 gr gr 0

DEVICE moscap_rf18_nw var_nw_rf18_nw poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf18> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(vargt_rf18)/gr
  wr = (perimeter_coincide(vargt_rf18,tndiff)/2)/(br*gr)
  lr = (area(vargt_rf18)/wr)/(br*gr)
]
TRACE PROPERTY moscap_rf18_nw lr lr 0
TRACE PROPERTY moscap_rf18_nw wr wr 0
TRACE PROPERTY moscap_rf18_nw br br 0
TRACE PROPERTY moscap_rf18_nw gr gr 0

DEVICE moscap_rf25 var_nw_rf25 poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf25> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(vargt_rf25)/gr
  wr = (perimeter_coincide(vargt_rf25,tndiff)/2)/(br*gr)
  lr = (area(vargt_rf25)/wr)/(br*gr)
]
TRACE PROPERTY moscap_rf25 lr lr 0
TRACE PROPERTY moscap_rf25 wr wr 0
TRACE PROPERTY moscap_rf25 br br 0
TRACE PROPERTY moscap_rf25 gr gr 0

DEVICE moscap_rf25_nw var_nw_rf25_nw poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf25> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(vargt_rf25)/gr
  wr = (perimeter_coincide(vargt_rf25,tndiff)/2)/(br*gr)
  lr = (area(vargt_rf25)/wr)/(br*gr)
]
TRACE PROPERTY moscap_rf25_nw lr lr 0
TRACE PROPERTY moscap_rf25_nw wr wr 0
TRACE PROPERTY moscap_rf25_nw br br 0
TRACE PROPERTY moscap_rf25_nw gr gr 0

DEVICE moscap_rf33 var_nw_rf33 poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf33> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(vargt_rf33)/gr
  wr = (perimeter_coincide(vargt_rf33,tndiff)/2)/(br*gr)
  lr = (area(vargt_rf33)/wr)/(br*gr)
]
TRACE PROPERTY moscap_rf33 lr lr 0
TRACE PROPERTY moscap_rf33 wr wr 0
TRACE PROPERTY moscap_rf33 br br 0
TRACE PROPERTY moscap_rf33 gr gr 0

DEVICE moscap_rf33_nw var_nw_rf33_nw poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf33> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(vargt_rf33)/gr
  wr = (perimeter_coincide(vargt_rf33,tndiff)/2)/(br*gr)
  lr = (area(vargt_rf33)/wr)/(br*gr)
]
TRACE PROPERTY moscap_rf33_nw lr lr 0
TRACE PROPERTY moscap_rf33_nw wr wr 0
TRACE PROPERTY moscap_rf33_nw br br 0
TRACE PROPERTY moscap_rf33_nw gr gr 0

DEVICE moscap_rf_hvt var_nw3_rf_hvt poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf_hvt> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(vargt_rf_hvt)/gr
  wr = (perimeter_coincide(vargt_rf_hvt,tndiff)/2)/(br*gr)
  lr = (area(vargt_rf_hvt)/wr)/(br*gr)
]
TRACE PROPERTY moscap_rf_hvt lr lr 0
TRACE PROPERTY moscap_rf_hvt wr wr 0
TRACE PROPERTY moscap_rf_hvt br br 0
TRACE PROPERTY moscap_rf_hvt gr gr 0

DEVICE moscap_rf_hvt_nw var_nw3_rf_hvt_nw poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf_hvt> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(vargt_rf_hvt)/gr
  wr = (perimeter_coincide(vargt_rf_hvt,tndiff)/2)/(br*gr)
  lr = (area(vargt_rf_hvt)/wr)/(br*gr)
]
TRACE PROPERTY moscap_rf_hvt_nw lr lr 0
TRACE PROPERTY moscap_rf_hvt_nw wr wr 0
TRACE PROPERTY moscap_rf_hvt_nw br br 0
TRACE PROPERTY moscap_rf_hvt_nw gr gr 0

DEVICE moscap_rf_nw var_nw3_rf_nw poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(vargt_rf)/gr
  wr = (perimeter_coincide(vargt_rf,tndiff)/2)/(br*gr)
  lr = (area(vargt_rf)/wr)/(br*gr)
]
TRACE PROPERTY moscap_rf_nw lr lr 0
TRACE PROPERTY moscap_rf_nw wr wr 0
TRACE PROPERTY moscap_rf_nw br br 0
TRACE PROPERTY moscap_rf_nw gr gr 0

DEVICE moscap_rf_rdk var_nw3_rdk poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(vargt_rf)/gr
  wr = (perimeter_coincide(vargt_rf,tndiff)/2)/(br*gr)
  lr = (area(vargt_rf)/wr)/(br*gr)
]
TRACE PROPERTY moscap_rf_rdk lr lr 0
TRACE PROPERTY moscap_rf_rdk wr wr 0
TRACE PROPERTY moscap_rf_rdk br br 0
TRACE PROPERTY moscap_rf_rdk gr gr 0

DEVICE ndio_hia_rf ndio_hia psub(PLUS) tndiff(MINUS) netlist model ndio_hia_rf [
  property al,aw

  A_HIA = area(ndio_hia)
  P_HIA = perimeter(ndio_hia)
  P_2_HIA = P_HIA * P_HIA
  AHIA4 = A_HIA * 16
  KKK = P_2_HIA-AHIA4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  al = (P_HIA+SQ)/4
  aw = (P_HIA-SQ)/4
]  

TRACE PROPERTY ndio_hia_rf al al 0
TRACE PROPERTY ndio_hia_rf aw aw 0

DEVICE nmos_rf ngate_nthin d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf> [
   property lr,wr,nr
   nr = count(ngate_rf)
   wr = ((perimeter_coincide(ngate_rf,s_tndiff)+ perimeter_coincide(ngate_rf,d_tndiff))/2)/nr
   lr = (area(ngate_rf)/wr)/nr
]
TRACE PROPERTY nmos_rf wr wr 0
TRACE PROPERTY nmos_rf lr lr 0
TRACE PROPERTY nmos_rf nr nr 0

DEVICE nmos_rf_18 ngate_nthin_18 d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf_18> [
   property lr,wr,nr
   nr = count(ngate_rf_18)
   wr = ((perimeter_coincide(ngate_rf_18,s_tndiff)+ perimeter_coincide(ngate_rf_18,d_tndiff))/2)/nr
   lr = (area(ngate_rf_18)/wr)/nr
]
TRACE PROPERTY nmos_rf_18 wr wr 0
TRACE PROPERTY nmos_rf_18 lr lr 0
TRACE PROPERTY nmos_rf_18 nr nr 0

DEVICE nmos_rf_18_6t ngate_nthin_18_6t d_tndiff(D) poly_rf(G) s_tndiff(S) rwel(B) DNW(NG) rfdmy56(PG) <ngate_rf_18> netlist model nmos_rf_18_6t [
   property lr,wr,nr
   nr = count(ngate_rf_18)
   wr = ((perimeter_coincide(ngate_rf_18,s_tndiff)+ perimeter_coincide(ngate_rf_18,d_tndiff))/2)/nr
   lr = (area(ngate_rf_18)/wr)/nr
]
TRACE PROPERTY nmos_rf_18_6t wr wr 0 
TRACE PROPERTY nmos_rf_18_6t lr lr 0
TRACE PROPERTY nmos_rf_18_6t nr nr 0

DEVICE nmos_rf_18_nodnw ngate_nthin_18nodnw d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf_18> netlist model nmos_rf_18 [
   property lr,wr,nr
   nr = count(ngate_rf_18)
   wr = ((perimeter_coincide(ngate_rf_18,s_tndiff)+ perimeter_coincide(ngate_rf_18,d_tndiff))/2)/nr
   lr = (area(ngate_rf_18)/wr)/nr
]
TRACE PROPERTY nmos_rf_18_nodnw wr wr 0
TRACE PROPERTY nmos_rf_18_nodnw lr lr 0
TRACE PROPERTY nmos_rf_18_nodnw nr nr 0

DEVICE nmos_rf_25 ngate_nthin_25 d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf_25> [
   property lr,wr,nr
   nr = count(ngate_rf_25)
   wr = ((perimeter_coincide(ngate_rf_25,s_tndiff)+ perimeter_coincide(ngate_rf_25,d_tndiff))/2)/nr
   lr = (area(ngate_rf_25)/wr)/nr
]
TRACE PROPERTY nmos_rf_25 wr wr 0
TRACE PROPERTY nmos_rf_25 lr lr 0
TRACE PROPERTY nmos_rf_25 nr nr 0

DEVICE nmos_rf_25_6t ngate_nthin_25_6t d_tndiff(D) poly_rf(G) s_tndiff(S) rwel(B) DNW(NG) rfdmy56(PG) <ngate_rf_25> netlist model nmos_rf_25_6t [
   property lr,wr,nr
   nr = count(ngate_rf_25)
   wr = ((perimeter_coincide(ngate_rf_25,s_tndiff)+ perimeter_coincide(ngate_rf_25,d_tndiff))/2)/nr
   lr = (area(ngate_rf_25)/wr)/nr
]
TRACE PROPERTY nmos_rf_25_6t wr wr 0 
TRACE PROPERTY nmos_rf_25_6t lr lr 0
TRACE PROPERTY nmos_rf_25_6t nr nr 0

DEVICE nmos_rf_25_nodnw ngate_nthin_25nodnw d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf_25> netlist model nmos_rf_25 [
   property lr,wr,nr
   nr = count(ngate_rf_25)
   wr = ((perimeter_coincide(ngate_rf_25,s_tndiff)+ perimeter_coincide(ngate_rf_25,d_tndiff))/2)/nr
   lr = (area(ngate_rf_25)/wr)/nr
]
TRACE PROPERTY nmos_rf_25_nodnw wr wr 0
TRACE PROPERTY nmos_rf_25_nodnw lr lr 0
TRACE PROPERTY nmos_rf_25_nodnw nr nr 0

DEVICE nmos_rf_25_nodnwod ngate_nthin_25nodnwod d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf_25od> netlist model nmos_rf_33 [
   property lr,wr,nr
   nr = count(ngate_rf_25od)
   wr = ((perimeter_coincide(ngate_rf_25od,s_tndiff)+ perimeter_coincide(ngate_rf_25od,d_tndiff))/2)/nr
   lr = (area(ngate_rf_25od)/wr)/nr
]
TRACE PROPERTY nmos_rf_25_nodnwod wr wr 0
TRACE PROPERTY nmos_rf_25_nodnwod lr lr 0
TRACE PROPERTY nmos_rf_25_nodnwod nr nr 0

DEVICE nmos_rf_25_nodnwud ngate_nthin_25nodnwud d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf_25ud> netlist model nmos_rf_18 [
   property lr,wr,nr
   nr = count(ngate_rf_25ud)
   wr = ((perimeter_coincide(ngate_rf_25ud,s_tndiff)+ perimeter_coincide(ngate_rf_25ud,d_tndiff))/2)/nr
   lr = (area(ngate_rf_25ud)/wr)/nr
]
TRACE PROPERTY nmos_rf_25_nodnwud wr wr 0
TRACE PROPERTY nmos_rf_25_nodnwud lr lr 0
TRACE PROPERTY nmos_rf_25_nodnwud nr nr 0

DEVICE nmos_rf_25od ngate_nthin_25od d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf_25od> netlist model nmos_rf_33 [
   property lr,wr,nr
   nr = count(ngate_rf_25od)
   wr = ((perimeter_coincide(ngate_rf_25od,s_tndiff)+ perimeter_coincide(ngate_rf_25od,d_tndiff))/2)/nr
   lr = (area(ngate_rf_25od)/wr)/nr
]
TRACE PROPERTY nmos_rf_25od wr wr 0
TRACE PROPERTY nmos_rf_25od lr lr 0
TRACE PROPERTY nmos_rf_25od nr nr 0

DEVICE nmos_rf_25od33_6t ngate_nthin_25od_6t d_tndiff(D) poly_rf(G) s_tndiff(S) rwel(B) DNW(NG) rfdmy56(PG) <ngate_rf_25od> netlist model nmos_rf_33_6t [
   property lr,wr,nr
   nr = count(ngate_rf_25od)
   wr = ((perimeter_coincide(ngate_rf_25od,s_tndiff)+ perimeter_coincide(ngate_rf_25od,d_tndiff))/2)/nr
   lr = (area(ngate_rf_25od)/wr)/nr
]
TRACE PROPERTY nmos_rf_25od33_6t wr wr 0 
TRACE PROPERTY nmos_rf_25od33_6t lr lr 0
TRACE PROPERTY nmos_rf_25od33_6t nr nr 0

DEVICE nmos_rf_25ud ngate_nthin_25ud d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf_25ud> netlist model nmos_rf_18 [
   property lr,wr,nr
   nr = count(ngate_rf_25ud)
   wr = ((perimeter_coincide(ngate_rf_25ud,s_tndiff)+ perimeter_coincide(ngate_rf_25ud,d_tndiff))/2)/nr
   lr = (area(ngate_rf_25ud)/wr)/nr
]
TRACE PROPERTY nmos_rf_25ud wr wr 0
TRACE PROPERTY nmos_rf_25ud lr lr 0
TRACE PROPERTY nmos_rf_25ud nr nr 0

DEVICE nmos_rf_25ud18_6t ngate_nthin_25ud_6t d_tndiff(D) poly_rf(G) s_tndiff(S) rwel(B) DNW(NG) rfdmy56(PG) <ngate_rf_25ud> netlist model nmos_rf_18_6t [
   property lr,wr,nr
   nr = count(ngate_rf_25ud)
   wr = ((perimeter_coincide(ngate_rf_25ud,s_tndiff)+ perimeter_coincide(ngate_rf_25ud,d_tndiff))/2)/nr
   lr = (area(ngate_rf_25ud)/wr)/nr
]
TRACE PROPERTY nmos_rf_25ud18_6t wr wr 0 
TRACE PROPERTY nmos_rf_25ud18_6t lr lr 0
TRACE PROPERTY nmos_rf_25ud18_6t nr nr 0

DEVICE nmos_rf_33 ngate_nthin_33 d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf_33> [
   property lr,wr,nr
   nr = count(ngate_rf_33)
   wr = ((perimeter_coincide(ngate_rf_33,s_tndiff)+ perimeter_coincide(ngate_rf_33,d_tndiff))/2)/nr
   lr = (area(ngate_rf_33)/wr)/nr
]
TRACE PROPERTY nmos_rf_33 wr wr 0
TRACE PROPERTY nmos_rf_33 lr lr 0
TRACE PROPERTY nmos_rf_33 nr nr 0

DEVICE nmos_rf_33_6t ngate_nthin_33_6t d_tndiff(D) poly_rf(G) s_tndiff(S) rwel(B) DNW(NG) rfdmy56(PG) <ngate_rf_33> netlist model nmos_rf_33_6t [
   property lr,wr,nr
   nr = count(ngate_rf_33)
   wr = ((perimeter_coincide(ngate_rf_33,s_tndiff)+ perimeter_coincide(ngate_rf_33,d_tndiff))/2)/nr
   lr = (area(ngate_rf_33)/wr)/nr
]
TRACE PROPERTY nmos_rf_33_6t wr wr 0 
TRACE PROPERTY nmos_rf_33_6t lr lr 0
TRACE PROPERTY nmos_rf_33_6t nr nr 0

DEVICE nmos_rf_33_nodnw ngate_nthin_33nodnw d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf_33> netlist model nmos_rf_33 [
   property lr,wr,nr
   nr = count(ngate_rf_33)
   wr = ((perimeter_coincide(ngate_rf_33,s_tndiff)+ perimeter_coincide(ngate_rf_33,d_tndiff))/2)/nr
   lr = (area(ngate_rf_33)/wr)/nr
]
TRACE PROPERTY nmos_rf_33_nodnw wr wr 0
TRACE PROPERTY nmos_rf_33_nodnw lr lr 0
TRACE PROPERTY nmos_rf_33_nodnw nr nr 0

DEVICE nmos_rf_6t ngate_nthin_6t d_tndiff(D) poly_rf(G) s_tndiff(S) rwel(B) DNW(NG) rfdmy56(PG) <ngate_rf> netlist model nmos_rf_6t [
   property lr,wr,nr
   nr = count(ngate_rf)
   wr = ((perimeter_coincide(ngate_rf,s_tndiff)+ perimeter_coincide(ngate_rf,d_tndiff))/2)/nr
   lr = (area(ngate_rf)/wr)/nr
]
TRACE PROPERTY nmos_rf_6t wr wr 0 
TRACE PROPERTY nmos_rf_6t lr lr 0
TRACE PROPERTY nmos_rf_6t nr nr 0

DEVICE nmos_rf_cas_nw nthin_cas_nw d_tndiff(D) gate_rbc_casb(GB) s_tndiff_cas(S) psub(B) gate_rbc_cast(GT) [
  property lr,wr,nr,lrr,wrr,nrr
  nr  = count(gate_rbc_casb)
  nrr = count(gate_rbc_cast)
  wr  = (perimeter_coincide(gate_rbc_casb,s_tndiff_cas)/nr)
  wrr = (perimeter_coincide(gate_rbc_cast,d_tndiff)/nrr)
  lr  = (area(gate_rbc_casb)/wr/nr)
  lrr = (area(gate_rbc_cast)/wrr/nrr)
]
TRACE PROPERTY nmos_rf_cas_nw wr wr 0
TRACE PROPERTY nmos_rf_cas_nw lr lr 0
TRACE PROPERTY nmos_rf_cas_nw nr nr 0
TRACE PROPERTY nmos_rf_cas_nw wrr wrr 0
TRACE PROPERTY nmos_rf_cas_nw lrr lrr 0
TRACE PROPERTY nmos_rf_cas_nw nrr nrr 0

DEVICE nmos_rf_cross_nw nthin_xcouple_nw d_tndiff(DP) d_tndiff(DM) s_tndiff(S) psub(B) <gate_rbc_xcoup> (DP DM) [
  property lr,wr,nr
  nr = (count(gate_rbc_xcoup))/2
  wr = ((perimeter_coincide(gate_rbc_xcoup,s_tndiff)+ perimeter_coincide(gate_rbc_xcoup,d_tndiff))/2)/(2*nr)
  lr = (area(gate_rbc_xcoup)/wr)/(2*nr)
]
TRACE PROPERTY nmos_rf_cross_nw wr wr 0
TRACE PROPERTY nmos_rf_cross_nw lr lr 0
TRACE PROPERTY nmos_rf_cross_nw nr nr 0

DEVICE nmos_rf_diff_nw nthin_diff_nw d_tndiff(DP) gate_rbc_diff(GP) s_tndiff(S) psub(B) d_tndiff(DM) gate_rbc_diff(GM) [
  property lr,wr,nr
  nr = (count(gate_rbc_diff))/2
  wr = ((perimeter_coincide(gate_rbc_diff,s_tndiff)+ perimeter_coincide(gate_rbc_diff,d_tndiff))/2)/(2*nr)
  lr = (area(gate_rbc_diff)/wr)/(2*nr)
]
TRACE PROPERTY nmos_rf_diff_nw wr wr 0
TRACE PROPERTY nmos_rf_diff_nw lr lr 0
TRACE PROPERTY nmos_rf_diff_nw nr nr 0

DEVICE nmos_rf_hvt ngate_nthin_hv d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rfhv> [
   property lr,wr,nr
   nr = count(ngate_rfhv)
   wr = ((perimeter_coincide(ngate_rfhv,s_tndiff)+ perimeter_coincide(ngate_rfhv,d_tndiff))/2)/nr
   lr = (area(ngate_rfhv)/wr)/nr
]
TRACE PROPERTY nmos_rf_hvt wr wr 0
TRACE PROPERTY nmos_rf_hvt lr lr 0
TRACE PROPERTY nmos_rf_hvt nr nr 0

DEVICE nmos_rf_hvt_6t ngate_nthin_hv_6t d_tndiff(D) poly_rf(G) s_tndiff(S) rwel(B) DNW(NG) rfdmy56(PG) <ngate_rfhv> netlist model nmos_rf_hvt_6t [
   property lr,wr,nr
   nr = count(ngate_rfhv)
   wr = ((perimeter_coincide(ngate_rfhv,s_tndiff)+ perimeter_coincide(ngate_rfhv,d_tndiff))/2)/nr
   lr = (area(ngate_rfhv)/wr)/nr
]
TRACE PROPERTY nmos_rf_hvt_6t wr wr 0 
TRACE PROPERTY nmos_rf_hvt_6t lr lr 0
TRACE PROPERTY nmos_rf_hvt_6t nr nr 0

DEVICE nmos_rf_hvt_nodnw ngate_nthin_hvnodnw d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rfhv> netlist model nmos_rf_hvt [
   property lr,wr,nr
   nr = count(ngate_rfhv)
   wr = ((perimeter_coincide(ngate_rfhv,s_tndiff)+ perimeter_coincide(ngate_rfhv,d_tndiff))/2)/nr
   lr = (area(ngate_rfhv)/wr)/nr
]
TRACE PROPERTY nmos_rf_hvt_nodnw wr wr 0
TRACE PROPERTY nmos_rf_hvt_nodnw lr lr 0
TRACE PROPERTY nmos_rf_hvt_nodnw nr nr 0

DEVICE nmos_rf_lvt ngate_nthin_lv d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rflv> [
   property lr,wr,nr
   nr = count(ngate_rflv)
   wr = ((perimeter_coincide(ngate_rflv,s_tndiff)+ perimeter_coincide(ngate_rflv,d_tndiff))/2)/nr
   lr = (area(ngate_rflv)/wr)/nr
]
TRACE PROPERTY nmos_rf_lvt wr wr 0
TRACE PROPERTY nmos_rf_lvt lr lr 0
TRACE PROPERTY nmos_rf_lvt nr nr 0

DEVICE nmos_rf_lvt_6t ngate_nthin_lv_6t d_tndiff(D) poly_rf(G) s_tndiff(S) rwel(B) DNW(NG) rfdmy56(PG) <ngate_rflv> netlist model nmos_rf_lvt_6t [
   property lr,wr,nr
   nr = count(ngate_rflv)
   wr = ((perimeter_coincide(ngate_rflv,s_tndiff)+ perimeter_coincide(ngate_rflv,d_tndiff))/2)/nr
   lr = (area(ngate_rflv)/wr)/nr
]
TRACE PROPERTY nmos_rf_lvt_6t wr wr 0 
TRACE PROPERTY nmos_rf_lvt_6t lr lr 0
TRACE PROPERTY nmos_rf_lvt_6t nr nr 0

DEVICE nmos_rf_lvt_nodnw ngate_nthin_lvnodnw d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rflv> netlist model nmos_rf_lvt [
   property lr,wr,nr
   nr = count(ngate_rflv)
   wr = ((perimeter_coincide(ngate_rflv,s_tndiff)+ perimeter_coincide(ngate_rflv,d_tndiff))/2)/nr
   lr = (area(ngate_rflv)/wr)/nr
]
TRACE PROPERTY nmos_rf_lvt_nodnw wr wr 0
TRACE PROPERTY nmos_rf_lvt_nodnw lr lr 0
TRACE PROPERTY nmos_rf_lvt_nodnw nr nr 0

DEVICE nmos_rf_mlvt ngate_nthin_mlv d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rfmlv> [
   property lr,wr,nr
   nr = count(ngate_rfmlv)
   wr = ((perimeter_coincide(ngate_rfmlv,s_tndiff)+ perimeter_coincide(ngate_rfmlv,d_tndiff))/2)/nr
   lr = (area(ngate_rfmlv)/wr)/nr
]
TRACE PROPERTY nmos_rf_mlvt wr wr 0
TRACE PROPERTY nmos_rf_mlvt lr lr 0
TRACE PROPERTY nmos_rf_mlvt nr nr 0

DEVICE nmos_rf_mlvt_6t ngate_nthin_mlv_6t d_tndiff(D) poly_rf(G) s_tndiff(S) rwel(B) DNW(NG) rfdmy56(PG) <ngate_rfmlv> netlist model nmos_rf_mlvt_6t [
   property lr,wr,nr
   nr = count(ngate_rfmlv)
   wr = ((perimeter_coincide(ngate_rfmlv,s_tndiff)+ perimeter_coincide(ngate_rfmlv,d_tndiff))/2)/nr
   lr = (area(ngate_rfmlv)/wr)/nr
]
TRACE PROPERTY nmos_rf_mlvt_6t wr wr 0 
TRACE PROPERTY nmos_rf_mlvt_6t lr lr 0
TRACE PROPERTY nmos_rf_mlvt_6t nr nr 0

DEVICE nmos_rf_mlvt_nodnw ngate_nthin_mlvnodnw d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rfmlv> netlist model nmos_rf_mlvt [
   property lr,wr,nr
   nr = count(ngate_rfmlv)
   wr = ((perimeter_coincide(ngate_rfmlv,s_tndiff)+ perimeter_coincide(ngate_rfmlv,d_tndiff))/2)/nr
   lr = (area(ngate_rfmlv)/wr)/nr
]
TRACE PROPERTY nmos_rf_mlvt_nodnw wr wr 0
TRACE PROPERTY nmos_rf_mlvt_nodnw lr lr 0
TRACE PROPERTY nmos_rf_mlvt_nodnw nr nr 0

DEVICE nmos_rf_na18 ngate_nthin_18na d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf_18na> [
   property lr,wr,nr
   nr = count(ngate_rf_18na)
   wr = ((perimeter_coincide(ngate_rf_18na,s_tndiff)+ perimeter_coincide(ngate_rf_18na,d_tndiff))/2)/nr
   lr = (area(ngate_rf_18na)/wr)/nr
]
TRACE PROPERTY nmos_rf_na18 wr wr 0
TRACE PROPERTY nmos_rf_na18 lr lr 0
TRACE PROPERTY nmos_rf_na18 nr nr 0

DEVICE nmos_rf_nodnw ngate_nthin_nodnw d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf> netlist model nmos_rf [
   property lr,wr,nr
   nr = count(ngate_rf)
   wr = ((perimeter_coincide(ngate_rf,s_tndiff)+ perimeter_coincide(ngate_rf,d_tndiff))/2)/nr
   lr = (area(ngate_rf)/wr)/nr
]
TRACE PROPERTY nmos_rf_nodnw wr wr 0
TRACE PROPERTY nmos_rf_nodnw lr lr 0
TRACE PROPERTY nmos_rf_nodnw nr nr 0

DEVICE nmos_rf_rdk ngate_nthin_rdk d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf> [
   property lr,wr,nr
   nr = count(ngate_rf)
   wr = ((perimeter_coincide(ngate_rf,s_tndiff)+ perimeter_coincide(ngate_rf,d_tndiff))/2)/nr
   lr = (area(ngate_rf)/wr)/nr
]
TRACE PROPERTY nmos_rf_rdk wr wr 0
TRACE PROPERTY nmos_rf_rdk lr lr 0
TRACE PROPERTY nmos_rf_rdk nr nr 0

DEVICE nmoscap vargt poly(PLUS) tndiff(MINUS) <nthin> netlist model nmoscap [
       property lr,wr
       nr = count(vargt)
       lr = perimeter_coincide(vargt,nthin)/nr/2
       A  = area(vargt)/nr
       wr = A/lr
]
TRACE PROPERTY nmoscap wr wr 0
TRACE PROPERTY nmoscap lr lr 0

DEVICE nmoscap_18 vargt_18 poly(PLUS) tndiff(MINUS) <nthin> netlist model nmoscap_18 [
       property lr,wr
       nr = count(vargt_18)
       lr = perimeter_coincide(vargt_18,nthin)/nr/2
       A  = area(vargt_18)/nr
       wr = A/lr
]
TRACE PROPERTY nmoscap_18 wr wr 0
TRACE PROPERTY nmoscap_18 lr lr 0

DEVICE nmoscap_25 vargt_25 poly(PLUS) tndiff(MINUS) <nthin> netlist model nmoscap_25 [
       property lr,wr
       nr = count(vargt_25)
       lr = perimeter_coincide(vargt_25,nthin)/nr/2
       A  = area(vargt_25)/nr
       wr = A/lr
]
TRACE PROPERTY nmoscap_25 wr wr 0
TRACE PROPERTY nmoscap_25 lr lr 0

DEVICE nmoscap_33 vargt_33 poly(PLUS) tndiff(MINUS) <nthin> netlist model nmoscap_33 [
       property lr,wr
       nr = count(vargt_33)
       lr = perimeter_coincide(vargt_33,nthin)/nr/2
       A  = area(vargt_33)/nr
       wr = A/lr
]
TRACE PROPERTY nmoscap_33 wr wr 0
TRACE PROPERTY nmoscap_33 lr lr 0

DEVICE nmoscap_lpg vargtlpg poly(PLUS) tndiff(MINUS) <nthin> netlist model nmoscap_lpg [
       property lr,wr
       nr = count(vargtlpg)
       lr = perimeter_coincide(vargtlpg,nthin)/nr/2
       A  = area(vargtlpg)/nr
       wr = A/lr
]
TRACE PROPERTY nmoscap_lpg wr wr 0
TRACE PROPERTY nmoscap_lpg lr lr 0

DEVICE pdio_hia_rf pdio_hia tpdiff(PLUS) nxwell(MINUS) RFDMY_hia(BULK) netlist model pdio_hia_rf [
  property al,aw

  A_HIA = area(pdio_hia)
  P_HIA = perimeter(pdio_hia)
  P_2_HIA = P_HIA * P_HIA
  AHIA4 = A_HIA * 16
  KKK = P_2_HIA-AHIA4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  al = (P_HIA+SQ)/4
  aw = (P_HIA-SQ)/4
]  

TRACE PROPERTY pdio_hia_rf al al 0
TRACE PROPERTY pdio_hia_rf aw aw 0

DEVICE pmos_rf pgate_pthin d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf> [
   property lr,wr,nr
   nr = count(pgate_rf)
   wr = ((perimeter_coincide(pgate_rf,s_tpdiff)+ perimeter_coincide(pgate_rf,d_tpdiff))/2)/nr
   lr = (area(pgate_rf)/wr)/nr
]
TRACE PROPERTY pmos_rf wr wr 0
TRACE PROPERTY pmos_rf lr lr 0
TRACE PROPERTY pmos_rf nr nr 0

DEVICE pmos_rf_18 pgate_pthin_18 d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf_18> [
   property lr,wr,nr
   nr = count(pgate_rf_18)
   wr = ((perimeter_coincide(pgate_rf_18,s_tpdiff)+ perimeter_coincide(pgate_rf_18,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_18)/wr)/nr
]
TRACE PROPERTY pmos_rf_18 wr wr 0
TRACE PROPERTY pmos_rf_18 lr lr 0
TRACE PROPERTY pmos_rf_18 nr nr 0

DEVICE pmos_rf_18_5t pgate_pthin_18_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rf_18> netlist model pmos_rf_18_5t [
   property lr,wr,nr
   nr = count(pgate_rf_18)
   wr = ((perimeter_coincide(pgate_rf_18,s_tpdiff)+ perimeter_coincide(pgate_rf_18,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_18)/wr)/nr
]
TRACE PROPERTY pmos_rf_18_5t wr wr 0 
TRACE PROPERTY pmos_rf_18_5t lr lr 0
TRACE PROPERTY pmos_rf_18_5t nr nr 0

DEVICE pmos_rf_18_nw pgate_pthin_18nw d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf_18> [
   property lr,wr,nr
   nr = count(pgate_rf_18)
   wr = ((perimeter_coincide(pgate_rf_18,s_tpdiff)+ perimeter_coincide(pgate_rf_18,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_18)/wr)/nr
]
TRACE PROPERTY pmos_rf_18_nw wr wr 0
TRACE PROPERTY pmos_rf_18_nw lr lr 0
TRACE PROPERTY pmos_rf_18_nw nr nr 0

DEVICE pmos_rf_18_nw_5t pgate_pthin_18nw_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rf_18> netlist model pmos_rf_18_nw_5t [
   property lr,wr,nr
   nr = count(pgate_rf_18)
   wr = ((perimeter_coincide(pgate_rf_18,s_tpdiff)+ perimeter_coincide(pgate_rf_18,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_18)/wr)/nr
]
TRACE PROPERTY pmos_rf_18_nw_5t wr wr 0 
TRACE PROPERTY pmos_rf_18_nw_5t lr lr 0
TRACE PROPERTY pmos_rf_18_nw_5t nr nr 0

DEVICE pmos_rf_25 pgate_pthin_25 d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf_25> [
   property lr,wr,nr
   nr = count(pgate_rf_25)
   wr = ((perimeter_coincide(pgate_rf_25,s_tpdiff)+ perimeter_coincide(pgate_rf_25,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_25)/wr)/nr
]
TRACE PROPERTY pmos_rf_25 wr wr 0
TRACE PROPERTY pmos_rf_25 lr lr 0
TRACE PROPERTY pmos_rf_25 nr nr 0

DEVICE pmos_rf_25_5t pgate_pthin_25_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rf_25> netlist model pmos_rf_25_5t [
   property lr,wr,nr
   nr = count(pgate_rf_25)
   wr = ((perimeter_coincide(pgate_rf_25,s_tpdiff)+ perimeter_coincide(pgate_rf_25,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_25)/wr)/nr
]
TRACE PROPERTY pmos_rf_25_5t wr wr 0 
TRACE PROPERTY pmos_rf_25_5t lr lr 0
TRACE PROPERTY pmos_rf_25_5t nr nr 0

DEVICE pmos_rf_25_nw pgate_pthin_25nw d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf_25> [
   property lr,wr,nr
   nr = count(pgate_rf_25)
   wr = ((perimeter_coincide(pgate_rf_25,s_tpdiff)+ perimeter_coincide(pgate_rf_25,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_25)/wr)/nr
]
TRACE PROPERTY pmos_rf_25_nw wr wr 0
TRACE PROPERTY pmos_rf_25_nw lr lr 0
TRACE PROPERTY pmos_rf_25_nw nr nr 0

DEVICE pmos_rf_25_nw_5t pgate_pthin_25nw_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rf_25> netlist model pmos_rf_25_nw_5t [
   property lr,wr,nr
   nr = count(pgate_rf_25)
   wr = ((perimeter_coincide(pgate_rf_25,s_tpdiff)+ perimeter_coincide(pgate_rf_25,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_25)/wr)/nr
]
TRACE PROPERTY pmos_rf_25_nw_5t wr wr 0 
TRACE PROPERTY pmos_rf_25_nw_5t lr lr 0
TRACE PROPERTY pmos_rf_25_nw_5t nr nr 0

DEVICE pmos_rf_25_nwod pgate_pthin_25nwod d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf_25od> netlist model pmos_rf_33_nw [
   property lr,wr,nr
   nr = count(pgate_rf_25od)
   wr = ((perimeter_coincide(pgate_rf_25od,s_tpdiff)+ perimeter_coincide(pgate_rf_25od,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_25od)/wr)/nr
]
TRACE PROPERTY pmos_rf_25_nwod wr wr 0
TRACE PROPERTY pmos_rf_25_nwod lr lr 0
TRACE PROPERTY pmos_rf_25_nwod nr nr 0

DEVICE pmos_rf_25_nwud pgate_pthin_25nwud d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf_25ud> netlist model pmos_rf_18_nw [
   property lr,wr,nr
   nr = count(pgate_rf_25ud)
   wr = ((perimeter_coincide(pgate_rf_25ud,s_tpdiff)+ perimeter_coincide(pgate_rf_25ud,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_25ud)/wr)/nr
]
TRACE PROPERTY pmos_rf_25_nwud wr wr 0
TRACE PROPERTY pmos_rf_25_nwud lr lr 0
TRACE PROPERTY pmos_rf_25_nwud nr nr 0

DEVICE pmos_rf_25od pgate_pthin_25od d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf_25od> netlist model pmos_rf_33 [
   property lr,wr,nr
   nr = count(pgate_rf_25od)
   wr = ((perimeter_coincide(pgate_rf_25od,s_tpdiff)+ perimeter_coincide(pgate_rf_25od,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_25od)/wr)/nr
]
TRACE PROPERTY pmos_rf_25od wr wr 0
TRACE PROPERTY pmos_rf_25od lr lr 0
TRACE PROPERTY pmos_rf_25od nr nr 0

DEVICE pmos_rf_25od33_5t pgate_pthin_25od_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rf_25od> netlist model pmos_rf_33_5t [
   property lr,wr,nr
   nr = count(pgate_rf_25od)
   wr = ((perimeter_coincide(pgate_rf_25od,s_tpdiff)+ perimeter_coincide(pgate_rf_25od,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_25od)/wr)/nr
]
TRACE PROPERTY pmos_rf_25od33_5t wr wr 0 
TRACE PROPERTY pmos_rf_25od33_5t lr lr 0
TRACE PROPERTY pmos_rf_25od33_5t nr nr 0

DEVICE pmos_rf_25od33_nw_5t pgate_pthin_25nwod_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rf_25od> netlist model pmos_rf_33_nw_5t [
   property lr,wr,nr
   nr = count(pgate_rf_25od)
   wr = ((perimeter_coincide(pgate_rf_25od,s_tpdiff)+ perimeter_coincide(pgate_rf_25od,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_25od)/wr)/nr
]
TRACE PROPERTY pmos_rf_25od33_nw_5t wr wr 0 
TRACE PROPERTY pmos_rf_25od33_nw_5t lr lr 0
TRACE PROPERTY pmos_rf_25od33_nw_5t nr nr 0

DEVICE pmos_rf_25ud pgate_pthin_25ud d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf_25ud> netlist model pmos_rf_18 [
   property lr,wr,nr
   nr = count(pgate_rf_25ud)
   wr = ((perimeter_coincide(pgate_rf_25ud,s_tpdiff)+ perimeter_coincide(pgate_rf_25ud,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_25ud)/wr)/nr
]
TRACE PROPERTY pmos_rf_25ud wr wr 0
TRACE PROPERTY pmos_rf_25ud lr lr 0
TRACE PROPERTY pmos_rf_25ud nr nr 0

DEVICE pmos_rf_25ud18_5t pgate_pthin_25ud_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rf_25ud> netlist model pmos_rf_18_5t [
   property lr,wr,nr
   nr = count(pgate_rf_25ud)
   wr = ((perimeter_coincide(pgate_rf_25ud,s_tpdiff)+ perimeter_coincide(pgate_rf_25ud,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_25ud)/wr)/nr
]
TRACE PROPERTY pmos_rf_25ud18_5t wr wr 0 
TRACE PROPERTY pmos_rf_25ud18_5t lr lr 0
TRACE PROPERTY pmos_rf_25ud18_5t nr nr 0

DEVICE pmos_rf_25ud18_nw_5t pgate_pthin_25nwud_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rf_25ud> netlist model pmos_rf_18_nw_5t [
   property lr,wr,nr
   nr = count(pgate_rf_25ud)
   wr = ((perimeter_coincide(pgate_rf_25ud,s_tpdiff)+ perimeter_coincide(pgate_rf_25ud,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_25ud)/wr)/nr
]
TRACE PROPERTY pmos_rf_25ud18_nw_5t wr wr 0 
TRACE PROPERTY pmos_rf_25ud18_nw_5t lr lr 0
TRACE PROPERTY pmos_rf_25ud18_nw_5t nr nr 0

DEVICE pmos_rf_33 pgate_pthin_33 d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf_33> [
   property lr,wr,nr
   nr = count(pgate_rf_33)
   wr = ((perimeter_coincide(pgate_rf_33,s_tpdiff)+ perimeter_coincide(pgate_rf_33,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_33)/wr)/nr
]
TRACE PROPERTY pmos_rf_33 wr wr 0
TRACE PROPERTY pmos_rf_33 lr lr 0
TRACE PROPERTY pmos_rf_33 nr nr 0

DEVICE pmos_rf_33_5t pgate_pthin_33_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rf_33> netlist model pmos_rf_33_5t [
   property lr,wr,nr
   nr = count(pgate_rf_33)
   wr = ((perimeter_coincide(pgate_rf_33,s_tpdiff)+ perimeter_coincide(pgate_rf_33,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_33)/wr)/nr
]
TRACE PROPERTY pmos_rf_33_5t wr wr 0 
TRACE PROPERTY pmos_rf_33_5t lr lr 0
TRACE PROPERTY pmos_rf_33_5t nr nr 0

DEVICE pmos_rf_33_nw pgate_pthin_33nw d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf_33> [
   property lr,wr,nr
   nr = count(pgate_rf_33)
   wr = ((perimeter_coincide(pgate_rf_33,s_tpdiff)+ perimeter_coincide(pgate_rf_33,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_33)/wr)/nr
]
TRACE PROPERTY pmos_rf_33_nw wr wr 0
TRACE PROPERTY pmos_rf_33_nw lr lr 0
TRACE PROPERTY pmos_rf_33_nw nr nr 0

DEVICE pmos_rf_33_nw_5t pgate_pthin_33nw_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rf_33> netlist model pmos_rf_33_nw_5t [
   property lr,wr,nr
   nr = count(pgate_rf_33)
   wr = ((perimeter_coincide(pgate_rf_33,s_tpdiff)+ perimeter_coincide(pgate_rf_33,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_33)/wr)/nr
]
TRACE PROPERTY pmos_rf_33_nw_5t wr wr 0 
TRACE PROPERTY pmos_rf_33_nw_5t lr lr 0
TRACE PROPERTY pmos_rf_33_nw_5t nr nr 0

DEVICE pmos_rf_5t pgate_pthin_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rf> netlist model pmos_rf_5t [
   property lr,wr,nr
   nr = count(pgate_rf)
   wr = ((perimeter_coincide(pgate_rf,s_tpdiff)+ perimeter_coincide(pgate_rf,d_tpdiff))/2)/nr
   lr = (area(pgate_rf)/wr)/nr
]
TRACE PROPERTY pmos_rf_5t wr wr 0 
TRACE PROPERTY pmos_rf_5t lr lr 0
TRACE PROPERTY pmos_rf_5t nr nr 0

DEVICE pmos_rf_hvt pgate_pthin_hv d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rfhv> [
   property lr,wr,nr
   nr = count(pgate_rfhv)
   wr = ((perimeter_coincide(pgate_rfhv,s_tpdiff)+ perimeter_coincide(pgate_rfhv,d_tpdiff))/2)/nr
   lr = (area(pgate_rfhv)/wr)/nr
]
TRACE PROPERTY pmos_rf_hvt wr wr 0
TRACE PROPERTY pmos_rf_hvt lr lr 0
TRACE PROPERTY pmos_rf_hvt nr nr 0

DEVICE pmos_rf_hvt_5t pgate_pthin_hv_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rfhv> netlist model pmos_rf_hvt_5t [
   property lr,wr,nr
   nr = count(pgate_rfhv)
   wr = ((perimeter_coincide(pgate_rfhv,s_tpdiff)+ perimeter_coincide(pgate_rfhv,d_tpdiff))/2)/nr
   lr = (area(pgate_rfhv)/wr)/nr
]
TRACE PROPERTY pmos_rf_hvt_5t wr wr 0 
TRACE PROPERTY pmos_rf_hvt_5t lr lr 0
TRACE PROPERTY pmos_rf_hvt_5t nr nr 0

DEVICE pmos_rf_hvt_nw pgate_pthin_hvnw d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rfhv> [
   property lr,wr,nr
   nr = count(pgate_rfhv)
   wr = ((perimeter_coincide(pgate_rfhv,s_tpdiff)+ perimeter_coincide(pgate_rfhv,d_tpdiff))/2)/nr
   lr = (area(pgate_rfhv)/wr)/nr
]
TRACE PROPERTY pmos_rf_hvt_nw wr wr 0
TRACE PROPERTY pmos_rf_hvt_nw lr lr 0
TRACE PROPERTY pmos_rf_hvt_nw nr nr 0

DEVICE pmos_rf_hvt_nw_5t pgate_pthin_hvnw_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rfhv> netlist model pmos_rf_hvt_nw_5t [
   property lr,wr,nr
   nr = count(pgate_rfhv)
   wr = ((perimeter_coincide(pgate_rfhv,s_tpdiff)+ perimeter_coincide(pgate_rfhv,d_tpdiff))/2)/nr
   lr = (area(pgate_rfhv)/wr)/nr
]
TRACE PROPERTY pmos_rf_hvt_nw_5t wr wr 0 
TRACE PROPERTY pmos_rf_hvt_nw_5t lr lr 0
TRACE PROPERTY pmos_rf_hvt_nw_5t nr nr 0

DEVICE pmos_rf_lvt pgate_pthin_lv d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rflv> [
   property lr,wr,nr
   nr = count(pgate_rflv)
   wr = ((perimeter_coincide(pgate_rflv,s_tpdiff)+ perimeter_coincide(pgate_rflv,d_tpdiff))/2)/nr
   lr = (area(pgate_rflv)/wr)/nr
]
TRACE PROPERTY pmos_rf_lvt wr wr 0
TRACE PROPERTY pmos_rf_lvt lr lr 0
TRACE PROPERTY pmos_rf_lvt nr nr 0

DEVICE pmos_rf_lvt_5t pgate_pthin_lv_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rflv> netlist model pmos_rf_lvt_5t [
   property lr,wr,nr
   nr = count(pgate_rflv)
   wr = ((perimeter_coincide(pgate_rflv,s_tpdiff)+ perimeter_coincide(pgate_rflv,d_tpdiff))/2)/nr
   lr = (area(pgate_rflv)/wr)/nr
]
TRACE PROPERTY pmos_rf_lvt_5t wr wr 0 
TRACE PROPERTY pmos_rf_lvt_5t lr lr 0
TRACE PROPERTY pmos_rf_lvt_5t nr nr 0

DEVICE pmos_rf_lvt_nw pgate_pthin_lvnw d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rflv> [
   property lr,wr,nr
   nr = count(pgate_rflv)
   wr = ((perimeter_coincide(pgate_rflv,s_tpdiff)+ perimeter_coincide(pgate_rflv,d_tpdiff))/2)/nr
   lr = (area(pgate_rflv)/wr)/nr
]
TRACE PROPERTY pmos_rf_lvt_nw wr wr 0
TRACE PROPERTY pmos_rf_lvt_nw lr lr 0
TRACE PROPERTY pmos_rf_lvt_nw nr nr 0

DEVICE pmos_rf_lvt_nw_5t pgate_pthin_lvnw_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rflv> netlist model pmos_rf_lvt_nw_5t [
   property lr,wr,nr
   nr = count(pgate_rflv)
   wr = ((perimeter_coincide(pgate_rflv,s_tpdiff)+ perimeter_coincide(pgate_rflv,d_tpdiff))/2)/nr
   lr = (area(pgate_rflv)/wr)/nr
]
TRACE PROPERTY pmos_rf_lvt_nw_5t wr wr 0 
TRACE PROPERTY pmos_rf_lvt_nw_5t lr lr 0
TRACE PROPERTY pmos_rf_lvt_nw_5t nr nr 0

DEVICE pmos_rf_mlvt pgate_pthin_mlv d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rfmlv> [
   property lr,wr,nr
   nr = count(pgate_rfmlv)
   wr = ((perimeter_coincide(pgate_rfmlv,s_tpdiff)+ perimeter_coincide(pgate_rfmlv,d_tpdiff))/2)/nr
   lr = (area(pgate_rfmlv)/wr)/nr
]
TRACE PROPERTY pmos_rf_mlvt wr wr 0
TRACE PROPERTY pmos_rf_mlvt lr lr 0
TRACE PROPERTY pmos_rf_mlvt nr nr 0

DEVICE pmos_rf_mlvt_5t pgate_pthin_mlv_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rfmlv> netlist model pmos_rf_mlvt_5t [
   property lr,wr,nr
   nr = count(pgate_rfmlv)
   wr = ((perimeter_coincide(pgate_rfmlv,s_tpdiff)+ perimeter_coincide(pgate_rfmlv,d_tpdiff))/2)/nr
   lr = (area(pgate_rfmlv)/wr)/nr
]
TRACE PROPERTY pmos_rf_mlvt_5t wr wr 0 
TRACE PROPERTY pmos_rf_mlvt_5t lr lr 0
TRACE PROPERTY pmos_rf_mlvt_5t nr nr 0

DEVICE pmos_rf_mlvt_nw pgate_pthin_mlvnw d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rfmlv> [
   property lr,wr,nr
   nr = count(pgate_rfmlv)
   wr = ((perimeter_coincide(pgate_rfmlv,s_tpdiff)+ perimeter_coincide(pgate_rfmlv,d_tpdiff))/2)/nr
   lr = (area(pgate_rfmlv)/wr)/nr
]
TRACE PROPERTY pmos_rf_mlvt_nw wr wr 0
TRACE PROPERTY pmos_rf_mlvt_nw lr lr 0
TRACE PROPERTY pmos_rf_mlvt_nw nr nr 0

DEVICE pmos_rf_mlvt_nw_5t pgate_pthin_mlvnw_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rfmlv> netlist model pmos_rf_mlvt_nw_5t [
   property lr,wr,nr
   nr = count(pgate_rfmlv)
   wr = ((perimeter_coincide(pgate_rfmlv,s_tpdiff)+ perimeter_coincide(pgate_rfmlv,d_tpdiff))/2)/nr
   lr = (area(pgate_rfmlv)/wr)/nr
]
TRACE PROPERTY pmos_rf_mlvt_nw_5t wr wr 0 
TRACE PROPERTY pmos_rf_mlvt_nw_5t lr lr 0
TRACE PROPERTY pmos_rf_mlvt_nw_5t nr nr 0

DEVICE pmos_rf_nw pgate_pthin_nw d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf> [
   property lr,wr,nr
   nr = count(pgate_rf)
   wr = ((perimeter_coincide(pgate_rf,s_tpdiff)+ perimeter_coincide(pgate_rf,d_tpdiff))/2)/nr
   lr = (area(pgate_rf)/wr)/nr
]
TRACE PROPERTY pmos_rf_nw wr wr 0
TRACE PROPERTY pmos_rf_nw lr lr 0
TRACE PROPERTY pmos_rf_nw nr nr 0

DEVICE pmos_rf_nw_5t pgate_pthin_nw_5t d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) rfdmy56(PG) <pgate_rf> netlist model pmos_rf_nw_5t [
   property lr,wr,nr
   nr = count(pgate_rf)
   wr = ((perimeter_coincide(pgate_rf,s_tpdiff)+ perimeter_coincide(pgate_rf,d_tpdiff))/2)/nr
   lr = (area(pgate_rf)/wr)/nr
]
TRACE PROPERTY pmos_rf_nw_5t wr wr 0 
TRACE PROPERTY pmos_rf_nw_5t lr lr 0
TRACE PROPERTY pmos_rf_nw_5t nr nr 0

DEVICE pmos_rf_rdk pgate_pthin_rdk d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf> [
   property lr,wr,nr
   nr = count(pgate_rf)
   wr = ((perimeter_coincide(pgate_rf,s_tpdiff)+ perimeter_coincide(pgate_rf,d_tpdiff))/2)/nr
   lr = (area(pgate_rf)/wr)/nr
]
TRACE PROPERTY pmos_rf_rdk wr wr 0
TRACE PROPERTY pmos_rf_rdk lr lr 0
TRACE PROPERTY pmos_rf_rdk nr nr 0

DEVICE pmoscap_rf pvar_rf poly(PLUS) tpdiff(MINUS) DNW(BULK) <vargt_rf> <pthin> [
  property lr,wr,br,gr
  gr = count(pthin)
  br = count(vargt_rf)/gr
  wr = (perimeter_coincide(vargt_rf,tpdiff)/2)/(br*gr)
  lr = (area(vargt_rf)/wr)/(br*gr)
]
TRACE PROPERTY pmoscap_rf lr lr 0
TRACE PROPERTY pmoscap_rf wr wr 0
TRACE PROPERTY pmoscap_rf br br 0
TRACE PROPERTY pmoscap_rf gr gr 0

DEVICE pmoscap_rf18 pvar_rf18 poly(PLUS) tpdiff(MINUS) DNW(BULK) <vargt_rf18> <pthin> [
  property lr,wr,br,gr
  gr = count(pthin)
  br = count(vargt_rf18)/gr
  wr = (perimeter_coincide(vargt_rf18,tpdiff)/2)/(br*gr)
  lr = (area(vargt_rf18)/wr)/(br*gr)
]
TRACE PROPERTY pmoscap_rf18 lr lr 0
TRACE PROPERTY pmoscap_rf18 wr wr 0
TRACE PROPERTY pmoscap_rf18 br br 0
TRACE PROPERTY pmoscap_rf18 gr gr 0

DEVICE pmoscap_rf25 pvar_rf25 poly(PLUS) tpdiff(MINUS) DNW(BULK) <vargt_rf25> <pthin> [
  property lr,wr,br,gr
  gr = count(pthin)
  br = count(vargt_rf25)/gr
  wr = (perimeter_coincide(vargt_rf25,tpdiff)/2)/(br*gr)
  lr = (area(vargt_rf25)/wr)/(br*gr)
]
TRACE PROPERTY pmoscap_rf25 lr lr 0
TRACE PROPERTY pmoscap_rf25 wr wr 0
TRACE PROPERTY pmoscap_rf25 br br 0
TRACE PROPERTY pmoscap_rf25 gr gr 0

#IFDEF extract_pnwdio
DEVICE D(pnwdio) pnwdio_r psub nxwell netlist model nwdio
#ENDIF
LVS FILTER D(pnwdio) LAYOUT OPEN

DEVICE probe1 PROBEM1 metal1(TOP) PROBEM1_T(BULK) [
property a,pj
   a  = area(PROBEM1)
   pj = perimeter(PROBEM1) 
]
TRACE PROPERTY probe1 a a 0
TRACE PROPERTY probe1 pj pj 0

DEVICE probe2 PROBEM2 metal2(TOP) PROBEM2_T(BULK) [
property a,pj
   a  = area(PROBEM2)
   pj = perimeter(PROBEM2) 
]
TRACE PROPERTY probe2 a a 0
TRACE PROPERTY probe2 pj pj 0

DEVICE probe3 PROBEM3 metal3(TOP) PROBEM3_T(BULK) [
property a,pj
   a  = area(PROBEM3)
   pj = perimeter(PROBEM3) 
]
TRACE PROPERTY probe3 a a 0
TRACE PROPERTY probe3 pj pj 0

DEVICE probe4 PROBEM4 metal4(TOP) PROBEM4_T(BULK) [
property a,pj
   a  = area(PROBEM4)
   pj = perimeter(PROBEM4) 
]
TRACE PROPERTY probe4 a a 0
TRACE PROPERTY probe4 pj pj 0

DEVICE probe5 PROBEM5 metal5(TOP) PROBEM5_T(BULK) [
property a,pj
   a  = area(PROBEM5)
   pj = perimeter(PROBEM5) 
]
TRACE PROPERTY probe5 a a 0
TRACE PROPERTY probe5 pj pj 0

DEVICE probe6 PROBEM6 metal6(TOP) PROBEM6_T(BULK) [
property a,pj
   a  = area(PROBEM6)
   pj = perimeter(PROBEM6) 
]
TRACE PROPERTY probe6 a a 0
TRACE PROPERTY probe6 pj pj 0

DEVICE probe7 PROBEM7 metal7(TOP) PROBEM7_T(BULK) [
property a,pj
   a  = area(PROBEM7)
   pj = perimeter(PROBEM7) 
]
TRACE PROPERTY probe7 a a 0
TRACE PROPERTY probe7 pj pj 0

//

DEVICE rfesd_rf1 rfesd_r1 metal10(APAD) cpad(CPAD) nxwell(DCPAD) psub(GNODE) [
       property lay
       lay = 6
]       
TRACE PROPERTY rfesd_rf1 lay lay 0

DEVICE rfesd_rf2 rfesd_r2 metal10(APAD) cpad(CPAD) nxwell(DCPAD) psub(GNODE) [
       property lay
       lay = 6
]       
TRACE PROPERTY rfesd_rf2 lay lay 0

DEVICE rfesd_rf3 rfesd_r3 metal10(APAD) cpad(CPAD) nxwell(DCPAD) psub(GNODE) [
       property lay
       lay = 6
]       
TRACE PROPERTY rfesd_rf3 lay lay 0

DEVICE rfesd_rf4 rfesd_r4 metal10(APAD) cpad(CPAD) nxwell(DCPAD) psub(GNODE) [
       property lay
       lay = 6
]       
TRACE PROPERTY rfesd_rf4 lay lay 0

DEVICE rfesd_rf5 rfesd_r5 metal10(APAD) cpad(CPAD) nxwell(DCPAD) psub(GNODE) [
       property lay
       lay = 6
]       
TRACE PROPERTY rfesd_rf5 lay lay 0

DEVICE rfesd_rf6 rfesd_r6 metal10(APAD) cpad(CPAD) nxwell(DCPAD) psub(GNODE) [
       property lay
       lay = 6
]       
TRACE PROPERTY rfesd_rf6 lay lay 0

DEVICE rfesd_rf7 rfesd_r7 metal10(APAD) cpad(CPAD) nxwell(DCPAD) psub(GNODE) [
       property lay
       lay = 6
]       
TRACE PROPERTY rfesd_rf7 lay lay 0

DEVICE rfesd_rf8 rfesd_r8 metal10(APAD) cpad(CPAD) nxwell(DCPAD) psub(GNODE) [
       property lay
       lay = 6
]       
TRACE PROPERTY rfesd_rf8 lay lay 0

DEVICE rm1 mt1res metal1(PLUS) metal1(MINUS) netlist model rm1w (PLUS MINUS) [
	property w,l
	w = perimeter_coincide(mt1res,metal1)/2
	l = area(mt1res)/w
]
	TRACE PROPERTY rm1 w  w  0
	TRACE PROPERTY rm1 l  l  0

#IFDEF AP_UT
DEVICE rm10 mtAPres metal10(PLUS) metal10(MINUS) netlist model rmap_ut (PLUS MINUS) [
	property w,l
	w = perimeter_coincide(mtAPres,metal10)/2
	l = area(mtAPres)/w
]
TRACE PROPERTY rm10 w  w  0
TRACE PROPERTY rm10 l  l  0
#ELSE
DEVICE rm10 mtAPres metal10(PLUS) metal10(MINUS) netlist model rm10 (PLUS MINUS) [
	property w,l
	w = perimeter_coincide(mtAPres,metal10)/2
	l = area(mtAPres)/w
]
TRACE PROPERTY rm10 w  w  0
TRACE PROPERTY rm10 l  l  0
#ENDIF


DEVICE rm2 mt2res metal2(PLUS) metal2(MINUS) netlist model rmxw (PLUS MINUS) [
	property w,l
	w = perimeter_coincide(mt2res,metal2)/2
	l = area(mt2res)/w
]
TRACE PROPERTY rm2 w  w  0
TRACE PROPERTY rm2 l  l  0

DEVICE rm3 mt3res metal3(PLUS) metal3(MINUS) netlist model rmxw (PLUS MINUS) [
	property w,l
	w = perimeter_coincide(mt3res,metal3)/2
	l = area(mt3res)/w
]
TRACE PROPERTY rm3 w  w  0
TRACE PROPERTY rm3 l  l  0

DEVICE rm4 mt4res metal4(PLUS) metal4(MINUS) netlist model rmxw (PLUS MINUS) [
	property w,l
	w = perimeter_coincide(mt4res,metal4)/2
	l = area(mt4res)/w
]
TRACE PROPERTY rm4 w  w  0
TRACE PROPERTY rm4 l  l  0

DEVICE rm5 mt5res metal5(PLUS) metal5(MINUS) netlist model rmxw (PLUS MINUS) [
	property w,l
	w = perimeter_coincide(mt5res,metal5)/2
	l = area(mt5res)/w
]
TRACE PROPERTY rm5 w  w  0
TRACE PROPERTY rm5 l  l  0

DEVICE rm6 mt6res metal6(PLUS) metal6(MINUS) netlist model rmxw (PLUS MINUS) [
	property w,l
	w = perimeter_coincide(mt6res,metal6)/2
	l = area(mt6res)/w
]
TRACE PROPERTY rm6 w  w  0
TRACE PROPERTY rm6 l  l  0

DEVICE rm7 mt7res metal7(PLUS) metal7(MINUS) netlist model rmxw (PLUS MINUS) [
	property w,l
	w = perimeter_coincide(mt7res,metal7)/2
	l = area(mt7res)/w
]
TRACE PROPERTY rm7 w  w  0
TRACE PROPERTY rm7 l  l  0

DEVICE rm8 mt8res metal8(PLUS) metal8(MINUS) netlist model rmzw (PLUS MINUS) [
	property w,l
	w = perimeter_coincide(mt8res,metal8)/2
	l = area(mt8res)/w
]
	TRACE PROPERTY rm8 w  w  0
	TRACE PROPERTY rm8 l  l  0


DEVICE rm9 mt9res metal9(PLUS) metal9(MINUS) netlist model rmt (PLUS MINUS) [

	property w,l
	w = perimeter_coincide(mt9res,metal9)/2
	l = area(mt9res)/w
]
	TRACE PROPERTY rm9 w  w  0
	TRACE PROPERTY rm9 l  l  0

DEVICE rnodl rnodl_r tndiff(PLUS) tndiff(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rnodl_r,tndiff)/2
   l = area(rnodl_r)/w
]
TRACE PROPERTY rnodl l l 0
TRACE PROPERTY rnodl w w 0

DEVICE rnodl_m rnodl_mr tndiff(PLUS) tndiff(MINUS) psub(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rnodl_mr,tndiff)/2
   lr = area(rnodl_mr)/wr
]
TRACE PROPERTY rnodl_m lr lr 0
TRACE PROPERTY rnodl_m wr wr 0

DEVICE rnods rnods_r tndiff(PLUS) tndiff(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rnods_r,tndiff)/2
   l = area(rnods_r)/w
]
TRACE PROPERTY rnods l l 0
TRACE PROPERTY rnods w w 0

DEVICE rnods_m rnods_mr tndiff(PLUS) tndiff(MINUS) psub(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rnods_mr,tndiff)/2
   lr = area(rnods_mr)/wr
]
TRACE PROPERTY rnods_m lr lr 0
TRACE PROPERTY rnods_m wr wr 0

DEVICE rnodwo rnodwo_r tndiff(PLUS) tndiff(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rnodwo_r,tndiff)/2
   l = area(rnodwo_r)/w
]
TRACE PROPERTY rnodwo l l 0
TRACE PROPERTY rnodwo w w 0

DEVICE rnodwo_m rnodwo_mr tndiff(PLUS) tndiff(MINUS) psub(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rnodwo_mr,tndiff)/2
   lr = area(rnodwo_mr)/wr
]
TRACE PROPERTY rnodwo_m lr lr 0
TRACE PROPERTY rnodwo_m wr wr 0

DEVICE rnpolyl rnpolyl_r poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rnpolyl_r,poly)/2
   l = area(rnpolyl_r)/w
]
TRACE PROPERTY rnpolyl l l 0
TRACE PROPERTY rnpolyl w w 0

DEVICE rnpolyl_m rnpolyl_d poly(PLUS) poly(MINUS) poly_term(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rnpolyl_d,poly)/2
   lr = area(rnpolyl_d)/wr
]
TRACE PROPERTY rnpolyl_m lr lr 0
TRACE PROPERTY rnpolyl_m wr wr 0

DEVICE rnpolys rnpolys_r poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rnpolys_r,poly)/2
   l = area(rnpolys_r)/w
]
TRACE PROPERTY rnpolys l l 0
TRACE PROPERTY rnpolys w w 0

DEVICE rnpolys_m rnpolys_d poly(PLUS) poly(MINUS) poly_term(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rnpolys_d,poly)/2
   lr = area(rnpolys_d)/wr
]
TRACE PROPERTY rnpolys_m lr lr 0
TRACE PROPERTY rnpolys_m wr wr 0

DEVICE rnpolywo rnpolywo_r poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rnpolywo_r,poly)/2
   l = area(rnpolywo_r)/w
]
TRACE PROPERTY rnpolywo l l 0
TRACE PROPERTY rnpolywo w w 0

DEVICE rnpolywo_m rnpolywo_d poly(PLUS) poly(MINUS) poly_term(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rnpolywo_d,poly)/2
   lr = area(rnpolywo_d)/wr
]
TRACE PROPERTY rnpolywo_m lr lr 0
TRACE PROPERTY rnpolywo_m wr wr 0

DEVICE rnwod nwod_r nxwell(PLUS) nxwell(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(nwod_r,nxwell)/2
   l = area(nwod_r)/w
]
TRACE PROPERTY rnwod l l 0
TRACE PROPERTY rnwod w w 0

DEVICE rnwod_m nwod_mr nxwell(PLUS) nxwell(MINUS) psub(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(nwod_mr,nxwell)/2
   lr = area(nwod_mr)/wr
]
TRACE PROPERTY rnwod_m lr lr 0
TRACE PROPERTY rnwod_m wr wr 0

DEVICE rnwsti nwsti_r nxwell(PLUS) nxwell(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(nwsti_r,nxwell)/2
   l = area(nwsti_r)/w
]
TRACE PROPERTY rnwsti l l 0
TRACE PROPERTY rnwsti w w 0

DEVICE rnwsti_m nwsti_mr nxwell(PLUS) nxwell(MINUS) psub(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(nwsti_mr,nxwell)/2
   lr = area(nwsti_mr)/wr
]
TRACE PROPERTY rnwsti_m lr lr 0
TRACE PROPERTY rnwsti_m wr wr 0

DEVICE rpodl rpodl_r tpdiff(PLUS) tpdiff(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rpodl_r,tpdiff)/2
   l = area(rpodl_r)/w
]
TRACE PROPERTY rpodl l l 0
TRACE PROPERTY rpodl w w 0

DEVICE rpodl_m rpodl_mr tpdiff(PLUS) tpdiff(MINUS) nxwell(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rpodl_mr,tpdiff)/2
   lr = area(rpodl_mr)/wr
]
TRACE PROPERTY rpodl_m lr lr 0
TRACE PROPERTY rpodl_m wr wr 0

DEVICE rpods rpods_r tpdiff(PLUS) tpdiff(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rpods_r,tpdiff)/2
   l = area(rpods_r)/w
]
TRACE PROPERTY rpods l l 0
TRACE PROPERTY rpods w w 0

DEVICE rpods_m rpods_mr tpdiff(PLUS) tpdiff(MINUS) nxwell(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rpods_mr,tpdiff)/2
   lr = area(rpods_mr)/wr
]
TRACE PROPERTY rpods_m lr lr 0
TRACE PROPERTY rpods_m wr wr 0

DEVICE rpodwo rpodwo_r tpdiff(PLUS) tpdiff(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rpodwo_r,tpdiff)/2
   l = area(rpodwo_r)/w
]
TRACE PROPERTY rpodwo l l 0
TRACE PROPERTY rpodwo w w 0

DEVICE rpodwo_m rpodwo_mr tpdiff(PLUS) tpdiff(MINUS) nxwell(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rpodwo_mr,tpdiff)/2
   lr = area(rpodwo_mr)/wr
]
TRACE PROPERTY rpodwo_m lr lr 0
TRACE PROPERTY rpodwo_m wr wr 0

DEVICE rppolyl rppolyl_r poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rppolyl_r,poly)/2
   l = area(rppolyl_r)/w
]
TRACE PROPERTY rppolyl l l 0
TRACE PROPERTY rppolyl w w 0

DEVICE rppolyl_m rppolyl_d poly(PLUS) poly(MINUS) poly_term(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rppolyl_d,poly)/2
   lr = area(rppolyl_d)/wr
]
TRACE PROPERTY rppolyl_m lr lr 0
TRACE PROPERTY rppolyl_m wr wr 0

DEVICE rppolyl_rf rppolyl_rf poly(PLUS) poly(MINUS) nxwell(BULK) (PLUS MINUS) [
property l,w
  w = perimeter_coincide(rppolyl_rf,poly)/2
  l = area(rppolyl_rf)/w
]
TRACE PROPERTY rppolyl_rf w w 0
TRACE PROPERTY rppolyl_rf l l 0

DEVICE rppolyl_rf_rdk rppolyl_rf_rdk poly(PLUS) poly(MINUS) nxwell(BULK) (PLUS MINUS) [
property l,w
  w = perimeter_coincide(rppolyl_rf_rdk,poly)/2
  l = area(rppolyl_rf_rdk)/w
]
TRACE PROPERTY rppolyl_rf_rdk w w 0
TRACE PROPERTY rppolyl_rf_rdk l l 0

DEVICE rppolys rppolys_r poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rppolys_r,poly)/2
   l = area(rppolys_r)/w
]
TRACE PROPERTY rppolys l l 0
TRACE PROPERTY rppolys w w 0

DEVICE rppolys_m rppolys_d poly(PLUS) poly(MINUS) poly_term(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rppolys_d,poly)/2
   lr = area(rppolys_d)/wr
]
TRACE PROPERTY rppolys_m lr lr 0
TRACE PROPERTY rppolys_m wr wr 0

DEVICE rppolys_rf rppolys_rf poly(PLUS) poly(MINUS) nxwell(BULK) (PLUS MINUS) [
property l,w
  w = perimeter_coincide(rppolys_rf,poly)/2
  l = area(rppolys_rf)/w
]
TRACE PROPERTY rppolys_rf w w 0
TRACE PROPERTY rppolys_rf l l 0

DEVICE rppolys_rf_rdk rppolys_rf_rdk poly(PLUS) poly(MINUS) nxwell(BULK) (PLUS MINUS) [
property l,w
  w = perimeter_coincide(rppolys_rf_rdk,poly)/2
  l = area(rppolys_rf_rdk)/w
]
TRACE PROPERTY rppolys_rf_rdk w w 0
TRACE PROPERTY rppolys_rf_rdk l l 0

DEVICE rppolywo rppolywo_r poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rppolywo_r,poly)/2
   l = area(rppolywo_r)/w
]
TRACE PROPERTY rppolywo l l 0
TRACE PROPERTY rppolywo w w 0

DEVICE rppolywo_m rppolywo_d poly(PLUS) poly(MINUS) poly_term(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rppolywo_d,poly)/2
   lr = area(rppolywo_d)/wr
]
TRACE PROPERTY rppolywo_m lr lr 0
TRACE PROPERTY rppolywo_m wr wr 0

DEVICE rppolywo_rf rppolywo_rf poly(PLUS) poly(MINUS) nxwell(BULK) (PLUS MINUS) [
property l,w
  w = perimeter_coincide(rppolywo_rf,poly)/2
  l = area(rppolywo_rf)/w
]
TRACE PROPERTY rppolywo_rf w w 0
TRACE PROPERTY rppolywo_rf l l 0

DEVICE rppolywo_rf_rdk rppolywo_rf_rdk poly(PLUS) poly(MINUS) nxwell(BULK) (PLUS MINUS) [
property l,w
  w = perimeter_coincide(rppolywo_rf_rdk,poly)/2
  l = area(rppolywo_rf_rdk)/w
]
TRACE PROPERTY rppolywo_rf_rdk w w 0
TRACE PROPERTY rppolywo_rf_rdk l l 0

sbd_w = EXT schottky_p schottky_n < 0.325 OPPOSITE REGION
DEVICE sbd_rf sbd_rfdnw schottky_p(PLUS) schottky_n(MINUS) psub(BULK) <sbd_w> [
   property l,w,nf
   nf = count(schottky_p)
   w = perimeter_coincide(schottky_p,sbd_w)/2/nf
   l = area(schottky_p)/w/nf

]
TRACE PROPERTY sbd_rf nf nf 0
TRACE PROPERTY sbd_rf w w 0
TRACE PROPERTY sbd_rf l l 0

DEVICE sbd_rf_nw sbd_rfnw schottky_p(PLUS) schottky_n(MINUS) psub(BULK) <sbd_w> [
   property l,w,nf
   nf = count(schottky_p)
   w = perimeter_coincide(schottky_p,sbd_w)/2/nf
   l = area(schottky_p)/w/nf

]
TRACE PROPERTY sbd_rf_nw nf nf 0
TRACE PROPERTY sbd_rf_nw w w 0
TRACE PROPERTY sbd_rf_nw l l 0

DEVICE sline_gscpw_mu sline_cpw_mu_r sline_m9p(PLUS) sline_m9m(MINUS) sline_m8(BULK) <INDDMY> <sline_m9a> (PLUS MINUS) [
   PROPERTY l,w,s,lay
   lay = 9
   w = perimeter_coincide(sline_m9p,INDDMY)
   l = area(sline_m9a)/w
   s = ( area(INDDMY)/l - w ) / 2
]
TRACE PROPERTY sline_gscpw_mu l l 0
TRACE PROPERTY sline_gscpw_mu s s 0
TRACE PROPERTY sline_gscpw_mu w w 0
TRACE PROPERTY sline_gscpw_mu lay lay 0

DEVICE sline_ms_mu sline_ms_mu_r sline_m9p(PLUS) sline_m9m(MINUS) metal1(BULK) <INDDMY> <sline_m9a> (PLUS MINUS) [
   PROPERTY l,w,lay
   lay = 9
   w = perimeter_coincide(sline_m9p,INDDMY)
   l = area(sline_m9a)/w
]
TRACE PROPERTY sline_ms_mu l l 0
TRACE PROPERTY sline_ms_mu w w 0
TRACE PROPERTY sline_ms_mu lay lay 0

std_w1 = INT std_ind < 31 OPPOSITE REGION PARALLEL ONLY EXCLUDE SHIELDED // "31" is a trade number from spice model
std_w  = ( RECTANGLE std_w1 ORTHOGONAL ONLY ) NOT INTERACT indm9

DEVICE spiral_std_mu_z std_ind indm9p(PLUS) indm9m(MINUS) psub(BULK) <IND_RAD> <IND_NR> <IND_GDIS> <IND_S> <std_w> [
   PROPERTY w,nr,rad,lay,gdis,spacing
   lay = 9
   rad = (perimeter(IND_RAD) - 5e-7*2)/2
   gdis = (perimeter(IND_GDIS) - 5e-7*2)/2
   nw = count(std_w)
   w = (perimeter_inside(std_w,std_ind))/(nw*2)
   nnr = ( perimeter(IND_NR) - 5e-9*2 ) / 2
   nr = ( nnr / 1e-8 ) * 0.25
   spacing = ( perimeter(IND_S) - 5e-7*2 ) / 2
]
  TRACE PROPERTY spiral_std_mu_z lay lay 0
  TRACE PROPERTY spiral_std_mu_z w w 0.05
  TRACE PROPERTY spiral_std_mu_z nr nr 0
  TRACE PROPERTY spiral_std_mu_z rad rad 0
  TRACE PROPERTY spiral_std_mu_z gdis gdis 0
  TRACE PROPERTY spiral_std_mu_z spacing spacing 0

STD_IND_CHECK { @ VIA8 is needed for connection of M9 and M8 in Std. inductor.

  A = std_ind1 NOT INTERACT IND_RAD
  A1 = std_ind2 INTERACT IND_RAD
  B = A AND A1
  B NOT INTERACT VIA8
  C = std_ind_m INTERACT IND_RAD
  C NOT INTERACT VIA8
}
STD_IND_CHECK.1 { @ VIA7 INTERACT std_mu_z inductor is forbidden.
  std_ind AND VIA7
}


std_w1_rdk = INT std_ind_rdk < 31 OPPOSITE REGION PARALLEL ONLY EXCLUDE SHIELDED // "31" is a trade number from spice model
std_w_rdk  = ( RECTANGLE std_w1_rdk ORTHOGONAL ONLY ) NOT INTERACT indm9

DEVICE spiral_std_mu_z_rdk std_ind_rdk indm9p(PLUS) indm9m(MINUS) psub(BULK) <IND_RAD> <IND_NR> <IND_GDIS> <IND_S> <std_w_rdk> [
   PROPERTY w,nr,rad,lay,gdis,spacing
   lay = 9
   rad = (perimeter(IND_RAD) - 5e-7*2)/2
   gdis = (perimeter(IND_GDIS) - 5e-7*2)/2
   nw = count(std_w_rdk)
   w = (perimeter_inside(std_w_rdk,std_ind_rdk))/(nw*2)
   nnr = ( perimeter(IND_NR) - 5e-9*2 ) / 2
   nr = ( nnr / 1e-8 ) * 0.25
   spacing = ( perimeter(IND_S) - 5e-7*2 ) / 2
]
  TRACE PROPERTY spiral_std_mu_z_rdk lay lay 0
  TRACE PROPERTY spiral_std_mu_z_rdk w w 0.05
  TRACE PROPERTY spiral_std_mu_z_rdk nr nr 0
  TRACE PROPERTY spiral_std_mu_z_rdk rad rad 0
  TRACE PROPERTY spiral_std_mu_z_rdk gdis gdis 0
  TRACE PROPERTY spiral_std_mu_z_rdk spacing spacing 0


ct_w1  = INT ct_inda < 31 OPPOSITE REGION PARALLEL ONLY EXCLUDE SHIELDED // "31" is a trade number from spice model
ct_w2  = ( RECTANGLE ct_w1 ORTHOGONAL ONLY ) NOT INTERACT indm9
ct_w   = ct_w2 NOT INTERACT ct_ind2 
DEVICE spiral_sym_ct_mu_z ct_ind indm9p(PLUS) indm9m(MINUS) psub(BULK) indm9c(CTAP) <IND_RAD> <IND_NR> <IND_GDIS> <IND_S> <ct_w> <ct_inda> [
   PROPERTY w,nr,rad,lay,gdis,spacing
   lay = 9
   nnr = ( perimeter(IND_NR) - 5e-9*2 ) / 2
   nr = ( nnr / 1e-8 ) * 0.25
   rad = (perimeter(IND_RAD) - 5e-7*2)/2
   gdis = (perimeter(IND_GDIS) - 5e-7*2)/2
   nw = count(ct_w)
   w = (perimeter_inside(ct_w,ct_inda))/(nw*2)
   spacing = ( perimeter(IND_S) - 5e-7*2 ) / 2
]
  TRACE PROPERTY spiral_sym_ct_mu_z lay lay 0
  TRACE PROPERTY spiral_sym_ct_mu_z w w 0.05
  TRACE PROPERTY spiral_sym_ct_mu_z nr nr 0
  TRACE PROPERTY spiral_sym_ct_mu_z rad rad 0
  TRACE PROPERTY spiral_sym_ct_mu_z gdis gdis 0
  TRACE PROPERTY spiral_sym_ct_mu_z spacing spacing 0

CT_IND_CHECK { @ VIA8 is needed for connection of M9 and M8 in Cnt. inductor.
  A1 = ct_ind1 INTERACT IND_NR
  A2 = ct_ind2 INTERACT A1
  A3 = A2 AND ct_ind1 
  A = RECTANGLE A3 ORTHOGONAL ONLY   
  ( A NOT INTERACT VIA8 ) NOT INTERACT ptap
}
CT_IND_CHECK.1 { @ VIA6 INTERACT sym_ct_mu_z inductor is forbidden.
  ct_ind AND VIA6
}


ct_w_rdk = ct_w INTERACT RDKDMY
DEVICE spiral_sym_ct_mu_z_rdk ct_ind_rdk indm9p(PLUS) indm9m(MINUS) psub(BULK) indm9c(CTAP) <IND_RAD> <IND_NR> <IND_GDIS> <IND_S> <ct_w_rdk> <ct_inda> [
   PROPERTY w,nr,rad,lay,gdis,spacing
   lay = 9
   nnr = ( perimeter(IND_NR) - 5e-9*2 ) / 2
   nr = ( nnr / 1e-8 ) * 0.25
   rad = (perimeter(IND_RAD) - 5e-7*2)/2
   gdis = (perimeter(IND_GDIS) - 5e-7*2)/2
   nw = count(ct_w_rdk)
   w = (perimeter_inside(ct_w_rdk,ct_inda))/(nw*2)
   spacing = ( perimeter(IND_S) - 5e-7*2 ) / 2
]
  TRACE PROPERTY spiral_sym_ct_mu_z_rdk lay lay 0
  TRACE PROPERTY spiral_sym_ct_mu_z_rdk w w 0.05
  TRACE PROPERTY spiral_sym_ct_mu_z_rdk nr nr 0
  TRACE PROPERTY spiral_sym_ct_mu_z_rdk rad rad 0
  TRACE PROPERTY spiral_sym_ct_mu_z_rdk gdis gdis 0
  TRACE PROPERTY spiral_sym_ct_mu_z_rdk spacing spacing 0


sym_w1  = INT sym_ind < 31 OPPOSITE REGION PARALLEL ONLY EXCLUDE SHIELDED // "31" is a trade number from spice model
sym_w2  = ( RECTANGLE sym_w1 ORTHOGONAL ONLY ) NOT INTERACT indm9
sym_w   = sym_w2 NOT INTERACT sym_ind2
DEVICE spiral_sym_mu_z sym_ind indm9p(PLUS) indm9m(MINUS) psub(BULK) <IND_RAD> <IND_NR> <IND_GDIS> <IND_S> <sym_w> [
   PROPERTY w,nr,rad,lay,gdis,spacing
   lay = 9
   nnr = ( perimeter(IND_NR) - 5e-9*2 ) / 2
   nr = ( nnr / 1e-8 ) * 0.25
   rad = (perimeter(IND_RAD) - 5e-7*2)/2
   gdis = (perimeter(IND_GDIS) - 5e-7*2)/2
   nw = count(sym_w)
   w = (perimeter_inside(sym_w,sym_ind))/(nw*2)
   spacing = ( perimeter(IND_S) - 5e-7*2 ) / 2
]
  TRACE PROPERTY spiral_sym_mu_z lay lay 0
  TRACE PROPERTY spiral_sym_mu_z w w 0.05
  TRACE PROPERTY spiral_sym_mu_z nr nr 0
  TRACE PROPERTY spiral_sym_mu_z rad rad 0
  TRACE PROPERTY spiral_sym_mu_z gdis gdis 0
  TRACE PROPERTY spiral_sym_mu_z spacing spacing 0

SYM_IND_CHECK { @ VIA8 is needed for connection of M9 and M8 in Sym. inductor. 
  A1 = sym_ind1 INTERACT IND_NR
  A2 = sym_ind2 INTERACT A1
  A3 = A2 AND sym_ind1 
  A = RECTANGLE A3 ORTHOGONAL ONLY
  ( A NOT INTERACT VIA8 ) NOT INTERACT ptap
}
SYM_IND_CHECK.1 { @ VIA7 INTERACT sym_mu_z inductor is forbidden.
  sym_ind AND VIA7
}


sym_w1_rdk  = INT sym_ind_rdk < 31 OPPOSITE REGION PARALLEL ONLY EXCLUDE SHIELDED // "31" is a trade number from spice model
sym_w2_rdk  = ( RECTANGLE sym_w1_rdk ORTHOGONAL ONLY ) NOT INTERACT indm9
sym_w_rdk   = sym_w2_rdk NOT INTERACT sym_ind2
DEVICE spiral_sym_mu_z_rdk sym_ind_rdk indm9p(PLUS) indm9m(MINUS) psub(BULK) <IND_RAD> <IND_NR> <IND_GDIS> <IND_S> <sym_w_rdk> [
   PROPERTY w,nr,rad,lay,gdis,spacing
   lay = 9
   nnr = ( perimeter(IND_NR) - 5e-9*2 ) / 2
   nr = ( nnr / 1e-8 ) * 0.25
   rad = (perimeter(IND_RAD) - 5e-7*2)/2
   gdis = (perimeter(IND_GDIS) - 5e-7*2)/2
   nw = count(sym_w_rdk)
   w = (perimeter_inside(sym_w_rdk,sym_ind_rdk))/(nw*2)
   spacing = ( perimeter(IND_S) - 5e-7*2 ) / 2
]
  TRACE PROPERTY spiral_sym_mu_z_rdk lay lay 0
  TRACE PROPERTY spiral_sym_mu_z_rdk w w 0.05
  TRACE PROPERTY spiral_sym_mu_z_rdk nr nr 0
  TRACE PROPERTY spiral_sym_mu_z_rdk rad rad 0
  TRACE PROPERTY spiral_sym_mu_z_rdk gdis gdis 0
  TRACE PROPERTY spiral_sym_mu_z_rdk spacing spacing 0


w_fac = EXT tpdiff_jvar tndiff_jvar < 0.29 OPPOSITE REGION
DEVICE xjvar jvar_rf tpdiff(PLUS) tndiff(MINUS) psub(BULK) <w_fac> <jvar3_rf> [
   property l,w,nr
   nr = count(jvar3_rf)
   w = (perimeter_coincide(jvar3_rf,w_fac)/nr)/2
   l = (area(jvar3_rf)/w)/nr
]
TRACE PROPERTY xjvar w w 0
TRACE PROPERTY xjvar l l 0
TRACE PROPERTY xjvar nr nr 0

w_fac1 = EXT tpdiff_jvar tndiff_jvar < 0.29 OPPOSITE REGION
DEVICE xjvar_nw jvar_rfnw tpdiff(PLUS) tndiff(MINUS) psub(BULK) <w_fac1> <jvar3_rf> [
   property l,w,nr
   nr = count(jvar3_rf)
   w = (perimeter_coincide(jvar3_rf,w_fac1)/nr)/2
   l = (area(jvar3_rf)/w)/nr
]
TRACE PROPERTY xjvar_nw w w 0
TRACE PROPERTY xjvar_nw l l 0
TRACE PROPERTY xjvar_nw nr nr 0

TVF FUNCTION device_function [/*

    package require CalibreLVS_DEVICE_DFM
    namespace import device::*
    proc catching_expr { arg } {
      	#puts "called catching_expr"
      	set rtval 0.0
      	if { [ catch {
            set rtval [ expr $arg ]
      	} result ] } {
            global errorCode
            set tmpError $errorCode
            #puts $result
            if { [ string match "ARITH UNDERFLOW *" $errorCode ] } {
            	#puts "$errorCode error caught during expr"
            	set rtval 0.0
            } elseif { [ string match "ARITH OVERFLOW *" $errorCode ] } {
	    	#puts "$errorCode error caught during expr"
            	set rtval 1e200
            } else {
            	#puts "error propagated during expr"
            	error $result $tmpError
            }
      	}
      	return $rtval
    }

    proc calc_sca { SCH SCV W L LR_EXT TOP_EXT BOT_EXT SCALE } {
  	set sca_sum1 0.0
  	set sca_sum2 0.0
  	set SCref 1.0
  	set slice_count1 [ $SCH slice_count ]
  	set slice_count2 [ $SCV slice_count ]

  	for { set i 0 } { $i < $slice_count1} { incr i } {
       	    set sca_sum1 [ expr { $sca_sum1 + ( ([$SCALE]*[$SCH w $i]) * ( ($SCref * $SCref/([$SCALE]*([$SCH a $i]+[$LR_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))) +  ($SCref * $SCref/([$SCALE]*([$SCH b $i]+[$LR_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))))) }]
       	}

  	for { set i 0 } { $i < $slice_count2} { incr i } {
            set sca_sum2 [ expr { $sca_sum2 + ( ([$SCALE]*[$SCV w $i]) * ( ($SCref * $SCref/([$SCALE]*([$SCV a $i]+[$BOT_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))) + ($SCref * $SCref/([$SCALE]*([$SCV b $i]+[$TOP_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))))) }]
       	}

  	return [ expr { ($sca_sum1 + $sca_sum2) / ( (([$SCALE]*[$W]) * ([$SCALE]*[$L])) * 1e12) }]
    }

    proc calc_scb {  SCH SCV W  L LR_EXT TOP_EXT BOT_EXT SCALE } {
  	set scb_sum1 0.0
	set scb_sum2 0.0
  	set SCref 1.0
  	set slice_count1 [ $SCH slice_count ]
  	set slice_count2 [ $SCV slice_count ]
  	for { set i 0 } { $i < $slice_count1} { incr i } {
  	    set exp_term1 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
  	    set exp_term2 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
  	    set exp_term3 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
    	    set exp_term4 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
   	    set exp_term5 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
  	    set exp_term6 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set scb_sum1 [ expr { $scb_sum1 + ( ([$SCALE]*[ $SCH w $i ])*1e6 * (   (([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6*( $exp_term1/10)) +   ($SCref*($exp_term2/100)) - (([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6*($exp_term3/10)) - (($SCref*($exp_term4/100))) + (([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6*( $exp_term5/10)) +   ($SCref*($exp_term6/100)) - (([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6*($exp_term7/10)) - ($SCref*($exp_term8/100))       )) } ]
     	}
   	for { set i 0 } { $i < $slice_count2} { incr i } {
	    set exp_term1 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term2 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term3 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term4 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term5 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term6 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set scb_sum2 [ expr { $scb_sum2 + ( ([$SCALE]*[$SCV w $i])*1e6 * (   (([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6*( $exp_term1/10)) +   ($SCref*($exp_term2/100)) - (([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6*($exp_term3/10)) - ($SCref*($exp_term4/100)) + (([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6*( $exp_term5/10)) +   ($SCref*($exp_term6/100)) - (([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6*($exp_term7/10)) - ($SCref*($exp_term8/100))       )) } ]
     	}
	return [ expr { ( $scb_sum1 + $scb_sum2)  / ( (([$SCALE]*[$W]) * ([$SCALE]*[$L])) *1e12) }]
    }

    proc calc_scc { SCH SCV W L LR_EXT TOP_EXT BOT_EXT SCALE } {
  	set scc_sum1 0.0
	set scc_sum2 0.0
	set SCref 1.0
	set slice_count1 [ $SCH slice_count ]
	set slice_count2 [ $SCV slice_count ]
	for { set i 0 } { $i < $slice_count1} { incr i } { 
	    set exp_term1 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term2 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term3 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term4 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term5 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term6 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set scc_sum1 [ expr { $scc_sum1 + ( ([$SCALE]*[$SCH w $i])*1e6 * (   (([$SCALE]*([$SCH a $i]+ [$LR_EXT]))*1e6*( $exp_term1/20)) +   ($SCref*($exp_term2/400)) - (([$SCALE]*([$SCH a $i]+[$L]+ [$LR_EXT]))*1e6*($exp_term3/20)) - ($SCref*($exp_term4/400)) + (([$SCALE]*([$SCH b $i]+ [$LR_EXT]))*1e6*( $exp_term5/20)) +   ($SCref*($exp_term6/400)) - (([$SCALE]*([$SCH b $i]+[$L]+ [$LR_EXT]))*1e6*($exp_term7/20)) - ($SCref*($exp_term8/400))       )) } ]
	}
	for { set i 0 } { $i < $slice_count2} { incr i } {
	    set exp_term1 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term2 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term3 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term4 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term5 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term6 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set scc_sum2 [ expr { $scc_sum2 + ( ([$SCALE]*[$SCV w $i])*1e6 * (   (([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6*( $exp_term1/20)) +   ($SCref*($exp_term2/400)) - (([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6*($exp_term3/20)) - ($SCref*($exp_term4/400)) + (([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6*( $exp_term5/20)) +   ($SCref*($exp_term6/400)) - (([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6*($exp_term7/20)) - ($SCref*($exp_term8/400))       )) } ]
	}
	return [ expr { ( $scc_sum1 + $scc_sum2)  / ( (([$SCALE]*[$W]) * ([$SCALE]*[$L])) *1e12) }]
    }
    proc calc_lod_sasb { dfm_vec drawn_width drawn_length units scale } {
       set measurments [ dfm_vec_measurements $dfm_vec ]
       set accum 0.0
       set Wsi [expr {[$drawn_width]*[$scale]} ]
       set Lsi [expr {[$drawn_length]*[$scale]} ]
       foreach segment $measurments {
           foreach { pw sa } $segment {
	        set pw [ expr {$pw*[$units]*[$scale]} ]
		set sa [ expr {$sa*[$units]*[$scale]} ]
		set val [expr {($pw/$Wsi)*1.0/($sa+0.5*$Lsi)} ]
                set accum [ expr {$accum + $val} ]
            }
        }
               return [ expr { ((1.0/$accum)-0.5*$Lsi)/[$scale] } ]
    }
    
    proc calc_lod_sa1sb1 { dfm_vec drawn_width drawn_length units scale } {
       set measurments [ dfm_vec_measurements $dfm_vec ]
       set accum 0.0
       set Wsi [expr {[$drawn_width]*[$scale]} ]
       set Lsi [expr {[$drawn_length]*[$scale]} ]
       foreach segment $measurments {
           foreach { pw sa } $segment {
	        set pw [ expr {$pw*[$units]*[$scale]} ]
		set sa [ expr {$sa*[$units]*[$scale]} ]
		set val [expr {($pw/$Wsi)*1.0/pow($sa+0.1*$Lsi,3)} ]
                set accum [ expr {$accum + $val} ]
            }
        }
               return [ expr { (pow(1.0/$accum,1.0/3)-0.1*$Lsi)/[$scale] } ]
    }

    proc calc_lod_sa2sb2 { dfm_vec drawn_width drawn_length units scale } {
       set measurments [ dfm_vec_measurements $dfm_vec ]
       set accum 0.0
       set Wsi [expr {[$drawn_width]*[$scale]} ]
       set Lsi [expr {[$drawn_length]*[$scale]} ]
       foreach segment $measurments {
           foreach { pw sa } $segment {
	        set pw [ expr {$pw*[$units]*[$scale]} ]
		set sa [ expr {$sa*[$units]*[$scale]} ]
		set val [expr {($pw/$Wsi)*sqrt(pow(5e-7/($sa+0.5*$Lsi),2)+1)} ]
                set accum [ expr {$accum + $val} ]
            }
        }
               return [ expr { ( 5e-7/sqrt(pow($accum,2)-1) - 0.5*$Lsi ) /[$scale] } ]
    }

    proc calc_lod_sa3sb3 { dfm_vec drawn_width drawn_length units scale } {
       set measurments [ dfm_vec_measurements $dfm_vec ]
       set accum 0.0
       set Wsi [expr {[$drawn_width]*[$scale]} ]
       set Lsi [expr {[$drawn_length]*[$scale]} ]
       foreach segment $measurments {
           foreach { pw sa } $segment {
	        set pw [ expr {$pw*[$units]*[$scale]} ]
		set sa [ expr {$sa*[$units]*[$scale]} ]
		set val [expr {($pw/$Wsi)/(1+pow(5e-7/($sa+0.1*$Lsi),3))} ]
                set accum [ expr {$accum + $val} ]
            }
        }
               return [ expr { ( 5e-7/pow(1.0/$accum - 1,1.0/3) - 0.1*$Lsi ) /[$scale] } ]
    }

    proc calc_sca_dfm__getsum { tclvec pgw ext units WPED } {
        
        # scale cancels out in this ratio, discarded
        # pgw = perpendicular gate width (L for sides, W for ends)
        # ext = encval extension (LR_EXT for sides, TOP_EXT/BOT_EXT for ends)
        
        set SCref 1.0
        set sum 0.0
        
        foreach segment $tclvec {
        	foreach { width encval } $segment {
        	    set width [ expr { $width * $units } ]
        	    set encval [ min $encval $WPED ]
        	    set encval [ expr { $encval * $units } ]
        	    set sum [ expr { $sum + $width * ( \
        		   $SCref * $SCref / ( $encval + $ext ) - \
        		   $SCref * $SCref / ( $encval + $pgw + $ext ) \
        		   ) } ]
        	}
        }
        
        return $sum
    }
    
    proc calc_sca_dfm { PER_1 PER_2 PAR_1 PAR_2 W L LR_EXT TOP_EXT BOT_EXT UNITS SCALE WPED} {
        
        set side_1 [ dfm_vec_measurements $PER_1 ]
        set side_2 [ dfm_vec_measurements $PER_2 ]
        set sides  [ concat $side_1 $side_2 ]
    
        set end_1  [ dfm_vec_measurements $PAR_1 ]
        set end_2  [ dfm_vec_measurements $PAR_2 ]
        
        set sum [ expr { [ calc_sca_dfm__getsum $sides [$L] [$LR_EXT] [$UNITS] [$WPED] ] + \
    			 [ calc_sca_dfm__getsum $end_1 [$W] [$BOT_EXT] [$UNITS] [$WPED] ] + \
    			 [ calc_sca_dfm__getsum $end_2 [$W] [$TOP_EXT] [$UNITS] [$WPED] ] } ]
        
        return [ expr { $sum / ( [$SCALE] * [$W] * [$SCALE] * [$L] * 1e12 ) } ]
    }	

    proc calc_scbscc_dfm__getsum { tclvec pgw ext units scale em d1 d2 WPED} {
    
        # pgw = perpendicular gate width (L for sides, W for ends)
        # ext = encval extension (LR_EXT for sides, TOP_EXT/BOT_EXT for ends)
        # em = multiplier for args to exp
        # d1 = denominator1 (for 1st and 3rd terms)
        # d2 = denominator2 (for 2nd and 4th terms)
        
        set SCref 1.0
        set sum 0.0
        set constant 1e6
        
        foreach segment $tclvec {
        	foreach { width encval } $segment {
        	    set width [ expr { $width * $units } ]
        	    set encval [ expr { $encval * $units } ]
        	    set encval [ min $encval $WPED ]
        	    set encval_1 [ expr { $scale * ( $encval + $ext ) } ]
        	    set encval_2 [ expr { $scale * ( $encval + $pgw + $ext ) } ]
                    set encval_1_exp [ catching_expr "exp( $em * $encval_1 * $constant / $SCref )" ]
                    set encval_2_exp [ catching_expr "exp( $em * $encval_2 * $constant / $SCref )" ]
        	    set sum [ expr { $sum + $scale * $width * $constant * ( \
        		       $encval_1 * $constant * ( $encval_1_exp/$d1 ) + \
    			       $SCref * ( $encval_1_exp/$d2 ) - \
    			       $encval_2 * $constant * ( $encval_2_exp/$d1 ) - \
    			       $SCref * ( $encval_2_exp/$d2 ) \
    			      ) } ]
    		}
        }
        
        return $sum
    }
    
    
    proc calc_scb_dfm { PER_1 PER_2 PAR_1 PAR_2 W L LR_EXT TOP_EXT BOT_EXT UNITS SCALE WPED } {
    
        set side_1 [ dfm_vec_measurements $PER_1 ]
        set side_2 [ dfm_vec_measurements $PER_2 ]
        set sides  [ concat $side_1 $side_2 ]
    
        set end_1  [ dfm_vec_measurements $PAR_1 ]
        set end_2  [ dfm_vec_measurements $PAR_2 ]
        
        set sum [ expr { [ calc_scbscc_dfm__getsum $sides [$L] [$LR_EXT] [$UNITS] [$SCALE] -10 10 100 [$WPED] ] + \
    			 [ calc_scbscc_dfm__getsum $end_1 [$W] [$BOT_EXT] [$UNITS] [$SCALE] -10 10 100 [$WPED] ] + \
    			 [ calc_scbscc_dfm__getsum $end_2 [$W] [$TOP_EXT] [$UNITS] [$SCALE] -10 10 100 [$WPED] ] } ]
        
        return [ expr { $sum / ( [$SCALE] * [$W] * [$SCALE] * [$L] * 1e12 ) } ]
    }

    proc calc_scc_dfm { PER_1 PER_2 PAR_1 PAR_2 W L LR_EXT TOP_EXT BOT_EXT UNITS SCALE WPED } {
    
        set side_1 [ dfm_vec_measurements $PER_1 ]
        set side_2 [ dfm_vec_measurements $PER_2 ]
        set sides  [ concat $side_1 $side_2 ]
        
        set end_1  [ dfm_vec_measurements $PAR_1 ]
        set end_2  [ dfm_vec_measurements $PAR_2 ]
        
        set sum [ expr { [ calc_scbscc_dfm__getsum $sides [$L] [$LR_EXT] [$UNITS] [$SCALE] -20 20 400 [$WPED] ] + \
			 [ calc_scbscc_dfm__getsum $end_1 [$W] [$BOT_EXT] [$UNITS] [$SCALE] -20 20 400 [$WPED] ] + \
			 [ calc_scbscc_dfm__getsum $end_2 [$W] [$TOP_EXT] [$UNITS] [$SCALE] -20 20 400 [$WPED] ] } ]
        
        return [ expr { $sum / ( [$SCALE] * [$W] * [$SCALE] * [$L] * 1e12 ) } ]
    }

    proc min { a b } {
            return [ expr { ($a < $b) ? $a : $b } ]
    }

*/]
// Serve X-resistor as an built-in resistor (for PATHCHK)
LVS DEVICE TYPE RESISTOR rm1 rm10 rm2 rm3 rm4 rm5 rm6 rm7 rm8 rm9 rnodl rnodl_m rnods rnods_m rnodwo rnodwo_m rnpolyl rnpolyl_m rnpolys rnpolys_m rnpolywo rnpolywo_m rnwod rnwod_m rnwsti rnwsti_m rpodl rpodl_m rpods rpods_m rpodwo rpodwo_m rppolyl rppolyl_m rppolyl_rf rppolyl_rf_rdk rppolys rppolys_m rppolys_rf rppolys_rf_rdk rppolywo rppolywo_m rppolywo_rf rppolywo_rf_rdk [POS=PLUS NEG=MINUS]
LVS REDUCE rppolyl_rf PARALLEL NO
LVS REDUCE rppolyl_rf SERIES PLUS MINUS NO
LVS REDUCE rppolyl_rf_rdk PARALLEL NO
LVS REDUCE rppolyl_rf_rdk SERIES PLUS MINUS NO
LVS REDUCE rppolys_rf PARALLEL NO
LVS REDUCE rppolys_rf SERIES PLUS MINUS NO
LVS REDUCE rppolys_rf_rdk PARALLEL NO
LVS REDUCE rppolys_rf_rdk SERIES PLUS MINUS NO
LVS REDUCE rppolywo_rf PARALLEL NO
LVS REDUCE rppolywo_rf SERIES PLUS MINUS NO
LVS REDUCE rppolywo_rf_rdk PARALLEL NO
LVS REDUCE rppolywo_rf_rdk SERIES PLUS MINUS NO

#IFDEF RC_DECK
//=============================
//======= Setup for PEX =======
//=============================
MASK SVDB DIRECTORY "svdb" XRC
//PEX MAGNIFY 1.0
//PEX DELAY                      none   //PENFIELD 0.7 MASK DIRECT

PEX EXTRACT EXCLUDE            "VDD" "AVDD" "VD33" "VDDSA" "VDDPST" "VDD5V"
PEX NETLIST                    "net.dist" HSPICE LAYOUTNAMES GROUND VSS LOCATION RCNAMED
PEX NETLIST SIMPLE             "net.simple" HSPICE LAYOUTNAMES LOCATION RCNAMED 		
//Back-annotation xcalibre flow
//PEX NETLIST                    "net.dist" HSPICE SOURCENAMES GROUND VSS LOCATION RCNAMED
//PEX NETLIST SIMPLE             "net.simple" HSPICE SOURCENAMES LOCATION  RCNAMED		 	    

PEX REPORT DISTRIBUTED         none  //"report.dist" ASCII LAYOUT MASK DIRECT
PEX REPORT LUMPED              none  //"report.lump" LAYOUT MASK DIRECT

//PEX REDUCE CC ABSOLUTE 10000000              		

PEX IDEAL XCELL                YES

// xcalibre capacitance and resistance file 
UNIT CAPACITANCE ff
UNIT RESISTANCE OHM
include /cad/libs/tsmc/oa/Calibre/rcx/rules


#ELSE

//#############################################
//# ERC CHECK                                 #
//#############################################
// Reports regions on a DNW layer that connect to more than one node.
LVS SOFTCHK DNW CONTACT
// Reports regions on a PROBEM1_T layer that connect to more than one node.
LVS SOFTCHK PROBEM1_T CONTACT
// Reports regions on a PROBEM2_T layer that connect to more than one node.
LVS SOFTCHK PROBEM2_T CONTACT
// Reports regions on a PROBEM3_T layer that connect to more than one node.
LVS SOFTCHK PROBEM3_T CONTACT
// Reports regions on a PROBEM4_T layer that connect to more than one node.
LVS SOFTCHK PROBEM4_T CONTACT
// Reports regions on a PROBEM5_T layer that connect to more than one node.
LVS SOFTCHK PROBEM5_T CONTACT
// Reports regions on a PROBEM6_T layer that connect to more than one node.
LVS SOFTCHK PROBEM6_T CONTACT
// Reports regions on a PROBEM7_T layer that connect to more than one node.
LVS SOFTCHK PROBEM7_T CONTACT
// Reports regions on a poly_term layer that connect to more than one node.
LVS SOFTCHK poly_term CONTACT
// Reports regions on a PROBEM1_T layer that connect to more than one node.
LVS SOFTCHK PROBEM1_T CONTACT
// Reports regions on a PROBEM2_T layer that connect to more than one node.
LVS SOFTCHK PROBEM2_T CONTACT
// Reports regions on a PROBEM3_T layer that connect to more than one node.
LVS SOFTCHK PROBEM3_T CONTACT
// Reports regions on a PROBEM4_T layer that connect to more than one node.
LVS SOFTCHK PROBEM4_T CONTACT
// Reports regions on a PROBEM5_T layer that connect to more than one node.
LVS SOFTCHK PROBEM5_T CONTACT
// Reports regions on a PROBEM6_T layer that connect to more than one node.
LVS SOFTCHK PROBEM6_T CONTACT
// Reports regions on a PROBEM7_T layer that connect to more than one node.
LVS SOFTCHK PROBEM7_T CONTACT
// Reports regions on a RFDMY_hia_psub layer that connect to more than one node.
LVS SOFTCHK RFDMY_hia_psub CONTACT
// Reports regions on a poly_term layer that connect to more than one node.
LVS SOFTCHK poly_term CONTACT
// Reports regions on a rfdmy56 layer that connect to more than one node.
LVS SOFTCHK rfdmy56 CONTACT
// Reports regions on a nxwell layer that connect to more than one node.
LVS SOFTCHK nxwell CONTACT
// Reports regions on a RFDMY_hia layer that connect to more than one node.
LVS SOFTCHK RFDMY_hia CONTACT
// Reports regions on a coll1 layer that connect to more than one node.
LVS SOFTCHK coll1 CONTACT
// Reports regions on a n_psub layer that connect to more than one node.
#IFNDEF NW_RING
	LVS SOFTCHK n_psub CONTACT
#ENDIF
// Reports regions on a psub layer that connect to more than one node.
LVS SOFTCHK psub CONTACT
// Reports regions on a psub_term layer that connect to more than one node.
LVS SOFTCHK psub_term CONTACT
// Reports regions on a rwel layer that connect to more than one node.
LVS SOFTCHK rwel CONTACT

#IFDEF WELL_TO_PG_CHECK
GROUP ERC_WELL_TO_PG_CHECK  npvss49 ppvdd49
ERC SELECT CHECK ERC_WELL_TO_PG_CHECK
#ENDIF

#IFDEF GATE_TO_PG_CHECK
GROUP ERC_GATE_TO_PG_CHECK  npvss150 ppvdd150
ERC SELECT CHECK ERC_GATE_TO_PG_CHECK
#ENDIF

#IFDEF DS_TO_PG_CHECK
GROUP ERC_DS_TO_PG_CHECK  mnpg mppg
ERC SELECT CHECK ERC_DS_TO_PG_CHECK
#ENDIF

#IFDEF FLOATING_WELL_CHECK
GROUP ERC_FLOATING_WELL_CHECK  floating.nxwell_float floating.psub
ERC SELECT CHECK ERC_FLOATING_WELL_CHECK
#ENDIF

//MOS erc_nmos_gates S/D connect to POWER&GROUND --mnpg*/
N1tndiff = NET tndiff POWER_NAME
T1tndiff = erc_nmos_gates TOUCH N1tndiff
N2tndiff = NET tndiff GROUND_NAME
T2tndiff = erc_nmos_gates TOUCH N2tndiff

#IFDEF DS_TO_PG_CHECK
mnpg { @ MOS connected to both power and ground
  T1tndiff AND T2tndiff
}
#ENDIF

//MOS erc_pmos_gates S/D connect to POWER&GROUND --mppg*/
N1tpdiff = NET tpdiff POWER_NAME
T1tpdiff = erc_pmos_gates TOUCH N1tpdiff
N2tpdiff = NET tpdiff GROUND_NAME
T2tpdiff = erc_pmos_gates TOUCH N2tpdiff

#IFDEF DS_TO_PG_CHECK
mppg { @ MOS connected to both power and ground
  T1tpdiff AND T2tpdiff
}
#ENDIF

#IFDEF FLOATING_WELL_CHECK
SCONNECT tndiff nxwell_float by nplug
floating.nxwell_float { @ nxwell_float is not connected to POWER
  no_power_path = PATHCHK !POWER nxwell_float PORTS ALSO
  direct_connect_ground = NET nxwell_float GROUND_NAME
  no_power_path or direct_connect_ground
}
#ENDIF

#IFDEF FLOATING_WELL_CHECK
floating.psub { @ psub is not connected to GROUND
  no_ground_path = PATHCHK !GROUND psub PORTS ALSO
  direct_connect_power = NET psub POWER_NAME
  no_ground_path or direct_connect_power
}
#ENDIF
gate1_not_IO2_GND = NET gate1_not_IO2_not_IO2 GROUND_NAME

#IFDEF GATE_TO_PG_CHECK
// gate1_not_IO2 connect to ground 
npvss150 { @ gate1_not_IO2 connected to GROUND
  gate1_not_IO2_GND1 = gate1_not_IO2_GND INTERACT N2tndiff == 2
  gate1_not_IO2_GND NOT gate1_not_IO2_GND1
}
#ENDIF

#IFDEF WELL_TO_PG_CHECK
// ntap connect to ground 
npvss49 { @ ntap connected to GROUND
  ntap_not_var = ntap NOT VAR
  NET ntap_not_var GROUND_NAME
}
#ENDIF

#IFDEF PATH_CHECK
// Nodes with a path to ground but not power 
ERC PATHCHK GROUND && !POWER
#ENDIF

#IFDEF PATH_CHECK
// Nodes with a path to power but not ground 
ERC PATHCHK POWER && !GROUND
#ENDIF

#IFDEF PATH_CHECK
// Nodes without a path to power and ground 
ERC PATHCHK !POWER && !GROUND NOFLOAT
#ENDIF

#IFDEF PATH_CHECK
ERC PATHCHK !LABELED NOFLOAT
#ENDIF
gate1_not_IO2_not_IO1 = gate1_not_IO2 NOT OD25_28
gate1_not_IO2_not_IO2 = gate1_not_IO2_not_IO1 NOT OD33
CONNECT gate1_not_IO2_not_IO2 poly
gate1_not_IO2_PWR = NET gate1_not_IO2_not_IO2 POWER_NAME

#IFDEF GATE_TO_PG_CHECK
// gate1_not_IO2 connect to power 
ppvdd150 { @ gate1_not_IO2 connected to POWER
  gate1_not_IO2_PWR1 = gate1_not_IO2_PWR INTERACT N1tpdiff == 2
  gate1_not_IO2_PWR NOT gate1_not_IO2_PWR1
}
#ENDIF

#IFDEF WELL_TO_PG_CHECK
// ptap connect to power 
ppvdd49 { @ ptap connected to POWER
  NET ptap POWER_NAME
}
#ENDIF

#ENDIF
////////////////////////////////////////////////////////////////////////////////
// STRAINED SILICON SEARCH DISTANCES
////////////////////////////////////////////////////////////////////////////////
all_sd = mdiff NOT gate1
}

package require CalibreDFM_DEVICE
tvf::SETLAYER nCore_WPEPROP = [
   device::enclosure_measurements -base gate_a1 -measurement c_nmcore_aux -orient all_sd -max_par 5 -max_per 5
]
tvf::SETLAYER pCore_WPEPROP = [
   device::enclosure_measurements -base gate_a1 -measurement c_pmcore_aux -orient all_sd -max_par 5 -max_per 5
]
tvf::SETLAYER nIO_WPEPROP = [
   device::enclosure_measurements -base gate_a1 -measurement c_nmIO_aux -orient all_sd -max_par 5 -max_per 5
]
tvf::SETLAYER pIO_WPEPROP = [
   device::enclosure_measurements -base gate_a1 -measurement c_pmIO_aux -orient all_sd -max_par 5 -max_per 5
]
tvf::SETLAYER nt_n_WPEPROP = [
   device::enclosure_measurements -base gate_a1 -measurement c_nt_n_aux -orient all_sd -max_par 5 -max_per 5
]
tvf::SETLAYER lod_PROP = [
   device::enclosure_measurements -base gate_a1 -measurement OD -orient all_sd -max_par 0  -max_per 60 
]
